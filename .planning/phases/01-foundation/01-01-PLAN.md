---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - tsconfig.json
  - drizzle.config.ts
  - src/db/schema/index.ts
  - src/db/schema/tenants.ts
  - src/db/index.ts
  - src/db/migrate.ts
  - .env.example
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Project initializes with TypeScript and all core dependencies"
    - "Database schema defines tenants table with tenant_id as primary isolation key"
    - "Drizzle ORM connects to PostgreSQL and can run migrations"
  artifacts:
    - path: "package.json"
      provides: "Core dependencies (hono, drizzle-orm, postgres, bullmq, ioredis, zod)"
      contains: "drizzle-orm"
    - path: "src/db/schema/tenants.ts"
      provides: "Tenants table schema"
      exports: ["tenants"]
    - path: "src/db/index.ts"
      provides: "Database connection singleton"
      exports: ["db"]
  key_links:
    - from: "src/db/index.ts"
      to: "drizzle.config.ts"
      via: "shared connection config"
      pattern: "drizzle\\("
---

<objective>
Initialize Findo project with TypeScript, core dependencies, and foundational database schema.

Purpose: Establish the project foundation with all required packages and the tenants table that every other table will reference for multi-tenant isolation.

Output: Working TypeScript project with Drizzle ORM connected to PostgreSQL, tenants schema defined.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/phases/01-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize project with TypeScript and core dependencies</name>
  <files>package.json, pnpm-lock.yaml, tsconfig.json, .env.example, .gitignore</files>
  <action>
Initialize a new Node.js project with pnpm:

1. Run `pnpm init` to create package.json
2. Set "type": "module" in package.json for ESM
3. Add scripts:
   - "dev": "tsx watch src/index.ts"
   - "build": "tsc"
   - "start": "node dist/index.js"
   - "db:generate": "drizzle-kit generate"
   - "db:migrate": "tsx src/db/migrate.ts"
   - "db:studio": "drizzle-kit studio"

4. Install core dependencies:
   ```bash
   pnpm add hono @hono/node-server @hono/zod-validator zod
   pnpm add drizzle-orm postgres dotenv
   pnpm add bullmq ioredis
   pnpm add nanoid
   pnpm add -D typescript @types/node tsx drizzle-kit vitest
   ```

5. Create tsconfig.json:
   - target: ES2022
   - module: ESNext
   - moduleResolution: bundler
   - strict: true
   - esModuleInterop: true
   - skipLibCheck: true
   - outDir: dist
   - rootDir: src

6. Create .env.example with placeholders:
   - DATABASE_URL=postgresql://user:pass@host:5432/findo
   - REDIS_URL=redis://default:token@host:6379
   - NODE_ENV=development

7. Create/update .gitignore:
   - node_modules/
   - dist/
   - .env
   - .env.local
   - *.log
  </action>
  <verify>
Run `pnpm install` completes without errors.
Run `pnpm exec tsc --noEmit` passes (no TypeScript errors on empty project).
  </verify>
  <done>
package.json contains all core dependencies, tsconfig.json configured for ESM + TypeScript, .env.example documents required environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Drizzle ORM configuration and database connection</name>
  <files>drizzle.config.ts, src/db/index.ts</files>
  <action>
Set up Drizzle ORM with PostgreSQL connection:

1. Create drizzle.config.ts at project root:
   ```typescript
   import { defineConfig } from 'drizzle-kit';

   export default defineConfig({
     schema: './src/db/schema/index.ts',
     out: './drizzle',
     dialect: 'postgresql',
     dbCredentials: {
       url: process.env.DATABASE_URL!,
     },
   });
   ```

2. Create src/db/index.ts:
   ```typescript
   import { drizzle } from 'drizzle-orm/postgres-js';
   import postgres from 'postgres';
   import * as schema from './schema/index.js';

   const connectionString = process.env.DATABASE_URL;

   if (!connectionString) {
     throw new Error('DATABASE_URL environment variable is required');
   }

   // For query purposes
   const queryClient = postgres(connectionString);
   export const db = drizzle(queryClient, { schema });

   // For migrations (uses different connection settings)
   export const createMigrationClient = () => {
     return postgres(connectionString, { max: 1 });
   };
   ```

Note: Use .js extension in imports for ESM compatibility even though source is .ts
  </action>
  <verify>
File src/db/index.ts exists and exports `db` and `createMigrationClient`.
TypeScript compiles without errors: `pnpm exec tsc --noEmit`
  </verify>
  <done>
Drizzle ORM configured with PostgreSQL connection, ready to accept schema definitions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tenants schema with multi-tenant foundation</name>
  <files>src/db/schema/index.ts, src/db/schema/tenants.ts, src/db/migrate.ts</files>
  <action>
Create the foundational tenants table that all other tables will reference:

1. Create src/db/schema/tenants.ts:
   ```typescript
   import { pgTable, uuid, varchar, text, timestamp, boolean, pgEnum } from 'drizzle-orm/pg-core';
   import { sql } from 'drizzle-orm';

   // Tenant status enum
   export const tenantStatusEnum = pgEnum('tenant_status', [
     'trial',        // 14-day free trial
     'active',       // Paying customer
     'grace',        // Trial ended, 3-day grace period
     'paused',       // Service paused (not paying)
     'cancelled'     // Cancelled, pending deletion
   ]);

   export const tenants = pgTable('tenants', {
     id: uuid('id').primaryKey().defaultRandom(),

     // Business information (minimal for 2-minute setup)
     businessName: varchar('business_name', { length: 255 }).notNull(),
     businessType: varchar('business_type', { length: 100 }),
     ownerName: varchar('owner_name', { length: 255 }).notNull(),
     ownerEmail: varchar('owner_email', { length: 255 }).notNull().unique(),
     ownerPhone: varchar('owner_phone', { length: 50 }), // Personal phone for backup auth

     // Business address (for GBP)
     address: text('address'),

     // Status and lifecycle
     status: tenantStatusEnum('status').default('trial').notNull(),
     trialEndsAt: timestamp('trial_ends_at', { withTimezone: true }),
     gracePeriodEndsAt: timestamp('grace_period_ends_at', { withTimezone: true }),

     // Timezone for scheduled jobs (Israel by default)
     timezone: varchar('timezone', { length: 50 }).default('Asia/Jerusalem').notNull(),

     // Timestamps
     createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
     updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
     deletedAt: timestamp('deleted_at', { withTimezone: true }), // Soft delete for 90-day retention
   });

   // Type exports for TypeScript inference
   export type Tenant = typeof tenants.$inferSelect;
   export type NewTenant = typeof tenants.$inferInsert;
   ```

2. Create src/db/schema/index.ts:
   ```typescript
   export * from './tenants.js';
   ```

3. Create src/db/migrate.ts:
   ```typescript
   import 'dotenv/config';
   import { migrate } from 'drizzle-orm/postgres-js/migrator';
   import { drizzle } from 'drizzle-orm/postgres-js';
   import postgres from 'postgres';

   const connectionString = process.env.DATABASE_URL;

   if (!connectionString) {
     throw new Error('DATABASE_URL environment variable is required');
   }

   const migrationClient = postgres(connectionString, { max: 1 });

   async function runMigrations() {
     console.log('Running migrations...');
     const db = drizzle(migrationClient);
     await migrate(db, { migrationsFolder: './drizzle' });
     console.log('Migrations complete!');
     await migrationClient.end();
   }

   runMigrations().catch((err) => {
     console.error('Migration failed:', err);
     process.exit(1);
   });
   ```

Note on design decisions:
- tenant_id is UUID for security (no enumeration attacks)
- Status enum covers full lifecycle from CONTEXT.md (trial -> active -> grace -> paused -> cancelled)
- Soft delete with deletedAt supports 90-day data retention requirement
- Timezone stored per tenant for Israel-specific scheduled jobs
  </action>
  <verify>
Run `pnpm db:generate` - should generate migration files in ./drizzle folder.
Verify migration SQL contains CREATE TABLE tenants with all columns.
TypeScript compiles: `pnpm exec tsc --noEmit`
  </verify>
  <done>
Tenants table schema defined with UUID primary key, status enum for lifecycle management, and soft delete for data retention. Migration files generated.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. ./drizzle folder contains generated migration files
3. Migration SQL includes CREATE TABLE tenants with id, business_name, owner_email, status columns
4. package.json has all required dependencies (hono, drizzle-orm, postgres, bullmq, ioredis, zod)
</verification>

<success_criteria>
- TypeScript project initialized with ESM configuration
- All core dependencies installed (Hono, Drizzle, BullMQ, ioredis, Zod)
- Drizzle ORM connected to PostgreSQL via configuration
- Tenants table schema defines the foundation for multi-tenant isolation
- Migration scripts ready to run against database
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
