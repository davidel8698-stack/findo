---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/db/schema/index.ts
  - src/db/schema/activity-events.ts
  - src/db/rls.sql
  - src/middleware/tenant-context.ts
  - src/types/tenant-context.ts
autonomous: true

must_haves:
  truths:
    - "Row-Level Security policies prevent cross-tenant data access at database level"
    - "Tenant context middleware extracts and injects tenant_id into every request"
    - "Activity events table captures all tenant activities for real-time feed"
  artifacts:
    - path: "src/db/rls.sql"
      provides: "RLS policies for all tenant tables"
      contains: "CREATE POLICY"
    - path: "src/middleware/tenant-context.ts"
      provides: "Tenant context middleware"
      exports: ["tenantContext", "setTenantContext"]
    - path: "src/db/schema/activity-events.ts"
      provides: "Activity events schema for real-time feed"
      exports: ["activityEvents"]
  key_links:
    - from: "src/middleware/tenant-context.ts"
      to: "src/db/index.ts"
      via: "sets RLS session variable"
      pattern: "SET app\\.current_tenant"
---

<objective>
Implement Row-Level Security policies and tenant context middleware for complete data isolation.

Purpose: Ensure tenant A can never access tenant B's data, even with a buggy query. This is critical infrastructure that must exist before any business data is stored.

Output: RLS policies enforced at database level, tenant context injected on every request, activity events table ready for real-time feed.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create activity events schema for real-time feed</name>
  <files>src/db/schema/activity-events.ts, src/db/schema/index.ts</files>
  <action>
Create the activity_events table that powers the real-time dashboard feed:

1. Create src/db/schema/activity-events.ts:
   ```typescript
   import { pgTable, uuid, varchar, text, timestamp, jsonb, index } from 'drizzle-orm/pg-core';
   import { tenants } from './tenants.js';

   export const activityEvents = pgTable('activity_events', {
     id: uuid('id').primaryKey().defaultRandom(),
     tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),

     // Event classification
     eventType: varchar('event_type', { length: 50 }).notNull(),
     // Examples: 'webhook.received', 'lead.created', 'review.detected',
     //           'message.sent', 'job.scheduled', 'token.refreshed'

     // Event details
     title: varchar('title', { length: 255 }).notNull(), // Human-readable title
     description: text('description'), // Optional longer description
     metadata: jsonb('metadata').$type<Record<string, unknown>>(), // Flexible event data

     // Source tracking
     source: varchar('source', { length: 50 }).notNull(), // 'webhook', 'scheduler', 'api', 'system'
     sourceId: varchar('source_id', { length: 255 }), // External reference (webhook_id, job_id, etc.)

     // Timestamps
     occurredAt: timestamp('occurred_at', { withTimezone: true }).defaultNow().notNull(),
     createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
   }, (table) => ({
     // Index for efficient tenant + time queries (dashboard feed)
     tenantTimeIdx: index('activity_events_tenant_time_idx').on(table.tenantId, table.occurredAt),
     // Index for event type filtering
     eventTypeIdx: index('activity_events_event_type_idx').on(table.eventType),
   }));

   export type ActivityEvent = typeof activityEvents.$inferSelect;
   export type NewActivityEvent = typeof activityEvents.$inferInsert;
   ```

2. Update src/db/schema/index.ts to export new schema:
   ```typescript
   export * from './tenants.js';
   export * from './activity-events.js';
   ```

3. Run `pnpm db:generate` to generate migration for activity_events table.

Design notes:
- 90-day retention for activity history (from CONTEXT.md) - cleanup job to be added later
- JSONB metadata allows flexible event data without schema changes
- Indexes optimized for tenant + time queries (most common dashboard pattern)
  </action>
  <verify>
Run `pnpm db:generate` - new migration should be created for activity_events table.
Verify migration SQL contains CREATE TABLE activity_events with tenant_id foreign key.
TypeScript compiles: `pnpm exec tsc --noEmit`
  </verify>
  <done>
Activity events table defined with tenant isolation via foreign key, indexes for efficient querying, JSONB metadata for flexible event data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Row-Level Security policies</name>
  <files>src/db/rls.sql</files>
  <action>
Create SQL file with RLS policies that enforce tenant isolation at database level:

1. Create src/db/rls.sql:
   ```sql
   -- Row-Level Security Policies for Findo Multi-Tenant Isolation
   -- Run this after migrations to enable tenant isolation at database level
   --
   -- IMPORTANT: These policies use app.current_tenant session variable
   -- which must be set via: SET app.current_tenant = 'tenant-uuid-here'
   -- before any queries are executed.

   -- Enable RLS on tenants table (read own tenant only)
   ALTER TABLE tenants ENABLE ROW LEVEL SECURITY;

   CREATE POLICY tenants_isolation ON tenants
     USING (id = current_setting('app.current_tenant', true)::uuid);

   -- Enable RLS on activity_events table
   ALTER TABLE activity_events ENABLE ROW LEVEL SECURITY;

   CREATE POLICY activity_events_isolation ON activity_events
     USING (tenant_id = current_setting('app.current_tenant', true)::uuid);

   -- Grant permissions for application user
   -- Note: Replace 'findo_app' with your actual database user
   -- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO findo_app;

   -- Force RLS for table owner (important for security)
   ALTER TABLE tenants FORCE ROW LEVEL SECURITY;
   ALTER TABLE activity_events FORCE ROW LEVEL SECURITY;

   -- Helper function to set tenant context (used by application)
   CREATE OR REPLACE FUNCTION set_tenant_context(tenant_uuid uuid)
   RETURNS void AS $$
   BEGIN
     PERFORM set_config('app.current_tenant', tenant_uuid::text, false);
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER;

   -- Helper function to get current tenant (for debugging)
   CREATE OR REPLACE FUNCTION get_current_tenant()
   RETURNS uuid AS $$
   BEGIN
     RETURN current_setting('app.current_tenant', true)::uuid;
   END;
   $$ LANGUAGE plpgsql;
   ```

Notes on implementation:
- current_setting(..., true) returns NULL if not set, avoiding errors
- FORCE ROW LEVEL SECURITY ensures policies apply even to table owner
- SECURITY DEFINER on set_tenant_context allows controlled context setting
- These policies must be applied after Drizzle migrations run
  </action>
  <verify>
File src/db/rls.sql exists and contains:
- ALTER TABLE ... ENABLE ROW LEVEL SECURITY for tenants and activity_events
- CREATE POLICY with tenant_id isolation
- Helper functions for setting/getting tenant context
  </verify>
  <done>
RLS policies defined in SQL file ready to be applied to database. Policies use session variable for tenant context, enforced on all queries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tenant context middleware for Hono</name>
  <files>src/middleware/tenant-context.ts, src/types/tenant-context.ts</files>
  <action>
Create middleware that extracts tenant context and sets RLS session variable:

1. Create src/types/tenant-context.ts:
   ```typescript
   import type { Tenant } from '../db/schema/index.js';

   export interface TenantContext {
     tenantId: string;
     tenant?: Tenant;
   }

   // Extend Hono context with tenant info
   declare module 'hono' {
     interface ContextVariableMap {
       tenant: TenantContext;
     }
   }
   ```

2. Create src/middleware/tenant-context.ts:
   ```typescript
   import { createMiddleware } from 'hono/factory';
   import { HTTPException } from 'hono/http-exception';
   import { db } from '../db/index.js';
   import { tenants } from '../db/schema/index.js';
   import { eq, sql } from 'drizzle-orm';
   import type { TenantContext } from '../types/tenant-context.js';

   /**
    * Sets the tenant context for RLS at the database level.
    * Must be called before any database queries.
    */
   export async function setTenantContext(tenantId: string): Promise<void> {
     await db.execute(sql`SELECT set_tenant_context(${tenantId}::uuid)`);
   }

   /**
    * Clears tenant context (useful for admin operations or between requests in pooled connections)
    */
   export async function clearTenantContext(): Promise<void> {
     await db.execute(sql`RESET app.current_tenant`);
   }

   /**
    * Tenant context middleware for API requests.
    *
    * Extracts tenant ID from:
    * 1. X-Tenant-ID header (for internal/service calls)
    * 2. JWT claims (for authenticated user requests) - to be implemented with Clerk
    *
    * Sets RLS context and loads tenant info into request context.
    */
   export const tenantContext = createMiddleware(async (c, next) => {
     // Extract tenant ID from header (temporary until Clerk auth is added)
     // In production, this will come from JWT claims
     const tenantId = c.req.header('X-Tenant-ID');

     if (!tenantId) {
       throw new HTTPException(401, {
         message: 'Tenant context required. Provide X-Tenant-ID header.',
       });
     }

     // Validate UUID format
     const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
     if (!uuidRegex.test(tenantId)) {
       throw new HTTPException(400, {
         message: 'Invalid tenant ID format. Must be a valid UUID.',
       });
     }

     try {
       // Set RLS context BEFORE any queries
       await setTenantContext(tenantId);

       // Load tenant (will be filtered by RLS)
       const tenant = await db.query.tenants.findFirst({
         where: eq(tenants.id, tenantId),
       });

       if (!tenant) {
         throw new HTTPException(404, {
           message: 'Tenant not found.',
         });
       }

       // Check tenant status
       if (tenant.status === 'cancelled') {
         throw new HTTPException(403, {
           message: 'Account has been cancelled.',
         });
       }

       // Set context for downstream handlers
       const context: TenantContext = {
         tenantId,
         tenant,
       };
       c.set('tenant', context);

       await next();
     } finally {
       // Clear context after request (important for connection pooling)
       await clearTenantContext();
     }
   });

   /**
    * Public routes middleware - allows requests without tenant context.
    * Useful for health checks, webhooks with own auth, etc.
    */
   export const publicRoute = createMiddleware(async (c, next) => {
     // No tenant context required
     await next();
   });

   /**
    * Worker tenant context - for background jobs with tenant ID in job data.
    * Use this in BullMQ workers to set context from job payload.
    */
   export async function withTenantContext<T>(
     tenantId: string,
     fn: () => Promise<T>
   ): Promise<T> {
     try {
       await setTenantContext(tenantId);
       return await fn();
     } finally {
       await clearTenantContext();
     }
   }
   ```

Key implementation notes:
- RLS context is set BEFORE any database queries
- Context is cleared AFTER request completes (critical for connection pooling)
- Middleware validates tenant exists and is not cancelled
- withTenantContext helper for background jobs
- X-Tenant-ID header is temporary; will be replaced by Clerk JWT claims
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
Files exist: src/middleware/tenant-context.ts, src/types/tenant-context.ts
Middleware exports: tenantContext, setTenantContext, withTenantContext
  </verify>
  <done>
Tenant context middleware implemented with RLS integration, request context injection, and helper for background jobs. Context cleared after each request for connection pool safety.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. ./drizzle folder contains migration for activity_events table
3. src/db/rls.sql contains RLS policies for tenants and activity_events
4. src/middleware/tenant-context.ts exports tenantContext, setTenantContext, withTenantContext
5. Middleware sets RLS session variable before queries and clears after
</verification>

<success_criteria>
- Activity events table schema defined with tenant foreign key and indexes
- RLS policies enforce tenant isolation at database level
- Tenant context middleware extracts tenant ID and sets RLS context
- Context is properly cleared after each request (connection pool safe)
- Helper function exists for background job tenant context
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
