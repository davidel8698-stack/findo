---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/db/schema/token-vault.ts
  - src/db/schema/index.ts
  - src/services/token-vault.ts
  - src/lib/encryption.ts
autonomous: true

must_haves:
  truths:
    - "Token vault encrypts credentials before storage"
    - "Token vault decrypts credentials on retrieval"
    - "Plaintext tokens never appear in database"
  artifacts:
    - path: "src/db/schema/token-vault.ts"
      provides: "Encrypted token storage schema"
      exports: ["tokenVault"]
    - path: "src/services/token-vault.ts"
      provides: "Token vault service"
      exports: ["TokenVaultService"]
    - path: "src/lib/encryption.ts"
      provides: "AES-256-GCM encryption utilities"
      exports: ["encrypt", "decrypt"]
  key_links:
    - from: "src/services/token-vault.ts"
      to: "src/lib/encryption.ts"
      via: "encrypts/decrypts tokens"
      pattern: "encrypt\\(|decrypt\\("
    - from: "src/services/token-vault.ts"
      to: "src/db/schema/token-vault.ts"
      via: "stores encrypted data"
      pattern: "tokenVault"
---

<objective>
Implement encrypted token storage for OAuth credentials and API keys.

Purpose: Secure storage for WhatsApp tokens, Google OAuth tokens, and other sensitive credentials. Encryption at rest ensures database compromise doesn't expose tokens.

Output: TokenVault service that encrypts before storage and decrypts on retrieval, with no plaintext ever persisted.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create encryption utilities</name>
  <files>src/lib/encryption.ts, .env.example</files>
  <action>
Create AES-256-GCM encryption utilities for token storage:

1. Create src/lib/encryption.ts:
   ```typescript
   import { createCipheriv, createDecipheriv, randomBytes, scrypt } from 'crypto';
   import { promisify } from 'util';

   const scryptAsync = promisify(scrypt);

   // AES-256-GCM provides both encryption and authentication
   const ALGORITHM = 'aes-256-gcm';
   const KEY_LENGTH = 32; // 256 bits
   const IV_LENGTH = 12; // 96 bits recommended for GCM
   const AUTH_TAG_LENGTH = 16; // 128 bits

   /**
    * Derives a 256-bit key from the master secret using scrypt.
    * This adds an extra layer of security even if the secret is compromised.
    */
   async function deriveKey(secret: string, salt: Buffer): Promise<Buffer> {
     return (await scryptAsync(secret, salt, KEY_LENGTH)) as Buffer;
   }

   /**
    * Get the encryption secret from environment.
    * Throws if not configured (fail fast on misconfiguration).
    */
   function getEncryptionSecret(): string {
     const secret = process.env.ENCRYPTION_SECRET;
     if (!secret) {
       throw new Error('ENCRYPTION_SECRET environment variable is required');
     }
     if (secret.length < 32) {
       throw new Error('ENCRYPTION_SECRET must be at least 32 characters');
     }
     return secret;
   }

   /**
    * Encrypts a string value using AES-256-GCM.
    *
    * Returns format: base64(salt:iv:authTag:ciphertext)
    *
    * @param plaintext - The string to encrypt
    * @returns Encrypted string (base64 encoded)
    */
   export async function encrypt(plaintext: string): Promise<string> {
     const secret = getEncryptionSecret();

     // Generate random salt and IV for each encryption
     const salt = randomBytes(16);
     const iv = randomBytes(IV_LENGTH);

     // Derive key from secret + salt
     const key = await deriveKey(secret, salt);

     // Create cipher and encrypt
     const cipher = createCipheriv(ALGORITHM, key, iv, {
       authTagLength: AUTH_TAG_LENGTH,
     });

     const encrypted = Buffer.concat([
       cipher.update(plaintext, 'utf8'),
       cipher.final(),
     ]);

     const authTag = cipher.getAuthTag();

     // Combine all components: salt + iv + authTag + ciphertext
     const combined = Buffer.concat([salt, iv, authTag, encrypted]);

     return combined.toString('base64');
   }

   /**
    * Decrypts a string encrypted with encrypt().
    *
    * @param encrypted - The encrypted string (base64 encoded)
    * @returns Decrypted plaintext string
    * @throws Error if decryption fails (wrong key, tampered data, etc.)
    */
   export async function decrypt(encrypted: string): Promise<string> {
     const secret = getEncryptionSecret();

     // Decode from base64
     const combined = Buffer.from(encrypted, 'base64');

     // Extract components
     const salt = combined.subarray(0, 16);
     const iv = combined.subarray(16, 16 + IV_LENGTH);
     const authTag = combined.subarray(16 + IV_LENGTH, 16 + IV_LENGTH + AUTH_TAG_LENGTH);
     const ciphertext = combined.subarray(16 + IV_LENGTH + AUTH_TAG_LENGTH);

     // Derive key from secret + salt
     const key = await deriveKey(secret, salt);

     // Create decipher and decrypt
     const decipher = createDecipheriv(ALGORITHM, key, iv, {
       authTagLength: AUTH_TAG_LENGTH,
     });
     decipher.setAuthTag(authTag);

     try {
       const decrypted = Buffer.concat([
         decipher.update(ciphertext),
         decipher.final(),
       ]);
       return decrypted.toString('utf8');
     } catch (error) {
       throw new Error('Decryption failed: data may be corrupted or tampered');
     }
   }

   /**
    * Generates a secure random secret suitable for ENCRYPTION_SECRET.
    * Use this to generate the initial secret.
    */
   export function generateEncryptionSecret(): string {
     return randomBytes(32).toString('base64');
   }
   ```

2. Update .env.example to include encryption secret:
   ```
   # Existing variables...
   DATABASE_URL=postgresql://user:pass@host:5432/findo
   REDIS_URL=redis://default:token@host:6379
   NODE_ENV=development

   # Encryption (generate with: node -e "console.log(require('crypto').randomBytes(32).toString('base64'))")
   ENCRYPTION_SECRET=your-base64-secret-at-least-32-chars
   ```

Design decisions:
- AES-256-GCM chosen for authenticated encryption (prevents tampering)
- Per-encryption salt and IV ensures identical values encrypt differently
- scrypt key derivation adds protection against brute force
- Throws on missing/weak secret (fail fast)
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
File src/lib/encryption.ts exports encrypt, decrypt, generateEncryptionSecret
.env.example contains ENCRYPTION_SECRET placeholder
  </verify>
  <done>
AES-256-GCM encryption utilities implemented with per-value salt/IV, scrypt key derivation, and authentication tag validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create token vault schema</name>
  <files>src/db/schema/token-vault.ts, src/db/schema/index.ts</files>
  <action>
Create the token_vault table for storing encrypted credentials:

1. Create src/db/schema/token-vault.ts:
   ```typescript
   import { pgTable, uuid, varchar, text, timestamp, index, pgEnum, unique } from 'drizzle-orm/pg-core';
   import { tenants } from './tenants.js';

   // Provider types for OAuth/API tokens
   export const tokenProviderEnum = pgEnum('token_provider', [
     'whatsapp',    // WhatsApp Business API tokens
     'google',      // Google OAuth (GBP, etc.)
     'voicenter',   // Voicenter API credentials
     'greeninvoice', // Greeninvoice API
     'icount',      // iCount API
     'clerk',       // Clerk authentication
   ]);

   // Token types within a provider
   export const tokenTypeEnum = pgEnum('token_type', [
     'access_token',   // Short-lived access token
     'refresh_token',  // Long-lived refresh token
     'api_key',        // Static API key
     'webhook_secret', // Webhook signature verification secret
   ]);

   export const tokenVault = pgTable('token_vault', {
     id: uuid('id').primaryKey().defaultRandom(),
     tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),

     // Token identification
     provider: tokenProviderEnum('provider').notNull(),
     tokenType: tokenTypeEnum('token_type').notNull(),
     identifier: varchar('identifier', { length: 255 }), // Provider-specific ID (e.g., WABA ID, GBP account ID)

     // Encrypted token value (NEVER store plaintext)
     encryptedValue: text('encrypted_value').notNull(),

     // Token metadata
     expiresAt: timestamp('expires_at', { withTimezone: true }), // NULL for non-expiring tokens
     lastUsedAt: timestamp('last_used_at', { withTimezone: true }),
     lastRefreshedAt: timestamp('last_refreshed_at', { withTimezone: true }),

     // Status tracking
     isValid: varchar('is_valid', { length: 10 }).default('true').notNull(), // 'true', 'false', 'unknown'
     lastError: text('last_error'), // Last error message if token failed

     // Audit timestamps
     createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
     updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
   }, (table) => ({
     // Unique constraint: one token per tenant/provider/type/identifier combo
     uniqueToken: unique('token_vault_unique').on(
       table.tenantId,
       table.provider,
       table.tokenType,
       table.identifier
     ),
     // Index for token lookups
     tenantProviderIdx: index('token_vault_tenant_provider_idx').on(table.tenantId, table.provider),
     // Index for token health monitoring (find expiring tokens)
     expiresAtIdx: index('token_vault_expires_at_idx').on(table.expiresAt),
   }));

   export type TokenVaultEntry = typeof tokenVault.$inferSelect;
   export type NewTokenVaultEntry = typeof tokenVault.$inferInsert;
   ```

2. Update src/db/schema/index.ts:
   ```typescript
   export * from './tenants.js';
   export * from './activity-events.js';
   export * from './token-vault.js';
   ```

3. Run `pnpm db:generate` to generate migration.

Design decisions:
- encryptedValue is TEXT (encrypted tokens can be long)
- isValid tracks token health without needing to test it
- identifier allows multiple accounts per provider (e.g., multiple Google accounts)
- Unique constraint prevents duplicate tokens
- expiresAt index supports proactive refresh job
  </action>
  <verify>
Run `pnpm db:generate` - new migration for token_vault should be created.
Migration SQL contains CREATE TABLE token_vault with encrypted_value column.
TypeScript compiles: `pnpm exec tsc --noEmit`
  </verify>
  <done>
Token vault schema defined with encrypted value storage, provider/type enums, and indexes for health monitoring and proactive refresh.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TokenVault service</name>
  <files>src/services/token-vault.ts</files>
  <action>
Create the TokenVault service for secure token management:

1. Create src/services/token-vault.ts:
   ```typescript
   import { db } from '../db/index.js';
   import { tokenVault, type TokenVaultEntry, type NewTokenVaultEntry } from '../db/schema/index.js';
   import { encrypt, decrypt } from '../lib/encryption.js';
   import { eq, and, lt, isNull, or } from 'drizzle-orm';

   export interface TokenData {
     value: string;
     expiresAt?: Date;
     identifier?: string;
   }

   export interface DecryptedToken {
     id: string;
     tenantId: string;
     provider: TokenVaultEntry['provider'];
     tokenType: TokenVaultEntry['tokenType'];
     value: string;
     identifier: string | null;
     expiresAt: Date | null;
     isValid: string;
     lastUsedAt: Date | null;
   }

   /**
    * TokenVaultService handles secure storage and retrieval of OAuth tokens and API keys.
    *
    * IMPORTANT: This service encrypts all token values before storage.
    * Plaintext tokens should NEVER appear in database or logs.
    */
   export class TokenVaultService {
     /**
      * Store a token (encrypts before storage).
      * If token already exists for tenant/provider/type/identifier, updates it.
      */
     async storeToken(
       tenantId: string,
       provider: TokenVaultEntry['provider'],
       tokenType: TokenVaultEntry['tokenType'],
       data: TokenData
     ): Promise<string> {
       const encryptedValue = await encrypt(data.value);

       const existing = await db.query.tokenVault.findFirst({
         where: and(
           eq(tokenVault.tenantId, tenantId),
           eq(tokenVault.provider, provider),
           eq(tokenVault.tokenType, tokenType),
           data.identifier
             ? eq(tokenVault.identifier, data.identifier)
             : isNull(tokenVault.identifier)
         ),
       });

       if (existing) {
         // Update existing token
         await db
           .update(tokenVault)
           .set({
             encryptedValue,
             expiresAt: data.expiresAt,
             isValid: 'true',
             lastError: null,
             lastRefreshedAt: new Date(),
             updatedAt: new Date(),
           })
           .where(eq(tokenVault.id, existing.id));
         return existing.id;
       }

       // Insert new token
       const [inserted] = await db
         .insert(tokenVault)
         .values({
           tenantId,
           provider,
           tokenType,
           identifier: data.identifier,
           encryptedValue,
           expiresAt: data.expiresAt,
           isValid: 'true',
         })
         .returning({ id: tokenVault.id });

       return inserted.id;
     }

     /**
      * Retrieve a token (decrypts on retrieval).
      * Updates lastUsedAt timestamp.
      */
     async getToken(
       tenantId: string,
       provider: TokenVaultEntry['provider'],
       tokenType: TokenVaultEntry['tokenType'],
       identifier?: string
     ): Promise<DecryptedToken | null> {
       const entry = await db.query.tokenVault.findFirst({
         where: and(
           eq(tokenVault.tenantId, tenantId),
           eq(tokenVault.provider, provider),
           eq(tokenVault.tokenType, tokenType),
           identifier
             ? eq(tokenVault.identifier, identifier)
             : isNull(tokenVault.identifier)
         ),
       });

       if (!entry) {
         return null;
       }

       // Update last used timestamp (fire and forget)
       db.update(tokenVault)
         .set({ lastUsedAt: new Date() })
         .where(eq(tokenVault.id, entry.id))
         .catch(() => {}); // Ignore errors on usage tracking

       // Decrypt the value
       const value = await decrypt(entry.encryptedValue);

       return {
         id: entry.id,
         tenantId: entry.tenantId,
         provider: entry.provider,
         tokenType: entry.tokenType,
         value,
         identifier: entry.identifier,
         expiresAt: entry.expiresAt,
         isValid: entry.isValid,
         lastUsedAt: entry.lastUsedAt,
       };
     }

     /**
      * Get access token with automatic refresh check.
      * Returns null if token is expired or invalid.
      * Returns token if valid or if expiring within buffer (caller should refresh).
      */
     async getAccessToken(
       tenantId: string,
       provider: TokenVaultEntry['provider'],
       identifier?: string,
       refreshBufferMinutes: number = 5
     ): Promise<{ token: DecryptedToken; needsRefresh: boolean } | null> {
       const token = await this.getToken(tenantId, provider, 'access_token', identifier);

       if (!token) {
         return null;
       }

       if (token.isValid === 'false') {
         return null;
       }

       const now = new Date();
       const bufferMs = refreshBufferMinutes * 60 * 1000;

       // Check if expired
       if (token.expiresAt && token.expiresAt <= now) {
         // Token is expired, mark as invalid
         await this.markTokenInvalid(token.id, 'Token expired');
         return null;
       }

       // Check if expiring soon
       const needsRefresh = token.expiresAt
         ? token.expiresAt.getTime() - now.getTime() < bufferMs
         : false;

       return { token, needsRefresh };
     }

     /**
      * Get refresh token for a provider.
      */
     async getRefreshToken(
       tenantId: string,
       provider: TokenVaultEntry['provider'],
       identifier?: string
     ): Promise<DecryptedToken | null> {
       return this.getToken(tenantId, provider, 'refresh_token', identifier);
     }

     /**
      * Mark a token as invalid (e.g., after failed API call).
      */
     async markTokenInvalid(tokenId: string, error: string): Promise<void> {
       await db
         .update(tokenVault)
         .set({
           isValid: 'false',
           lastError: error,
           updatedAt: new Date(),
         })
         .where(eq(tokenVault.id, tokenId));
     }

     /**
      * Delete a token.
      */
     async deleteToken(tokenId: string): Promise<void> {
       await db.delete(tokenVault).where(eq(tokenVault.id, tokenId));
     }

     /**
      * Delete all tokens for a tenant/provider.
      */
     async deleteProviderTokens(tenantId: string, provider: TokenVaultEntry['provider']): Promise<void> {
       await db
         .delete(tokenVault)
         .where(and(eq(tokenVault.tenantId, tenantId), eq(tokenVault.provider, provider)));
     }

     /**
      * Find tokens expiring within a time window (for proactive refresh job).
      */
     async findExpiringTokens(
       withinMinutes: number,
       provider?: TokenVaultEntry['provider']
     ): Promise<Array<{ tenantId: string; provider: string; tokenType: string; identifier: string | null }>> {
       const expiresBy = new Date(Date.now() + withinMinutes * 60 * 1000);

       const conditions = [
         eq(tokenVault.isValid, 'true'),
         eq(tokenVault.tokenType, 'access_token'),
         lt(tokenVault.expiresAt, expiresBy),
       ];

       if (provider) {
         conditions.push(eq(tokenVault.provider, provider));
       }

       const entries = await db.query.tokenVault.findMany({
         where: and(...conditions),
         columns: {
           tenantId: true,
           provider: true,
           tokenType: true,
           identifier: true,
         },
       });

       return entries;
     }
   }

   // Export singleton instance
   export const tokenVaultService = new TokenVaultService();
   ```

Key implementation notes:
- All token values are encrypted before storage via encrypt()
- All token values are decrypted on retrieval via decrypt()
- getAccessToken includes proactive refresh check (5-minute buffer by default)
- findExpiringTokens supports scheduled refresh job
- lastUsedAt tracking helps identify stale tokens
- Error tracking helps debugging integration issues
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/services/token-vault.ts exports TokenVaultService and tokenVaultService
Service methods: storeToken, getToken, getAccessToken, getRefreshToken, markTokenInvalid
  </verify>
  <done>
TokenVault service implemented with encrypt/decrypt integration, proactive refresh support, and health tracking. Plaintext tokens never stored in database.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. ./drizzle folder contains migration for token_vault table
3. src/lib/encryption.ts provides encrypt/decrypt functions
4. src/services/token-vault.ts encrypts all tokens before storage
5. TokenVaultService.getToken decrypts values on retrieval
</verification>

<success_criteria>
- AES-256-GCM encryption with per-value salt and IV
- Token vault schema stores only encrypted values
- TokenVaultService encrypts before storage, decrypts on retrieval
- Proactive refresh support via getAccessToken with buffer check
- Health tracking (isValid, lastError) for monitoring
- Expiring token finder for scheduled refresh jobs
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
