---
phase: 01-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/queue/index.ts
  - src/queue/queues.ts
  - src/queue/workers/webhook.worker.ts
  - src/queue/workers/test.worker.ts
  - src/lib/redis.ts
autonomous: true

must_haves:
  truths:
    - "Redis connection established for BullMQ queue operations"
    - "Webhook queue exists and can accept jobs"
    - "Jobs can be enqueued and processed asynchronously"
  artifacts:
    - path: "src/lib/redis.ts"
      provides: "Redis connection for BullMQ"
      exports: ["redis", "createRedisConnection"]
    - path: "src/queue/queues.ts"
      provides: "Queue definitions"
      exports: ["webhookQueue", "scheduledQueue"]
    - path: "src/queue/workers/webhook.worker.ts"
      provides: "Webhook processing worker"
      exports: ["startWebhookWorker"]
  key_links:
    - from: "src/queue/queues.ts"
      to: "src/lib/redis.ts"
      via: "Redis connection"
      pattern: "new Queue\\("
    - from: "src/queue/workers/webhook.worker.ts"
      to: "src/queue/queues.ts"
      via: "processes queue jobs"
      pattern: "new Worker\\("
---

<objective>
Set up BullMQ queue infrastructure for async webhook processing and background jobs.

Purpose: Queue-first architecture ensures webhooks are acknowledged quickly (< 500ms) while actual processing happens asynchronously. This prevents lost events and enables reliable retry logic.

Output: Redis connection, webhook queue, and basic worker setup ready for queue-based processing.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Redis connection for BullMQ</name>
  <files>src/lib/redis.ts</files>
  <action>
Create Redis connection management for BullMQ:

1. Create src/lib/redis.ts:
   ```typescript
   import { Redis, RedisOptions } from 'ioredis';

   /**
    * Parse Upstash Redis URL to connection options.
    * Upstash format: redis://default:token@endpoint:port
    */
   function parseRedisUrl(url: string): RedisOptions {
     const parsed = new URL(url);

     return {
       host: parsed.hostname,
       port: parseInt(parsed.port, 10) || 6379,
       password: parsed.password || undefined,
       username: parsed.username !== 'default' ? parsed.username : undefined,
       // Upstash requires TLS
       tls: parsed.protocol === 'rediss:' || parsed.hostname.includes('upstash.io')
         ? { rejectUnauthorized: false }
         : undefined,
       // Connection settings optimized for serverless
       maxRetriesPerRequest: null, // Required for BullMQ
       enableReadyCheck: false,
       lazyConnect: true,
     };
   }

   /**
    * Get Redis URL from environment.
    */
   function getRedisUrl(): string {
     const url = process.env.REDIS_URL;
     if (!url) {
       throw new Error('REDIS_URL environment variable is required');
     }
     return url;
   }

   /**
    * Create a new Redis connection.
    * Use this for BullMQ queues and workers (they need separate connections).
    */
   export function createRedisConnection(): Redis {
     const options = parseRedisUrl(getRedisUrl());
     return new Redis(options);
   }

   /**
    * Shared Redis connection for general use (caching, pub/sub).
    * Do NOT use this for BullMQ - use createRedisConnection() instead.
    */
   let sharedConnection: Redis | null = null;

   export function getRedis(): Redis {
     if (!sharedConnection) {
       sharedConnection = createRedisConnection();
     }
     return sharedConnection;
   }

   /**
    * Close all Redis connections (for graceful shutdown).
    */
   export async function closeRedisConnections(): Promise<void> {
     if (sharedConnection) {
       await sharedConnection.quit();
       sharedConnection = null;
     }
   }

   // Export for direct access (used by BullMQ)
   export { Redis };
   ```

Design notes:
- maxRetriesPerRequest: null is REQUIRED for BullMQ blocking commands
- Separate connections for queues vs workers (BullMQ requirement)
- TLS detection for Upstash (required for their hosted Redis)
- lazyConnect for faster startup
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/lib/redis.ts exports createRedisConnection, getRedis, closeRedisConnections
  </verify>
  <done>
Redis connection management created with BullMQ-compatible settings, TLS support for Upstash, and graceful shutdown handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BullMQ queue definitions</name>
  <files>src/queue/queues.ts, src/queue/index.ts</files>
  <action>
Create queue definitions for webhook processing and scheduled jobs:

1. Create src/queue/queues.ts:
   ```typescript
   import { Queue, QueueOptions } from 'bullmq';
   import { createRedisConnection } from '../lib/redis.js';

   // Default queue options
   const defaultQueueOptions: Partial<QueueOptions> = {
     defaultJobOptions: {
       attempts: 5,
       backoff: {
         type: 'exponential',
         delay: 1000, // Start with 1 second, then 2s, 4s, 8s, 16s
       },
       removeOnComplete: {
         age: 24 * 60 * 60, // Keep completed jobs for 24 hours
         count: 1000, // Keep last 1000 completed jobs
       },
       removeOnFail: {
         age: 7 * 24 * 60 * 60, // Keep failed jobs for 7 days
       },
     },
   };

   /**
    * Webhook processing queue.
    * Handles incoming webhooks from external services (Voicenter, Greeninvoice, WhatsApp, etc.)
    */
   export const webhookQueue = new Queue('webhooks', {
     ...defaultQueueOptions,
     connection: createRedisConnection(),
   });

   /**
    * Scheduled jobs queue.
    * Handles recurring jobs (hourly review check, daily digest, weekly photo request, etc.)
    */
   export const scheduledQueue = new Queue('scheduled', {
     ...defaultQueueOptions,
     connection: createRedisConnection(),
   });

   /**
    * Notification queue.
    * Handles outbound notifications (WhatsApp, SMS, email to business owners).
    */
   export const notificationQueue = new Queue('notifications', {
     ...defaultQueueOptions,
     connection: createRedisConnection(),
   });

   /**
    * Activity feed queue.
    * Handles real-time activity feed updates (publish to SSE).
    */
   export const activityQueue = new Queue('activity', {
     ...defaultQueueOptions,
     connection: createRedisConnection(),
     defaultJobOptions: {
       ...defaultQueueOptions.defaultJobOptions,
       attempts: 3, // Fewer retries for activity events (less critical)
       removeOnComplete: {
         age: 60 * 60, // Only keep 1 hour (processed quickly)
         count: 500,
       },
     },
   });

   // Job type definitions for type safety
   export interface WebhookJobData {
     source: 'voicenter' | 'greeninvoice' | 'icount' | 'whatsapp' | 'google' | 'test';
     eventId: string;
     eventType: string;
     payload: Record<string, unknown>;
     tenantId?: string; // May need to be resolved from payload
     receivedAt: string; // ISO timestamp
   }

   export interface ScheduledJobData {
     jobType: 'review-check' | 'photo-request' | 'daily-digest' | 'token-refresh' | 'test';
     tenantId?: string; // Optional for tenant-specific jobs
     params?: Record<string, unknown>;
   }

   export interface NotificationJobData {
     tenantId: string;
     channel: 'whatsapp' | 'sms' | 'email';
     recipientId: string; // Phone number or email
     templateId: string;
     params: Record<string, unknown>;
   }

   export interface ActivityJobData {
     tenantId: string;
     eventType: string;
     title: string;
     description?: string;
     metadata?: Record<string, unknown>;
     source: string;
     sourceId?: string;
   }
   ```

2. Create src/queue/index.ts:
   ```typescript
   export {
     webhookQueue,
     scheduledQueue,
     notificationQueue,
     activityQueue,
     type WebhookJobData,
     type ScheduledJobData,
     type NotificationJobData,
     type ActivityJobData,
   } from './queues.js';
   ```

Design notes:
- Exponential backoff starting at 1 second
- Completed jobs retained for debugging (24h / 1000 jobs)
- Failed jobs retained for investigation (7 days)
- Type definitions for job payloads ensure type safety
- Separate queues allow independent scaling and monitoring
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/queue/index.ts exports webhookQueue, scheduledQueue, notificationQueue, activityQueue
Job type interfaces exported: WebhookJobData, ScheduledJobData, etc.
  </verify>
  <done>
BullMQ queues defined for webhooks, scheduled jobs, notifications, and activity feed. Job types defined for type-safe enqueueing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create webhook and test workers</name>
  <files>src/queue/workers/webhook.worker.ts, src/queue/workers/test.worker.ts</files>
  <action>
Create workers for processing webhook and test jobs:

1. Create src/queue/workers/webhook.worker.ts:
   ```typescript
   import { Worker, Job } from 'bullmq';
   import { createRedisConnection } from '../../lib/redis.js';
   import { withTenantContext } from '../../middleware/tenant-context.js';
   import { db } from '../../db/index.js';
   import { activityEvents } from '../../db/schema/index.js';
   import { activityQueue, type WebhookJobData, type ActivityJobData } from '../queues.js';

   /**
    * Process webhook jobs.
    * Routes to appropriate handler based on source.
    */
   async function processWebhook(job: Job<WebhookJobData>): Promise<void> {
     const { source, eventId, eventType, payload, tenantId, receivedAt } = job.data;

     console.log(`[webhook] Processing ${source}:${eventType} (${eventId})`);

     // Route to appropriate handler
     switch (source) {
       case 'test':
         await handleTestWebhook(job.data);
         break;

       case 'voicenter':
         // TODO: Implement in Phase 3
         console.log(`[webhook] Voicenter webhook received: ${eventType}`);
         break;

       case 'whatsapp':
         // TODO: Implement in Phase 2
         console.log(`[webhook] WhatsApp webhook received: ${eventType}`);
         break;

       case 'google':
         // TODO: Implement in Phase 4
         console.log(`[webhook] Google webhook received: ${eventType}`);
         break;

       case 'greeninvoice':
       case 'icount':
         // TODO: Implement in Phase 6
         console.log(`[webhook] Accounting webhook received: ${source}:${eventType}`);
         break;

       default:
         console.warn(`[webhook] Unknown source: ${source}`);
     }
   }

   /**
    * Handle test webhook (for Phase 1 verification).
    */
   async function handleTestWebhook(data: WebhookJobData): Promise<void> {
     const { eventId, payload, tenantId } = data;

     if (!tenantId) {
       throw new Error('Test webhook requires tenantId');
     }

     // Process within tenant context
     await withTenantContext(tenantId, async () => {
       // Create activity event
       await db.insert(activityEvents).values({
         tenantId,
         eventType: 'webhook.test',
         title: 'Test webhook processed',
         description: `Processed test webhook ${eventId}`,
         metadata: payload,
         source: 'webhook',
         sourceId: eventId,
       });

       // Enqueue activity feed update
       await activityQueue.add('test-activity', {
         tenantId,
         eventType: 'webhook.test',
         title: 'Test webhook processed',
         description: `Test webhook ${eventId} processed successfully`,
         metadata: payload,
         source: 'webhook',
         sourceId: eventId,
       } satisfies ActivityJobData);
     });

     console.log(`[webhook] Test webhook processed: ${eventId}`);
   }

   /**
    * Start the webhook worker.
    */
   export function startWebhookWorker(): Worker<WebhookJobData> {
     const worker = new Worker<WebhookJobData>(
       'webhooks',
       processWebhook,
       {
         connection: createRedisConnection(),
         concurrency: 5, // Process up to 5 jobs concurrently
       }
     );

     worker.on('completed', (job) => {
       console.log(`[webhook] Job ${job.id} completed`);
     });

     worker.on('failed', (job, err) => {
       console.error(`[webhook] Job ${job?.id} failed:`, err.message);
     });

     console.log('[webhook] Worker started');
     return worker;
   }
   ```

2. Create src/queue/workers/test.worker.ts:
   ```typescript
   import { Worker, Job } from 'bullmq';
   import { createRedisConnection } from '../../lib/redis.js';
   import type { ScheduledJobData } from '../queues.js';

   /**
    * Process scheduled test jobs.
    * Used for Phase 1 verification of scheduler functionality.
    */
   async function processScheduledJob(job: Job<ScheduledJobData>): Promise<void> {
     const { jobType, tenantId, params } = job.data;

     console.log(`[scheduled] Processing ${jobType} job${tenantId ? ` for tenant ${tenantId}` : ''}`);

     switch (jobType) {
       case 'test':
         // Just log for verification
         console.log(`[scheduled] Test job executed at ${new Date().toISOString()}`);
         console.log(`[scheduled] Job params:`, params);
         break;

       case 'review-check':
         // TODO: Implement in Phase 5
         console.log(`[scheduled] Review check job placeholder`);
         break;

       case 'photo-request':
         // TODO: Implement in Phase 7
         console.log(`[scheduled] Photo request job placeholder`);
         break;

       case 'daily-digest':
         // TODO: Implement in Phase 9
         console.log(`[scheduled] Daily digest job placeholder`);
         break;

       case 'token-refresh':
         // TODO: Implement proactive token refresh
         console.log(`[scheduled] Token refresh job placeholder`);
         break;

       default:
         console.warn(`[scheduled] Unknown job type: ${jobType}`);
     }
   }

   /**
    * Start the scheduled jobs worker.
    */
   export function startScheduledWorker(): Worker<ScheduledJobData> {
     const worker = new Worker<ScheduledJobData>(
       'scheduled',
       processScheduledJob,
       {
         connection: createRedisConnection(),
         concurrency: 3, // Lower concurrency for scheduled jobs
       }
     );

     worker.on('completed', (job) => {
       console.log(`[scheduled] Job ${job.id} completed`);
     });

     worker.on('failed', (job, err) => {
       console.error(`[scheduled] Job ${job?.id} failed:`, err.message);
     });

     console.log('[scheduled] Worker started');
     return worker;
   }
   ```

Design notes:
- withTenantContext ensures RLS is set before database operations
- Webhook worker routes by source to appropriate handler
- Test handlers allow Phase 1 verification without external services
- Placeholders for future phase implementations
- Separate workers for webhooks vs scheduled jobs (different scaling needs)
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/queue/workers/webhook.worker.ts exports startWebhookWorker
src/queue/workers/test.worker.ts exports startScheduledWorker
Workers handle 'test' job types for verification
  </verify>
  <done>
Webhook and scheduled job workers implemented with test handlers for Phase 1 verification. Workers use tenant context for RLS compliance.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. src/lib/redis.ts provides BullMQ-compatible Redis connections
3. src/queue/queues.ts defines webhookQueue, scheduledQueue, notificationQueue, activityQueue
4. Workers can be started with startWebhookWorker() and startScheduledWorker()
5. Job type interfaces provide type safety for enqueueing
</verification>

<success_criteria>
- Redis connection with maxRetriesPerRequest: null (BullMQ requirement)
- Separate queues for webhooks, scheduled jobs, notifications, activity
- Exponential backoff retry strategy configured
- Workers process jobs with tenant context for RLS compliance
- Test job handlers ready for Phase 1 verification
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
