---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/index.ts
  - src/routes/webhooks.ts
  - src/routes/health.ts
  - src/services/activity.ts
autonomous: true

must_haves:
  truths:
    - "Webhook endpoint receives POST and returns 200 within 500ms"
    - "Webhook payload is enqueued for async processing"
    - "Activity events are created and queryable per tenant"
  artifacts:
    - path: "src/index.ts"
      provides: "Main application entry point"
      exports: []
    - path: "src/routes/webhooks.ts"
      provides: "Webhook receiver endpoints"
      exports: ["webhookRoutes"]
    - path: "src/services/activity.ts"
      provides: "Activity feed service"
      exports: ["ActivityService", "activityService"]
  key_links:
    - from: "src/routes/webhooks.ts"
      to: "src/queue/queues.ts"
      via: "enqueues webhook jobs"
      pattern: "webhookQueue\\.add"
    - from: "src/services/activity.ts"
      to: "src/db/schema/activity-events.ts"
      via: "queries activity events"
      pattern: "activityEvents"
---

<objective>
Create the main Hono application with webhook endpoints and activity feed service.

Purpose: Deliver the webhook receiver that responds fast and queues for async processing, plus activity service that enables real-time dashboard feed.

Output: Running Hono server with /webhook/test endpoint that queues jobs and activity service for feed queries.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create activity feed service</name>
  <files>src/services/activity.ts</files>
  <action>
Create the activity feed service for querying and publishing activity events:

1. Create src/services/activity.ts:
   ```typescript
   import { db } from '../db/index.js';
   import { activityEvents, type ActivityEvent, type NewActivityEvent } from '../db/schema/index.js';
   import { eq, desc, and, gte, lte } from 'drizzle-orm';
   import { activityQueue, type ActivityJobData } from '../queue/index.js';

   export interface ActivityFeedOptions {
     limit?: number;
     offset?: number;
     eventType?: string;
     since?: Date;
     until?: Date;
   }

   /**
    * ActivityService handles activity feed operations.
    * Creates activity events and provides query interface for dashboard feed.
    */
   export class ActivityService {
     /**
      * Create an activity event and optionally publish to real-time feed.
      */
     async createEvent(
       tenantId: string,
       event: Omit<NewActivityEvent, 'tenantId'>
     ): Promise<ActivityEvent> {
       const [created] = await db
         .insert(activityEvents)
         .values({
           ...event,
           tenantId,
         })
         .returning();

       return created;
     }

     /**
      * Create event and publish to activity queue for real-time updates.
      */
     async createAndPublish(
       tenantId: string,
       event: Omit<NewActivityEvent, 'tenantId'>
     ): Promise<ActivityEvent> {
       // Create in database
       const created = await this.createEvent(tenantId, event);

       // Publish to activity queue for real-time feed
       await activityQueue.add('publish', {
         tenantId,
         eventType: event.eventType,
         title: event.title,
         description: event.description ?? undefined,
         metadata: event.metadata ?? undefined,
         source: event.source,
         sourceId: event.sourceId ?? undefined,
       } satisfies ActivityJobData);

       return created;
     }

     /**
      * Get activity feed for a tenant.
      * Results are ordered by occurredAt DESC (newest first).
      */
     async getFeed(
       tenantId: string,
       options: ActivityFeedOptions = {}
     ): Promise<ActivityEvent[]> {
       const {
         limit = 50,
         offset = 0,
         eventType,
         since,
         until,
       } = options;

       const conditions = [eq(activityEvents.tenantId, tenantId)];

       if (eventType) {
         conditions.push(eq(activityEvents.eventType, eventType));
       }

       if (since) {
         conditions.push(gte(activityEvents.occurredAt, since));
       }

       if (until) {
         conditions.push(lte(activityEvents.occurredAt, until));
       }

       const events = await db.query.activityEvents.findMany({
         where: and(...conditions),
         orderBy: [desc(activityEvents.occurredAt)],
         limit,
         offset,
       });

       return events;
     }

     /**
      * Get recent activity (last N events).
      */
     async getRecent(tenantId: string, count: number = 10): Promise<ActivityEvent[]> {
       return this.getFeed(tenantId, { limit: count });
     }

     /**
      * Get activity since a specific event (for polling updates).
      */
     async getSince(tenantId: string, sinceEventId: string): Promise<ActivityEvent[]> {
       // Get the timestamp of the reference event
       const referenceEvent = await db.query.activityEvents.findFirst({
         where: and(
           eq(activityEvents.tenantId, tenantId),
           eq(activityEvents.id, sinceEventId)
         ),
         columns: { occurredAt: true },
       });

       if (!referenceEvent) {
         // If reference event not found, return recent events
         return this.getRecent(tenantId, 20);
       }

       // Get events newer than the reference
       return db.query.activityEvents.findMany({
         where: and(
           eq(activityEvents.tenantId, tenantId),
           gte(activityEvents.occurredAt, referenceEvent.occurredAt)
         ),
         orderBy: [desc(activityEvents.occurredAt)],
         limit: 100,
       });
     }

     /**
      * Count events by type (for dashboard stats).
      */
     async countByType(
       tenantId: string,
       eventType: string,
       since?: Date
     ): Promise<number> {
       const conditions = [
         eq(activityEvents.tenantId, tenantId),
         eq(activityEvents.eventType, eventType),
       ];

       if (since) {
         conditions.push(gte(activityEvents.occurredAt, since));
       }

       const events = await db.query.activityEvents.findMany({
         where: and(...conditions),
         columns: { id: true },
       });

       return events.length;
     }
   }

   // Export singleton instance
   export const activityService = new ActivityService();
   ```

Design notes:
- createAndPublish both persists and queues for real-time updates
- Feed is sorted newest first (natural for dashboard)
- getSince enables efficient polling with last-event-id
- countByType supports dashboard statistics
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/services/activity.ts exports ActivityService, activityService
Methods: createEvent, createAndPublish, getFeed, getRecent, getSince
  </verify>
  <done>
Activity service implemented with create, publish, and query methods for dashboard feed support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook and health routes</name>
  <files>src/routes/webhooks.ts, src/routes/health.ts</files>
  <action>
Create webhook receiver endpoints that enqueue for async processing:

1. Create src/routes/webhooks.ts:
   ```typescript
   import { Hono } from 'hono';
   import { zValidator } from '@hono/zod-validator';
   import { z } from 'zod';
   import { nanoid } from 'nanoid';
   import { webhookQueue, type WebhookJobData } from '../queue/index.js';
   import { getRedis } from '../lib/redis.js';

   export const webhookRoutes = new Hono();

   // Generic webhook payload schema
   const webhookPayloadSchema = z.object({}).passthrough();

   /**
    * Test webhook endpoint for Phase 1 verification.
    * POST /webhook/test
    *
    * Accepts any JSON payload, enqueues for async processing.
    * Must respond within 500ms.
    */
   webhookRoutes.post(
     '/test',
     zValidator('json', webhookPayloadSchema),
     async (c) => {
       const startTime = Date.now();
       const payload = c.req.valid('json');

       // Extract or generate event ID (for idempotency)
       const eventId = (payload.event_id as string) || nanoid();

       // Get tenant ID from header (required for test webhook)
       const tenantId = c.req.header('X-Tenant-ID');
       if (!tenantId) {
         return c.json({ error: 'X-Tenant-ID header required' }, 400);
       }

       // Check idempotency (prevent duplicate processing)
       const redis = getRedis();
       const idempotencyKey = `webhook:idempotency:test:${eventId}`;
       const alreadyProcessed = await redis.get(idempotencyKey);

       if (alreadyProcessed) {
         return c.json({
           status: 'already_processed',
           event_id: eventId,
         }, 200);
       }

       // Set idempotency key (24 hour TTL)
       await redis.set(idempotencyKey, '1', 'EX', 86400);

       // Enqueue for async processing
       await webhookQueue.add(
         'test-webhook',
         {
           source: 'test',
           eventId,
           eventType: 'test.received',
           payload,
           tenantId,
           receivedAt: new Date().toISOString(),
         } satisfies WebhookJobData,
         {
           jobId: eventId, // Use event ID for deduplication
         }
       );

       const processingTime = Date.now() - startTime;
       console.log(`[webhook] Test webhook enqueued in ${processingTime}ms`);

       return c.json({
         status: 'accepted',
         event_id: eventId,
         processing_time_ms: processingTime,
       }, 200);
     }
   );

   /**
    * Voicenter webhook endpoint (placeholder for Phase 3).
    * POST /webhook/voicenter
    */
   webhookRoutes.post('/voicenter', async (c) => {
     // TODO: Implement in Phase 3
     return c.json({ error: 'Not implemented' }, 501);
   });

   /**
    * WhatsApp webhook endpoint (placeholder for Phase 2).
    * GET /webhook/whatsapp - Verification
    * POST /webhook/whatsapp - Events
    */
   webhookRoutes.get('/whatsapp', async (c) => {
     // TODO: Implement Meta webhook verification in Phase 2
     return c.json({ error: 'Not implemented' }, 501);
   });

   webhookRoutes.post('/whatsapp', async (c) => {
     // TODO: Implement in Phase 2
     return c.json({ error: 'Not implemented' }, 501);
   });

   /**
    * Accounting webhook endpoints (placeholder for Phase 6).
    */
   webhookRoutes.post('/greeninvoice', async (c) => {
     return c.json({ error: 'Not implemented' }, 501);
   });

   webhookRoutes.post('/icount', async (c) => {
     return c.json({ error: 'Not implemented' }, 501);
   });
   ```

2. Create src/routes/health.ts:
   ```typescript
   import { Hono } from 'hono';
   import { db } from '../db/index.js';
   import { getRedis } from '../lib/redis.js';
   import { sql } from 'drizzle-orm';

   export const healthRoutes = new Hono();

   /**
    * Basic health check - always returns 200.
    * GET /health
    */
   healthRoutes.get('/', (c) => {
     return c.json({
       status: 'ok',
       timestamp: new Date().toISOString(),
     });
   });

   /**
    * Deep health check - verifies database and Redis connections.
    * GET /health/deep
    */
   healthRoutes.get('/deep', async (c) => {
     const checks: Record<string, { status: string; latency_ms?: number; error?: string }> = {};

     // Check database
     try {
       const dbStart = Date.now();
       await db.execute(sql`SELECT 1`);
       checks.database = {
         status: 'ok',
         latency_ms: Date.now() - dbStart,
       };
     } catch (error) {
       checks.database = {
         status: 'error',
         error: error instanceof Error ? error.message : 'Unknown error',
       };
     }

     // Check Redis
     try {
       const redisStart = Date.now();
       const redis = getRedis();
       await redis.ping();
       checks.redis = {
         status: 'ok',
         latency_ms: Date.now() - redisStart,
       };
     } catch (error) {
       checks.redis = {
         status: 'error',
         error: error instanceof Error ? error.message : 'Unknown error',
       };
     }

     // Overall status
     const allOk = Object.values(checks).every((c) => c.status === 'ok');

     return c.json({
       status: allOk ? 'ok' : 'degraded',
       timestamp: new Date().toISOString(),
       checks,
     }, allOk ? 200 : 503);
   });
   ```

Design notes:
- Webhook endpoint uses idempotency key to prevent duplicate processing
- Response time logged to verify < 500ms requirement
- Health endpoints support both basic (for load balancer) and deep (for monitoring)
- Placeholders for future webhook sources
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/routes/webhooks.ts exports webhookRoutes
src/routes/health.ts exports healthRoutes
POST /webhook/test enqueues job and returns 200
  </verify>
  <done>
Webhook and health routes created. Test webhook enqueues jobs within 500ms target. Health checks verify database and Redis connectivity.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create main application entry point</name>
  <files>src/index.ts</files>
  <action>
Create the main Hono application that ties everything together:

1. Create src/index.ts:
   ```typescript
   import 'dotenv/config';
   import { serve } from '@hono/node-server';
   import { Hono } from 'hono';
   import { cors } from 'hono/cors';
   import { logger } from 'hono/logger';
   import { webhookRoutes } from './routes/webhooks.js';
   import { healthRoutes } from './routes/health.js';
   import { tenantContext } from './middleware/tenant-context.js';
   import { startWebhookWorker } from './queue/workers/webhook.worker.js';
   import { startScheduledWorker } from './queue/workers/test.worker.js';
   import { closeRedisConnections } from './lib/redis.js';

   // Create main app
   const app = new Hono();

   // Global middleware
   app.use('*', logger());
   app.use('*', cors());

   // Health routes (no auth required)
   app.route('/health', healthRoutes);

   // Webhook routes (no tenant auth - they bring their own auth)
   app.route('/webhook', webhookRoutes);

   // API routes (require tenant context)
   const api = new Hono();
   api.use('*', tenantContext);

   // Example protected endpoint for testing
   api.get('/me', (c) => {
     const tenant = c.get('tenant');
     return c.json({
       tenantId: tenant.tenantId,
       businessName: tenant.tenant?.businessName,
       status: tenant.tenant?.status,
     });
   });

   // Mount API under /api
   app.route('/api', api);

   // Root endpoint
   app.get('/', (c) => {
     return c.json({
       name: 'Findo API',
       version: '0.1.0',
       status: 'running',
     });
   });

   // Start server and workers
   const port = parseInt(process.env.PORT || '3000', 10);

   // Track workers for cleanup
   let webhookWorker: ReturnType<typeof startWebhookWorker> | null = null;
   let scheduledWorker: ReturnType<typeof startScheduledWorker> | null = null;

   // Graceful shutdown
   async function shutdown() {
     console.log('\n[server] Shutting down...');

     // Stop workers
     if (webhookWorker) {
       await webhookWorker.close();
       console.log('[server] Webhook worker stopped');
     }
     if (scheduledWorker) {
       await scheduledWorker.close();
       console.log('[server] Scheduled worker stopped');
     }

     // Close Redis connections
     await closeRedisConnections();
     console.log('[server] Redis connections closed');

     process.exit(0);
   }

   // Register shutdown handlers
   process.on('SIGINT', shutdown);
   process.on('SIGTERM', shutdown);

   // Start everything
   async function start() {
     console.log('[server] Starting Findo...');

     // Start workers
     webhookWorker = startWebhookWorker();
     scheduledWorker = startScheduledWorker();

     // Start HTTP server
     serve({
       fetch: app.fetch,
       port,
     });

     console.log(`[server] Findo API running on http://localhost:${port}`);
     console.log('[server] Ready to accept requests');
   }

   start().catch((error) => {
     console.error('[server] Failed to start:', error);
     process.exit(1);
   });
   ```

Design notes:
- Health and webhook routes are public (no tenant auth)
- API routes require tenant context middleware
- Workers start automatically with server
- Graceful shutdown closes workers and Redis connections
- Logger middleware for request tracking
- CORS enabled for dashboard access
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/index.ts imports all routes, middleware, and workers
Server starts on PORT environment variable (default 3000)
Graceful shutdown handler registered for SIGINT/SIGTERM
  </verify>
  <done>
Main application entry point created with public health/webhook routes, protected API routes with tenant context, and graceful shutdown handling.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. `pnpm dev` starts the server without errors
3. `curl http://localhost:3000/health` returns 200 with status: ok
4. `curl -X POST http://localhost:3000/webhook/test -H "Content-Type: application/json" -H "X-Tenant-ID: test-uuid" -d "{}"` returns 200 within 500ms
5. Webhook job appears in BullMQ queue and is processed by worker
</verification>

<success_criteria>
- Hono server starts and accepts requests
- /health endpoint returns service status
- /webhook/test accepts POST and enqueues job in < 500ms
- Activity service can create and query events
- Tenant context middleware protects /api routes
- Graceful shutdown stops workers and closes connections
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
