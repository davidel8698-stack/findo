---
phase: 01-foundation
plan: 06
type: execute
wave: 3
depends_on: ["01-04"]
files_modified:
  - src/scheduler/index.ts
  - src/scheduler/jobs.ts
  - src/queue/workers/activity.worker.ts
autonomous: true

must_haves:
  truths:
    - "Scheduled jobs run at configured intervals (hourly, daily, weekly)"
    - "Activity worker processes feed events for real-time updates"
    - "Test jobs can be scheduled and verified to run"
  artifacts:
    - path: "src/scheduler/index.ts"
      provides: "Job scheduler setup"
      exports: ["initializeScheduler"]
    - path: "src/scheduler/jobs.ts"
      provides: "Job definitions"
      exports: ["scheduleTestJobs", "scheduleRecurringJobs"]
    - path: "src/queue/workers/activity.worker.ts"
      provides: "Activity feed worker"
      exports: ["startActivityWorker"]
  key_links:
    - from: "src/scheduler/jobs.ts"
      to: "src/queue/queues.ts"
      via: "schedules jobs"
      pattern: "scheduledQueue\\.add"
---

<objective>
Implement background job scheduling for recurring tasks and activity feed processing.

Purpose: Enable hourly, daily, and weekly background jobs that power review checking, photo requests, and other autonomous operations. Activity worker publishes events for real-time dashboard.

Output: Scheduler that creates recurring BullMQ jobs and activity worker for real-time feed.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
@.planning/phases/01-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create activity feed worker</name>
  <files>src/queue/workers/activity.worker.ts</files>
  <action>
Create the activity worker that processes feed events:

1. Create src/queue/workers/activity.worker.ts:
   ```typescript
   import { Worker, Job } from 'bullmq';
   import { createRedisConnection, getRedis } from '../../lib/redis.js';
   import type { ActivityJobData } from '../queues.js';

   // Channel name for activity feed pub/sub
   const ACTIVITY_CHANNEL_PREFIX = 'activity:tenant:';

   /**
    * Process activity feed events.
    * Publishes to Redis pub/sub for real-time dashboard updates.
    */
   async function processActivity(job: Job<ActivityJobData>): Promise<void> {
     const { tenantId, eventType, title, description, metadata, source, sourceId } = job.data;

     console.log(`[activity] Publishing event: ${eventType} for tenant ${tenantId}`);

     // Create event payload for pub/sub
     const event = {
       id: job.id,
       tenantId,
       eventType,
       title,
       description,
       metadata,
       source,
       sourceId,
       publishedAt: new Date().toISOString(),
     };

     // Publish to tenant-specific channel
     const redis = getRedis();
     const channel = `${ACTIVITY_CHANNEL_PREFIX}${tenantId}`;

     await redis.publish(channel, JSON.stringify(event));

     console.log(`[activity] Published to ${channel}`);
   }

   /**
    * Start the activity feed worker.
    */
   export function startActivityWorker(): Worker<ActivityJobData> {
     const worker = new Worker<ActivityJobData>(
       'activity',
       processActivity,
       {
         connection: createRedisConnection(),
         concurrency: 10, // High concurrency for fast feed updates
       }
     );

     worker.on('completed', (job) => {
       console.log(`[activity] Job ${job.id} completed`);
     });

     worker.on('failed', (job, err) => {
       console.error(`[activity] Job ${job?.id} failed:`, err.message);
     });

     console.log('[activity] Worker started');
     return worker;
   }

   /**
    * Subscribe to activity feed for a tenant (for SSE endpoint).
    * Returns cleanup function.
    */
   export async function subscribeToActivityFeed(
     tenantId: string,
     onMessage: (event: Record<string, unknown>) => void
   ): Promise<() => void> {
     const redis = createRedisConnection(); // Dedicated connection for subscription
     const channel = `${ACTIVITY_CHANNEL_PREFIX}${tenantId}`;

     await redis.subscribe(channel);

     redis.on('message', (ch, message) => {
       if (ch === channel) {
         try {
           const event = JSON.parse(message);
           onMessage(event);
         } catch (error) {
           console.error('[activity] Failed to parse message:', error);
         }
       }
     });

     console.log(`[activity] Subscribed to ${channel}`);

     // Return cleanup function
     return async () => {
       await redis.unsubscribe(channel);
       await redis.quit();
       console.log(`[activity] Unsubscribed from ${channel}`);
     };
   }
   ```

Design notes:
- High concurrency (10) because activity events are lightweight
- Pub/sub via Redis enables real-time SSE to dashboard
- subscribeToActivityFeed helper for SSE endpoint implementation
- Tenant-specific channels for isolation
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/queue/workers/activity.worker.ts exports startActivityWorker, subscribeToActivityFeed
Worker publishes to Redis pub/sub channel
  </verify>
  <done>
Activity worker implemented with Redis pub/sub for real-time dashboard updates. Subscription helper ready for SSE endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job scheduler and job definitions</name>
  <files>src/scheduler/jobs.ts, src/scheduler/index.ts</files>
  <action>
Create the scheduler that sets up recurring BullMQ jobs:

1. Create src/scheduler/jobs.ts:
   ```typescript
   import { scheduledQueue, type ScheduledJobData } from '../queue/index.js';

   /**
    * Schedule test jobs for Phase 1 verification.
    * Creates hourly, daily, and weekly test jobs.
    */
   export async function scheduleTestJobs(): Promise<void> {
     console.log('[scheduler] Scheduling test jobs...');

     // Hourly test job - runs every hour at minute 0
     await scheduledQueue.add(
       'test-hourly',
       {
         jobType: 'test',
         params: { frequency: 'hourly' },
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '0 * * * *', // Every hour at minute 0
         },
         jobId: 'test-hourly', // Prevent duplicates
       }
     );
     console.log('[scheduler] Scheduled hourly test job');

     // Daily test job - runs every day at 10:00 AM Israel time
     await scheduledQueue.add(
       'test-daily',
       {
         jobType: 'test',
         params: { frequency: 'daily' },
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '0 10 * * *', // 10:00 AM every day
           tz: 'Asia/Jerusalem',
         },
         jobId: 'test-daily',
       }
     );
     console.log('[scheduler] Scheduled daily test job (10:00 AM Israel)');

     // Weekly test job - runs every Sunday at 10:00 AM Israel time
     await scheduledQueue.add(
       'test-weekly',
       {
         jobType: 'test',
         params: { frequency: 'weekly' },
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '0 10 * * 0', // 10:00 AM every Sunday
           tz: 'Asia/Jerusalem',
         },
         jobId: 'test-weekly',
       }
     );
     console.log('[scheduler] Scheduled weekly test job (Sunday 10:00 AM Israel)');
   }

   /**
    * Schedule production recurring jobs.
    * These are placeholders - will be implemented in later phases.
    */
   export async function scheduleRecurringJobs(): Promise<void> {
     console.log('[scheduler] Scheduling recurring jobs...');

     // Review check - hourly (Phase 5)
     await scheduledQueue.add(
       'review-check',
       {
         jobType: 'review-check',
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '0 * * * *', // Every hour
         },
         jobId: 'review-check-hourly',
       }
     );
     console.log('[scheduler] Scheduled review check (hourly)');

     // Token refresh check - every 30 minutes
     await scheduledQueue.add(
       'token-refresh',
       {
         jobType: 'token-refresh',
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '*/30 * * * *', // Every 30 minutes
         },
         jobId: 'token-refresh',
       }
     );
     console.log('[scheduler] Scheduled token refresh check (every 30 min)');

     // Photo request - weekly on Sunday 10:00 AM Israel (Phase 7)
     await scheduledQueue.add(
       'photo-request',
       {
         jobType: 'photo-request',
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '0 10 * * 0', // Sunday 10:00 AM
           tz: 'Asia/Jerusalem',
         },
         jobId: 'photo-request-weekly',
       }
     );
     console.log('[scheduler] Scheduled photo request (Sunday 10:00 AM Israel)');

     // Daily digest - every day at 10:00 AM Israel (Phase 9)
     await scheduledQueue.add(
       'daily-digest',
       {
         jobType: 'daily-digest',
       } satisfies ScheduledJobData,
       {
         repeat: {
           pattern: '0 10 * * *', // 10:00 AM every day
           tz: 'Asia/Jerusalem',
         },
         jobId: 'daily-digest',
       }
     );
     console.log('[scheduler] Scheduled daily digest (10:00 AM Israel)');
   }

   /**
    * Remove all scheduled test jobs.
    */
   export async function removeTestJobs(): Promise<void> {
     const repeatableJobs = await scheduledQueue.getRepeatableJobs();
     for (const job of repeatableJobs) {
       if (job.name.startsWith('test-')) {
         await scheduledQueue.removeRepeatableByKey(job.key);
         console.log(`[scheduler] Removed ${job.name}`);
       }
     }
   }

   /**
    * List all scheduled repeatable jobs.
    */
   export async function listScheduledJobs(): Promise<void> {
     const repeatableJobs = await scheduledQueue.getRepeatableJobs();
     console.log('[scheduler] Scheduled jobs:');
     for (const job of repeatableJobs) {
       console.log(`  - ${job.name}: ${job.pattern} (next: ${new Date(job.next).toISOString()})`);
     }
   }
   ```

2. Create src/scheduler/index.ts:
   ```typescript
   import { scheduleTestJobs, scheduleRecurringJobs, listScheduledJobs } from './jobs.js';

   /**
    * Initialize the job scheduler.
    * Sets up all recurring jobs on application startup.
    *
    * @param includeTestJobs - Whether to include test jobs (Phase 1 verification)
    */
   export async function initializeScheduler(includeTestJobs: boolean = false): Promise<void> {
     console.log('[scheduler] Initializing scheduler...');

     // Schedule production recurring jobs
     await scheduleRecurringJobs();

     // Optionally schedule test jobs for verification
     if (includeTestJobs) {
       await scheduleTestJobs();
     }

     // List all scheduled jobs
     await listScheduledJobs();

     console.log('[scheduler] Scheduler initialized');
   }

   export { scheduleTestJobs, scheduleRecurringJobs, listScheduledJobs } from './jobs.js';
   ```

Design notes:
- All times use Israel timezone (Asia/Jerusalem) per CONTEXT.md
- Sunday 10:00 AM for weekly jobs (start of Israeli work week)
- Daily jobs at 10:00 AM (after morning rush, per CONTEXT.md)
- Token refresh every 30 minutes (proactive, not reactive)
- Test jobs for Phase 1 verification
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/scheduler/index.ts exports initializeScheduler
src/scheduler/jobs.ts exports scheduleTestJobs, scheduleRecurringJobs
Jobs use Asia/Jerusalem timezone
  </verify>
  <done>
Scheduler implemented with hourly, daily, and weekly jobs using Israel timezone. Test jobs enable Phase 1 verification of scheduling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate scheduler and activity worker into main app</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to start scheduler and activity worker:

1. Update imports at top of src/index.ts:
   ```typescript
   import 'dotenv/config';
   import { serve } from '@hono/node-server';
   import { Hono } from 'hono';
   import { cors } from 'hono/cors';
   import { logger } from 'hono/logger';
   import { webhookRoutes } from './routes/webhooks.js';
   import { healthRoutes } from './routes/health.js';
   import { tenantContext } from './middleware/tenant-context.js';
   import { startWebhookWorker } from './queue/workers/webhook.worker.js';
   import { startScheduledWorker } from './queue/workers/test.worker.js';
   import { startActivityWorker } from './queue/workers/activity.worker.js';
   import { initializeScheduler } from './scheduler/index.js';
   import { closeRedisConnections } from './lib/redis.js';
   ```

2. Update worker tracking to include activity worker:
   ```typescript
   // Track workers for cleanup
   let webhookWorker: ReturnType<typeof startWebhookWorker> | null = null;
   let scheduledWorker: ReturnType<typeof startScheduledWorker> | null = null;
   let activityWorker: ReturnType<typeof startActivityWorker> | null = null;
   ```

3. Update shutdown function:
   ```typescript
   async function shutdown() {
     console.log('\n[server] Shutting down...');

     // Stop workers
     if (webhookWorker) {
       await webhookWorker.close();
       console.log('[server] Webhook worker stopped');
     }
     if (scheduledWorker) {
       await scheduledWorker.close();
       console.log('[server] Scheduled worker stopped');
     }
     if (activityWorker) {
       await activityWorker.close();
       console.log('[server] Activity worker stopped');
     }

     // Close Redis connections
     await closeRedisConnections();
     console.log('[server] Redis connections closed');

     process.exit(0);
   }
   ```

4. Update start function to initialize scheduler and activity worker:
   ```typescript
   async function start() {
     console.log('[server] Starting Findo...');

     // Start workers
     webhookWorker = startWebhookWorker();
     scheduledWorker = startScheduledWorker();
     activityWorker = startActivityWorker();

     // Initialize scheduler (include test jobs in development)
     const includeTestJobs = process.env.NODE_ENV !== 'production';
     await initializeScheduler(includeTestJobs);

     // Start HTTP server
     serve({
       fetch: app.fetch,
       port,
     });

     console.log(`[server] Findo API running on http://localhost:${port}`);
     console.log('[server] Ready to accept requests');
   }
   ```

This integrates:
- Activity worker for real-time feed processing
- Scheduler initialization on startup
- Test jobs enabled in non-production environments
- Graceful shutdown of activity worker
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
`pnpm dev` starts with all three workers and scheduler initialization
Console shows scheduled jobs list with next run times
Graceful shutdown stops all workers
  </verify>
  <done>
Main application updated with scheduler initialization and activity worker. All recurring jobs scheduled on startup with Israel timezone.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. `pnpm dev` starts server with output showing:
   - "[scheduler] Scheduling recurring jobs..."
   - "[scheduler] Scheduled jobs:" with list of jobs and next run times
   - All three workers started
3. Hourly, daily, and weekly jobs visible in scheduled jobs list
4. Jobs use Asia/Jerusalem timezone for Israeli business hours
</verification>

<success_criteria>
- Scheduler initializes recurring jobs on startup
- Hourly, daily, and weekly test jobs scheduled
- Production jobs scheduled (review-check, token-refresh, photo-request, daily-digest)
- Activity worker processes feed events and publishes to Redis pub/sub
- All jobs use Israel timezone (Asia/Jerusalem)
- Graceful shutdown stops all workers
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-06-SUMMARY.md`
</output>
