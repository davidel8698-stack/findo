---
phase: 01-foundation
plan: 07
type: execute
wave: 4
depends_on: ["01-05", "01-06"]
files_modified:
  - src/routes/activity.ts
  - src/index.ts
  - scripts/seed-test-tenants.ts
  - scripts/verify-phase1.ts
autonomous: true

must_haves:
  truths:
    - "Two test tenants exist in database with unique IDs"
    - "RLS prevents cross-tenant data access"
    - "Activity feed SSE endpoint streams events to tenant"
    - "All Phase 1 success criteria verified"
  artifacts:
    - path: "scripts/seed-test-tenants.ts"
      provides: "Test tenant seeding script"
      exports: []
    - path: "scripts/verify-phase1.ts"
      provides: "Phase 1 verification script"
      exports: []
    - path: "src/routes/activity.ts"
      provides: "Activity feed endpoints"
      exports: ["activityRoutes"]
  key_links:
    - from: "src/routes/activity.ts"
      to: "src/services/activity.ts"
      via: "queries activity feed"
      pattern: "activityService\\."
    - from: "scripts/verify-phase1.ts"
      to: "src/routes/webhooks.ts"
      via: "tests webhook endpoint"
      pattern: "webhook/test"
---

<objective>
Complete Phase 1 by adding activity feed endpoints and verification scripts.

Purpose: Add the activity feed SSE endpoint for real-time dashboard updates and create verification scripts that prove all Phase 1 success criteria are met.

Output: Complete foundation infrastructure with passing verification tests.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-05-SUMMARY.md
@.planning/phases/01-foundation/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create activity feed routes with SSE</name>
  <files>src/routes/activity.ts, src/index.ts</files>
  <action>
Create activity feed endpoints including SSE for real-time updates:

1. Create src/routes/activity.ts:
   ```typescript
   import { Hono } from 'hono';
   import { stream } from 'hono/streaming';
   import { activityService } from '../services/activity.js';
   import { subscribeToActivityFeed } from '../queue/workers/activity.worker.js';

   export const activityRoutes = new Hono();

   /**
    * Get activity feed for authenticated tenant.
    * GET /api/activity
    *
    * Query params:
    * - limit: number (default 50)
    * - offset: number (default 0)
    * - eventType: string (optional filter)
    * - since: ISO date string (optional)
    */
   activityRoutes.get('/', async (c) => {
     const tenant = c.get('tenant');
     const { limit, offset, eventType, since } = c.req.query();

     const events = await activityService.getFeed(tenant.tenantId, {
       limit: limit ? parseInt(limit, 10) : 50,
       offset: offset ? parseInt(offset, 10) : 0,
       eventType: eventType || undefined,
       since: since ? new Date(since) : undefined,
     });

     return c.json({
       events,
       pagination: {
         limit: limit ? parseInt(limit, 10) : 50,
         offset: offset ? parseInt(offset, 10) : 0,
         count: events.length,
       },
     });
   });

   /**
    * Get recent activity (last N events).
    * GET /api/activity/recent
    */
   activityRoutes.get('/recent', async (c) => {
     const tenant = c.get('tenant');
     const { count } = c.req.query();

     const events = await activityService.getRecent(
       tenant.tenantId,
       count ? parseInt(count, 10) : 10
     );

     return c.json({ events });
   });

   /**
    * Server-Sent Events stream for real-time activity updates.
    * GET /api/activity/stream
    *
    * Use with EventSource in browser:
    *   const es = new EventSource('/api/activity/stream', {
    *     headers: { 'X-Tenant-ID': tenantId }
    *   });
    *   es.onmessage = (e) => console.log(JSON.parse(e.data));
    */
   activityRoutes.get('/stream', async (c) => {
     const tenant = c.get('tenant');

     return stream(c, async (stream) => {
       // Send initial connection message
       await stream.write(`data: ${JSON.stringify({ type: 'connected', tenantId: tenant.tenantId })}\n\n`);

       // Subscribe to activity feed
       const unsubscribe = await subscribeToActivityFeed(tenant.tenantId, async (event) => {
         try {
           await stream.write(`data: ${JSON.stringify(event)}\n\n`);
         } catch (error) {
           // Client disconnected
           console.log(`[activity] Client disconnected for tenant ${tenant.tenantId}`);
         }
       });

       // Keep connection alive with heartbeat
       const heartbeat = setInterval(async () => {
         try {
           await stream.write(`: heartbeat\n\n`);
         } catch {
           // Client disconnected, cleanup will happen
         }
       }, 30000); // Every 30 seconds

       // Cleanup on disconnect
       stream.onAbort(() => {
         console.log(`[activity] Stream aborted for tenant ${tenant.tenantId}`);
         clearInterval(heartbeat);
         unsubscribe();
       });
     }, {
       headers: {
         'Content-Type': 'text/event-stream',
         'Cache-Control': 'no-cache',
         'Connection': 'keep-alive',
       },
     });
   });
   ```

2. Update src/index.ts to add activity routes to the API:
   After the `api.get('/me', ...)` endpoint, add:
   ```typescript
   import { activityRoutes } from './routes/activity.js';

   // ... existing code ...

   // Add activity routes
   api.route('/activity', activityRoutes);
   ```

Design notes:
- SSE endpoint uses Hono's stream helper for proper SSE format
- Heartbeat keeps connection alive (every 30 seconds)
- Cleanup function unsubscribes from Redis pub/sub
- Pagination support for feed endpoint
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
src/routes/activity.ts exports activityRoutes
GET /api/activity requires tenant context
GET /api/activity/stream returns SSE stream
  </verify>
  <done>
Activity feed routes implemented with REST endpoints for queries and SSE endpoint for real-time updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test tenant seeding script</name>
  <files>scripts/seed-test-tenants.ts</files>
  <action>
Create script to seed two test tenants for Phase 1 verification:

1. Create scripts/seed-test-tenants.ts:
   ```typescript
   import 'dotenv/config';
   import { db } from '../src/db/index.js';
   import { tenants } from '../src/db/schema/index.js';
   import { tokenVaultService } from '../src/services/token-vault.js';
   import { sql } from 'drizzle-orm';

   /**
    * Seed two test tenants for Phase 1 verification.
    * These tenants will be used to verify:
    * - Multi-tenant architecture works
    * - RLS prevents cross-tenant access
    * - Token vault encryption works
    */
   async function seedTestTenants() {
     console.log('Seeding test tenants...');

     // Clear existing test tenants (for re-running)
     await db.delete(tenants).where(
       sql`owner_email LIKE '%@test.findo.local'`
     );
     console.log('Cleared existing test tenants');

     // Create Tenant A
     const [tenantA] = await db
       .insert(tenants)
       .values({
         businessName: 'Test Business A',
         businessType: 'Restaurant',
         ownerName: 'Test Owner A',
         ownerEmail: 'owner-a@test.findo.local',
         ownerPhone: '+972501234567',
         address: 'Tel Aviv, Israel',
         status: 'trial',
         trialEndsAt: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 days
         timezone: 'Asia/Jerusalem',
       })
       .returning();

     console.log(`Created Tenant A: ${tenantA.id}`);
     console.log(`  Business: ${tenantA.businessName}`);
     console.log(`  Owner: ${tenantA.ownerName} (${tenantA.ownerEmail})`);

     // Create Tenant B
     const [tenantB] = await db
       .insert(tenants)
       .values({
         businessName: 'Test Business B',
         businessType: 'Plumber',
         ownerName: 'Test Owner B',
         ownerEmail: 'owner-b@test.findo.local',
         ownerPhone: '+972509876543',
         address: 'Jerusalem, Israel',
         status: 'active',
         timezone: 'Asia/Jerusalem',
       })
       .returning();

     console.log(`Created Tenant B: ${tenantB.id}`);
     console.log(`  Business: ${tenantB.businessName}`);
     console.log(`  Owner: ${tenantB.ownerName} (${tenantB.ownerEmail})`);

     // Store test tokens for both tenants
     console.log('\nStoring test tokens...');

     // Tenant A: WhatsApp tokens
     await tokenVaultService.storeToken(tenantA.id, 'whatsapp', 'access_token', {
       value: 'test-whatsapp-token-tenant-a',
       expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
       identifier: 'waba-12345',
     });
     console.log('  Stored WhatsApp access token for Tenant A');

     // Tenant B: Google tokens
     await tokenVaultService.storeToken(tenantB.id, 'google', 'access_token', {
       value: 'test-google-token-tenant-b',
       expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
       identifier: 'gbp-67890',
     });
     await tokenVaultService.storeToken(tenantB.id, 'google', 'refresh_token', {
       value: 'test-google-refresh-token-tenant-b',
       identifier: 'gbp-67890',
     });
     console.log('  Stored Google tokens for Tenant B');

     console.log('\n=== Test Tenants Seeded ===');
     console.log(`Tenant A ID: ${tenantA.id}`);
     console.log(`Tenant B ID: ${tenantB.id}`);
     console.log('\nUse these IDs in X-Tenant-ID header for testing.');

     // Return IDs for use in verification script
     return {
       tenantA: tenantA.id,
       tenantB: tenantB.id,
     };
   }

   // Run if executed directly
   seedTestTenants()
     .then(() => {
       console.log('\nDone!');
       process.exit(0);
     })
     .catch((error) => {
       console.error('Error seeding tenants:', error);
       process.exit(1);
     });

   export { seedTestTenants };
   ```

2. Add script to package.json:
   ```json
   "scripts": {
     "seed:test": "tsx scripts/seed-test-tenants.ts"
   }
   ```
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
scripts/seed-test-tenants.ts exists and exports seedTestTenants
`pnpm seed:test` creates two test tenants with unique IDs
  </verify>
  <done>
Test tenant seeding script created. Seeds two tenants with different business types and test tokens for verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Phase 1 verification script</name>
  <files>scripts/verify-phase1.ts</files>
  <action>
Create comprehensive verification script for all Phase 1 success criteria:

1. Create scripts/verify-phase1.ts:
   ```typescript
   import 'dotenv/config';
   import { db } from '../src/db/index.js';
   import { tenants, activityEvents, tokenVault } from '../src/db/schema/index.js';
   import { tokenVaultService } from '../src/services/token-vault.js';
   import { setTenantContext, clearTenantContext } from '../src/middleware/tenant-context.js';
   import { eq, sql } from 'drizzle-orm';

   const BASE_URL = process.env.BASE_URL || 'http://localhost:3000';

   interface VerificationResult {
     criterion: string;
     passed: boolean;
     details: string;
   }

   const results: VerificationResult[] = [];

   function log(criterion: string, passed: boolean, details: string) {
     results.push({ criterion, passed, details });
     const status = passed ? '✓ PASS' : '✗ FAIL';
     console.log(`${status}: ${criterion}`);
     console.log(`  ${details}`);
   }

   /**
    * Criterion 1: Webhook processes and returns 200 within 500ms
    */
   async function verifyWebhook(tenantId: string) {
     console.log('\n=== Criterion 1: Webhook Processing ===');

     const start = Date.now();
     const response = await fetch(`${BASE_URL}/webhook/test`, {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
         'X-Tenant-ID': tenantId,
       },
       body: JSON.stringify({
         event_id: `verify-${Date.now()}`,
         test_data: 'Phase 1 verification',
       }),
     });
     const elapsed = Date.now() - start;

     const data = await response.json();

     log(
       'Webhook returns 200',
       response.status === 200,
       `Status: ${response.status}, Response: ${JSON.stringify(data)}`
     );

     log(
       'Webhook responds within 500ms',
       elapsed < 500,
       `Response time: ${elapsed}ms`
     );

     // Wait for job to process
     await new Promise((resolve) => setTimeout(resolve, 1000));

     // Check activity event was created
     await setTenantContext(tenantId);
     const events = await db.query.activityEvents.findMany({
       where: eq(activityEvents.tenantId, tenantId),
       orderBy: (events, { desc }) => [desc(events.createdAt)],
       limit: 1,
     });
     await clearTenantContext();

     log(
       'Webhook job queued and processed asynchronously',
       events.length > 0 && events[0].eventType === 'webhook.test',
       `Activity events found: ${events.length}, Latest type: ${events[0]?.eventType || 'none'}`
     );
   }

   /**
    * Criterion 2: Two test tenants with RLS isolation
    */
   async function verifyRLSIsolation(tenantAId: string, tenantBId: string) {
     console.log('\n=== Criterion 2: RLS Tenant Isolation ===');

     // Verify tenants exist
     const tenantA = await db.query.tenants.findFirst({
       where: eq(tenants.id, tenantAId),
     });
     const tenantB = await db.query.tenants.findFirst({
       where: eq(tenants.id, tenantBId),
     });

     log(
       'Two test tenants exist',
       !!tenantA && !!tenantB,
       `Tenant A: ${tenantA?.businessName || 'NOT FOUND'}, Tenant B: ${tenantB?.businessName || 'NOT FOUND'}`
     );

     // Create activity event for Tenant A
     await setTenantContext(tenantAId);
     await db.insert(activityEvents).values({
       tenantId: tenantAId,
       eventType: 'test.rls',
       title: 'RLS Test Event A',
       source: 'verify-script',
     });

     // Try to query from Tenant A context - should see Tenant A events only
     const eventsFromA = await db.query.activityEvents.findMany({
       where: eq(activityEvents.eventType, 'test.rls'),
     });
     await clearTenantContext();

     // Create activity event for Tenant B
     await setTenantContext(tenantBId);
     await db.insert(activityEvents).values({
       tenantId: tenantBId,
       eventType: 'test.rls',
       title: 'RLS Test Event B',
       source: 'verify-script',
     });

     // Query from Tenant B context - should NOT see Tenant A events
     const eventsFromB = await db.query.activityEvents.findMany({
       where: eq(activityEvents.eventType, 'test.rls'),
     });
     await clearTenantContext();

     // Tenant A should only see 1 event (their own)
     const tenantASeesTenantB = eventsFromA.some((e) => e.tenantId === tenantBId);
     const tenantBSeesTenantA = eventsFromB.some((e) => e.tenantId === tenantAId);

     log(
       'RLS prevents Tenant A from seeing Tenant B data',
       !tenantASeesTenantB,
       `Tenant A query found ${eventsFromA.length} events, cross-tenant: ${tenantASeesTenantB}`
     );

     log(
       'RLS prevents Tenant B from seeing Tenant A data',
       !tenantBSeesTenantA,
       `Tenant B query found ${eventsFromB.length} events, cross-tenant: ${tenantBSeesTenantA}`
     );
   }

   /**
    * Criterion 3: Encrypted token storage
    */
   async function verifyTokenEncryption(tenantId: string) {
     console.log('\n=== Criterion 3: Encrypted Token Storage ===');

     const testToken = 'super-secret-test-token-12345';

     // Store token
     await tokenVaultService.storeToken(tenantId, 'voicenter', 'api_key', {
       value: testToken,
     });

     // Verify encrypted in database (direct query, no decryption)
     const rawEntry = await db.query.tokenVault.findFirst({
       where: eq(tokenVault.tenantId, tenantId),
     });

     const encryptedDoesNotContainPlaintext =
       rawEntry && !rawEntry.encryptedValue.includes(testToken);

     log(
       'Tokens encrypted before storage (plaintext not in DB)',
       !!encryptedDoesNotContainPlaintext,
       `Stored value starts with: ${rawEntry?.encryptedValue.substring(0, 50)}...`
     );

     // Retrieve and verify decryption works
     const retrieved = await tokenVaultService.getToken(tenantId, 'voicenter', 'api_key');

     log(
       'Tokens decrypted on retrieval',
       retrieved?.value === testToken,
       `Retrieved value matches original: ${retrieved?.value === testToken}`
     );
   }

   /**
    * Criterion 4: Background job scheduler
    */
   async function verifyScheduler() {
     console.log('\n=== Criterion 4: Background Job Scheduler ===');

     // Check scheduled jobs via BullMQ
     const { scheduledQueue } = await import('../src/queue/index.js');
     const repeatableJobs = await scheduledQueue.getRepeatableJobs();

     const hasHourly = repeatableJobs.some((j) => j.name.includes('hourly') || j.pattern === '0 * * * *');
     const hasDaily = repeatableJobs.some((j) => j.name.includes('daily') || j.pattern === '0 10 * * *');
     const hasWeekly = repeatableJobs.some((j) => j.name.includes('weekly') || j.pattern === '0 10 * * 0');

     log(
       'Hourly job scheduled',
       hasHourly,
       `Found hourly jobs: ${repeatableJobs.filter((j) => j.pattern?.includes('* * * *')).map((j) => j.name).join(', ') || 'none'}`
     );

     log(
       'Daily job scheduled',
       hasDaily,
       `Found daily jobs: ${repeatableJobs.filter((j) => j.name.includes('daily') || j.name.includes('digest')).map((j) => j.name).join(', ') || 'none'}`
     );

     log(
       'Weekly job scheduled',
       hasWeekly,
       `Found weekly jobs: ${repeatableJobs.filter((j) => j.name.includes('weekly') || j.name.includes('photo')).map((j) => j.name).join(', ') || 'none'}`
     );

     console.log('\n  All scheduled jobs:');
     for (const job of repeatableJobs) {
       console.log(`    - ${job.name}: ${job.pattern} (next: ${new Date(job.next).toLocaleString()})`);
     }
   }

   /**
    * Criterion 5: Activity feed real-time updates
    */
   async function verifyActivityFeed(tenantId: string) {
     console.log('\n=== Criterion 5: Activity Feed Real-time ===');

     // Create an activity event via service
     const { activityService } = await import('../src/services/activity.js');

     await setTenantContext(tenantId);
     const event = await activityService.createAndPublish(tenantId, {
       eventType: 'test.realtime',
       title: 'Real-time Test Event',
       description: 'Testing activity feed',
       source: 'verify-script',
     });
     await clearTenantContext();

     log(
       'Activity event created',
       !!event.id,
       `Event ID: ${event.id}, Type: ${event.eventType}`
     );

     // Verify event can be queried via API
     const response = await fetch(`${BASE_URL}/api/activity/recent?count=5`, {
       headers: {
         'X-Tenant-ID': tenantId,
       },
     });

     const data = await response.json();
     const hasRealtimeEvent = data.events?.some((e: any) => e.eventType === 'test.realtime');

     log(
       'Activity feed receives real-time updates',
       response.status === 200 && hasRealtimeEvent,
       `API returned ${data.events?.length || 0} events, includes test event: ${hasRealtimeEvent}`
     );
   }

   /**
    * Run all verifications
    */
   async function runVerification() {
     console.log('========================================');
     console.log('  PHASE 1 VERIFICATION');
     console.log('========================================');
     console.log(`Testing against: ${BASE_URL}`);

     // Get test tenant IDs
     const testTenants = await db.query.tenants.findMany({
       where: sql`owner_email LIKE '%@test.findo.local'`,
       limit: 2,
     });

     if (testTenants.length < 2) {
       console.error('\n✗ ERROR: Test tenants not found. Run: pnpm seed:test');
       process.exit(1);
     }

     const tenantAId = testTenants[0].id;
     const tenantBId = testTenants[1].id;

     console.log(`\nUsing test tenants:`);
     console.log(`  Tenant A: ${tenantAId} (${testTenants[0].businessName})`);
     console.log(`  Tenant B: ${tenantBId} (${testTenants[1].businessName})`);

     // Run all criteria checks
     await verifyWebhook(tenantAId);
     await verifyRLSIsolation(tenantAId, tenantBId);
     await verifyTokenEncryption(tenantAId);
     await verifyScheduler();
     await verifyActivityFeed(tenantAId);

     // Summary
     console.log('\n========================================');
     console.log('  VERIFICATION SUMMARY');
     console.log('========================================');

     const passed = results.filter((r) => r.passed).length;
     const failed = results.filter((r) => !r.passed).length;

     console.log(`\nTotal: ${results.length} checks`);
     console.log(`Passed: ${passed}`);
     console.log(`Failed: ${failed}`);

     if (failed > 0) {
       console.log('\n✗ FAILED CHECKS:');
       for (const r of results.filter((r) => !r.passed)) {
         console.log(`  - ${r.criterion}: ${r.details}`);
       }
     }

     const allPassed = failed === 0;
     console.log(`\n${allPassed ? '✓ PHASE 1 COMPLETE' : '✗ PHASE 1 INCOMPLETE'}`);

     process.exit(allPassed ? 0 : 1);
   }

   // Run verification
   runVerification().catch((error) => {
     console.error('Verification failed with error:', error);
     process.exit(1);
   });
   ```

2. Add script to package.json:
   ```json
   "scripts": {
     "verify:phase1": "tsx scripts/verify-phase1.ts"
   }
   ```
  </action>
  <verify>
TypeScript compiles: `pnpm exec tsc --noEmit`
scripts/verify-phase1.ts exists
`pnpm verify:phase1` runs all Phase 1 success criteria checks
Script outputs PASS/FAIL for each criterion
  </verify>
  <done>
Comprehensive Phase 1 verification script created. Tests all 5 success criteria from ROADMAP.md: webhook processing, RLS isolation, encrypted tokens, job scheduling, activity feed.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm exec tsc --noEmit` passes with no errors
2. `pnpm seed:test` creates two test tenants
3. `pnpm dev` starts the server
4. `pnpm verify:phase1` runs all checks and outputs results
5. All Phase 1 success criteria pass:
   - Webhook at /webhook/test returns 200 within 500ms
   - Two test tenants exist with RLS preventing cross-tenant access
   - Encrypted token storage works (encrypt/decrypt)
   - Scheduler runs hourly, daily, weekly test jobs
   - Activity feed receives real-time updates
</verification>

<success_criteria>
- Activity feed SSE endpoint streams events in real-time
- Test tenant seeding script creates two isolated tenants
- Verification script checks all Phase 1 success criteria
- All criteria pass when running verification
- Phase 1 foundation infrastructure complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-07-SUMMARY.md`
</output>
