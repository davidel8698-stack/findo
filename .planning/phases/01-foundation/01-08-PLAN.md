---
phase: 01-foundation
plan: 08
type: execute
wave: 5
depends_on: [01-05, 01-02]
files_modified:
  - src/index.ts
  - src/lib/redis.ts
  - src/db/rls.sql
  - docs/rls-setup.md
  - package.json
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "First webhook request completes within 500ms (no cold start penalty)"
    - "RLS prevents cross-tenant data access even for Tenant B"
    - "Non-superuser database role enforces RLS policies"
  artifacts:
    - path: "src/lib/redis.ts"
      provides: "Redis connection warm-up function"
      exports: ["warmUpConnections"]
    - path: "src/index.ts"
      provides: "Redis warm-up during startup"
      contains: "warmUpConnections"
    - path: "src/db/rls.sql"
      provides: "GRANT statements for findo_app role"
      contains: "GRANT SELECT"
    - path: "docs/rls-setup.md"
      provides: "Instructions for creating findo_app user"
      contains: "CREATE ROLE findo_app"
  key_links:
    - from: "src/index.ts"
      to: "src/lib/redis.ts"
      via: "warmUpConnections call in start()"
      pattern: "await warmUpConnections"
    - from: "src/db/rls.sql"
      to: "database"
      via: "GRANT statements for findo_app"
      pattern: "GRANT.*TO findo_app"
---

<objective>
Fix two diagnosed gaps from UAT: webhook cold start (689ms due to lazy Redis connections) and RLS bypass (database user has superuser privileges).

Purpose: Ensure Phase 1 success criteria are met - webhooks respond within 500ms and RLS truly isolates tenants at database level.

Output: Redis connections warm up before accepting requests; RLS properly configured for non-superuser application role.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-UAT.md
@.planning/phases/01-foundation/01-05-SUMMARY.md (webhook implementation)
@.planning/phases/01-foundation/01-02-SUMMARY.md (RLS implementation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Redis connection warm-up during startup</name>
  <files>src/lib/redis.ts, src/index.ts</files>
  <action>
Fix the webhook cold start issue by warming up Redis connections before accepting HTTP requests.

Root cause: lazyConnect: true defers TCP+TLS handshake (~300ms each to Upstash) until first command.

1. In src/lib/redis.ts, add a warmUpConnections function:
   ```typescript
   /**
    * Warm up Redis connections by executing a PING command.
    * Call this during startup to avoid cold start latency on first request.
    *
    * This establishes TCP+TLS connections eagerly instead of on first command.
    */
   export async function warmUpConnections(): Promise<void> {
     const redis = getRedis();

     // Force connection establishment with PING
     const startTime = Date.now();
     await redis.ping();
     const elapsed = Date.now() - startTime;

     console.log(`[redis] Connection warmed up in ${elapsed}ms`);
   }
   ```

2. In src/index.ts, call warmUpConnections() in the start() function BEFORE starting the HTTP server:
   ```typescript
   import { closeRedisConnections, warmUpConnections } from './lib/redis';

   async function start() {
     console.log('[server] Starting Findo...');

     // Warm up Redis connections BEFORE accepting requests
     console.log('[server] Warming up Redis connections...');
     await warmUpConnections();

     // Start workers (existing code)
     webhookWorker = startWebhookWorker();
     // ... rest of existing code
   ```

The warm-up ensures Redis TCP+TLS handshake completes during startup, not during the first webhook request.
  </action>
  <verify>
1. Run `pnpm dev` and observe "[redis] Connection warmed up in Xms" in startup logs
2. Run `curl -X POST http://localhost:3000/webhook/test -H "Content-Type: application/json" -H "X-Tenant-ID: test-tenant" -d "{}"` immediately after startup
3. Verify processing_time_ms is under 500ms (no cold start penalty)
  </verify>
  <done>
Redis connections are established during server startup. First webhook request completes within 500ms target.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update RLS SQL with proper GRANT statements for application user</name>
  <files>src/db/rls.sql, package.json</files>
  <action>
Fix the RLS bypass issue by adding proper GRANT statements for a non-superuser database role.

Root cause: Database user has SUPERUSER/owner privileges which bypass RLS even with FORCE ROW LEVEL SECURITY.

1. Update src/db/rls.sql to uncomment and expand GRANT statements:
   ```sql
   -- After the existing policies, add:

   -- =============================================================================
   -- APPLICATION USER SETUP
   -- =============================================================================
   -- The application must connect as 'findo_app' user (NOT the table owner/superuser)
   -- to enforce RLS policies. The table owner bypasses RLS even with FORCE ROW LEVEL SECURITY.
   --
   -- Run these commands as the database superuser/owner:

   -- Grant schema usage
   GRANT USAGE ON SCHEMA public TO findo_app;

   -- Grant table permissions (SELECT, INSERT, UPDATE, DELETE on all current tables)
   GRANT SELECT, INSERT, UPDATE, DELETE ON tenants TO findo_app;
   GRANT SELECT, INSERT, UPDATE, DELETE ON activity_events TO findo_app;
   GRANT SELECT, INSERT, UPDATE, DELETE ON token_vault TO findo_app;

   -- Grant sequence permissions (for auto-generated IDs if any)
   GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO findo_app;

   -- Grant execute on helper functions
   GRANT EXECUTE ON FUNCTION set_tenant_context(uuid) TO findo_app;
   GRANT EXECUTE ON FUNCTION get_current_tenant() TO findo_app;

   -- DEFAULT PRIVILEGES: Grant permissions on future tables created by owner
   ALTER DEFAULT PRIVILEGES IN SCHEMA public
   GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO findo_app;

   ALTER DEFAULT PRIVILEGES IN SCHEMA public
   GRANT USAGE, SELECT ON SEQUENCES TO findo_app;
   ```

2. Add a db:rls script to package.json:
   ```json
   "db:rls": "tsx scripts/apply-rls.ts"
   ```

3. Create scripts/apply-rls.ts:
   ```typescript
   import 'dotenv/config';
   import { readFileSync } from 'fs';
   import { join } from 'path';
   import postgres from 'postgres';

   const connectionString = process.env.DATABASE_URL;

   if (!connectionString) {
     throw new Error('DATABASE_URL environment variable is required');
   }

   async function applyRLS() {
     console.log('Applying RLS policies...');

     const sql = postgres(connectionString, { max: 1 });

     try {
       const rlsPath = join(process.cwd(), 'src', 'db', 'rls.sql');
       const rlsContent = readFileSync(rlsPath, 'utf-8');

       // Split by semicolons and execute each statement
       // Filter out empty statements and comments-only blocks
       const statements = rlsContent
         .split(';')
         .map(s => s.trim())
         .filter(s => s.length > 0 && !s.startsWith('--'));

       for (const statement of statements) {
         // Skip if only whitespace/comments remain
         const withoutComments = statement.replace(/--.*$/gm, '').trim();
         if (!withoutComments) continue;

         try {
           await sql.unsafe(statement + ';');
           console.log('  OK:', statement.substring(0, 60) + '...');
         } catch (err: any) {
           // Ignore "already exists" errors for idempotency
           if (err.message?.includes('already exists') ||
               err.message?.includes('duplicate')) {
             console.log('  SKIP (exists):', statement.substring(0, 50) + '...');
           } else {
             throw err;
           }
         }
       }

       console.log('\nRLS policies applied successfully!');
       console.log('\nIMPORTANT: See docs/rls-setup.md for creating the findo_app user.');
     } finally {
       await sql.end();
     }
   }

   applyRLS().catch((err) => {
     console.error('Failed to apply RLS:', err);
     process.exit(1);
   });
   ```
  </action>
  <verify>
1. File src/db/rls.sql contains GRANT statements for findo_app
2. package.json contains "db:rls" script
3. scripts/apply-rls.ts exists and is valid TypeScript
4. Run `pnpm exec tsc --noEmit` - no TypeScript errors
  </verify>
  <done>
RLS SQL updated with proper GRANT statements. db:rls script created for applying policies.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RLS setup documentation</name>
  <files>docs/rls-setup.md</files>
  <action>
Create documentation explaining how to set up the findo_app database user for proper RLS enforcement.

Create docs/rls-setup.md:

```markdown
# RLS Database User Setup

Row-Level Security (RLS) policies only work when the application connects as a **non-superuser** database role. The table owner/superuser bypasses RLS even with `FORCE ROW LEVEL SECURITY`.

## Why This Matters

Findo uses RLS to isolate tenant data at the database level. If the application connects as the database owner (which has superuser privileges), RLS policies are bypassed and tenants can see each other's data.

## Setup Steps

### 1. Create the findo_app Role

Connect to your database as the superuser and run:

```sql
-- Create the application role (no login, no superuser)
CREATE ROLE findo_app NOLOGIN;

-- Create a login user that inherits from findo_app
CREATE USER findo_app_user WITH PASSWORD 'your-secure-password-here' IN ROLE findo_app;
```

### 2. Apply RLS Policies and Grants

Run the RLS script which includes GRANT statements:

```bash
pnpm db:rls
```

This applies:
- RLS policies for tenant isolation
- GRANT permissions for findo_app on all tables
- Default privileges for future tables

### 3. Update DATABASE_URL

Update your `.env` to use the new user:

```
# Before (superuser - BAD for RLS)
DATABASE_URL=postgresql://postgres:password@host:5432/findo

# After (application user - GOOD for RLS)
DATABASE_URL=postgresql://findo_app_user:your-secure-password@host:5432/findo
```

### 4. Keep Superuser Credentials for Migrations

Store superuser credentials separately for migrations:

```
# For running migrations (needs superuser)
DATABASE_URL_ADMIN=postgresql://postgres:password@host:5432/findo

# For application (uses RLS-enforced user)
DATABASE_URL=postgresql://findo_app_user:your-secure-password@host:5432/findo
```

Update `db:migrate` script to use `DATABASE_URL_ADMIN` if set.

## Verification

After setup, run the phase verification:

```bash
pnpm verify:phase1
```

Both Tenant A and Tenant B isolation tests should pass.

## Troubleshooting

### "permission denied for table X"

The findo_app role doesn't have permissions. Re-run:

```bash
pnpm db:rls
```

### "role findo_app does not exist"

Create the role first (Step 1 above).

### RLS still not working

Check that you're connecting as findo_app_user, not postgres:

```sql
SELECT current_user;  -- Should return: findo_app_user
```
```
  </action>
  <verify>
1. File docs/rls-setup.md exists
2. Contains CREATE ROLE and CREATE USER commands
3. Explains the superuser bypass issue
4. Includes verification steps
  </verify>
  <done>
Documentation created explaining how to set up the findo_app database user for proper RLS enforcement.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Redis warm-up verification:**
   - Start server with `pnpm dev`
   - Check startup logs for "[redis] Connection warmed up"
   - Send webhook request immediately: `curl -X POST http://localhost:3000/webhook/test -H "Content-Type: application/json" -H "X-Tenant-ID: test" -d "{}"`
   - Verify processing_time_ms < 500

2. **RLS SQL verification:**
   - Check src/db/rls.sql contains `GRANT SELECT, INSERT, UPDATE, DELETE ON tenants TO findo_app`
   - Run `pnpm exec tsc --noEmit` - no errors

3. **Documentation verification:**
   - docs/rls-setup.md exists with setup instructions
</verification>

<success_criteria>
- Redis connections warm up during server startup (not on first request)
- First webhook request after startup completes within 500ms
- RLS SQL includes GRANT statements for findo_app application role
- db:rls script exists for applying RLS policies
- Documentation explains how to create findo_app user and configure DATABASE_URL
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-08-SUMMARY.md`
</output>
