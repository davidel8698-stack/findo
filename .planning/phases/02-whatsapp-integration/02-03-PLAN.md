---
phase: 02-whatsapp-integration
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/routes/webhooks.ts
  - src/services/whatsapp/webhooks.ts
  - src/services/whatsapp/index.ts
autonomous: true

must_haves:
  truths:
    - "Meta can verify webhook endpoint via GET challenge-response"
    - "Incoming webhook signatures are verified before processing"
    - "Webhook responds within 500ms regardless of payload complexity"
    - "Messages are queued for async processing"
    - "Status updates are queued separately from messages"
  artifacts:
    - path: "src/routes/webhooks.ts"
      provides: "WhatsApp webhook handlers"
      contains: "X-Hub-Signature-256"
    - path: "src/services/whatsapp/webhooks.ts"
      provides: "Webhook payload parsing and signature verification"
      exports: ["verifyWebhookSignature", "parseWebhookPayload"]
  key_links:
    - from: "src/routes/webhooks.ts"
      to: "src/services/whatsapp/webhooks.ts"
      via: "verifyWebhookSignature call"
      pattern: "verifyWebhookSignature"
    - from: "src/routes/webhooks.ts"
      to: "webhookQueue"
      via: "webhookQueue.add"
      pattern: "webhookQueue\\.add"
---

<objective>
Implement the WhatsApp webhook endpoints: GET for Meta verification and POST for receiving incoming messages with signature verification.

Purpose: Enable Meta to verify our webhook endpoint and allow receiving incoming WhatsApp messages. Messages are queued for async processing to ensure <500ms response time. This completes the bidirectional messaging capability.

Output: Working /webhook/whatsapp GET and POST endpoints with signature verification.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\דודאלמועלם\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-whatsapp-integration/02-CONTEXT.md
@.planning/phases/02-whatsapp-integration/02-RESEARCH.md

# From 02-01
@src/db/schema/whatsapp.ts
@src/queue/queues.ts

# Existing webhook infrastructure
@src/routes/webhooks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook payload parser and signature verification</name>
  <files>
    src/services/whatsapp/webhooks.ts
    src/services/whatsapp/index.ts
  </files>
  <action>
Create webhook utilities following RESEARCH.md patterns:

**src/services/whatsapp/webhooks.ts:**

```typescript
import crypto from 'crypto';

/**
 * WhatsApp webhook payload types.
 * Based on Meta Cloud API v21.0 webhook format.
 */
export interface WhatsAppWebhookPayload {
  object: 'whatsapp_business_account';
  entry: Array<{
    id: string; // WABA ID
    changes: Array<{
      field: 'messages';
      value: WhatsAppWebhookValue;
    }>;
  }>;
}

export interface WhatsAppWebhookValue {
  messaging_product: 'whatsapp';
  metadata: {
    display_phone_number: string;
    phone_number_id: string;
  };
  contacts?: Array<{
    profile: { name: string };
    wa_id: string;
  }>;
  messages?: Array<WhatsAppIncomingMessage>;
  statuses?: Array<WhatsAppStatusUpdate>;
}

export interface WhatsAppIncomingMessage {
  from: string;  // Sender phone number
  id: string;    // Message ID
  timestamp: string; // Unix timestamp as string
  type: 'text' | 'image' | 'audio' | 'video' | 'document' | 'sticker' | 'location' | 'contacts' | 'button' | 'interactive';
  text?: { body: string };
  image?: {
    id: string;
    mime_type: string;
    sha256: string;
    caption?: string;
  };
  // Other types omitted for Phase 2 (only text and image handled)
}

export interface WhatsAppStatusUpdate {
  id: string;        // Message ID
  status: 'sent' | 'delivered' | 'read' | 'failed';
  timestamp: string;
  recipient_id: string;
  errors?: Array<{
    code: number;
    title: string;
    message?: string;
  }>;
}

/**
 * Verify webhook signature using HMAC-SHA256.
 *
 * IMPORTANT: Must be called with raw body BEFORE JSON parsing.
 * Parsing changes the byte representation and breaks signature verification.
 *
 * @param rawBody - Raw request body as string or Buffer
 * @param signature - X-Hub-Signature-256 header value
 * @returns true if signature is valid
 */
export function verifyWebhookSignature(
  rawBody: string | Buffer,
  signature: string
): boolean {
  const appSecret = process.env.META_APP_SECRET;

  if (!appSecret) {
    console.error('[whatsapp] META_APP_SECRET not configured');
    return false;
  }

  if (!signature || !signature.startsWith('sha256=')) {
    console.warn('[whatsapp] Invalid signature format');
    return false;
  }

  const expectedSignature = 'sha256=' +
    crypto.createHmac('sha256', appSecret)
      .update(rawBody)
      .digest('hex');

  try {
    // Use timing-safe comparison to prevent timing attacks
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  } catch (error) {
    // Length mismatch will throw in timingSafeEqual
    console.warn('[whatsapp] Signature comparison failed:', error);
    return false;
  }
}

/**
 * Parse webhook payload into structured data.
 *
 * Separates messages from status updates for different processing queues.
 */
export function parseWebhookPayload(payload: WhatsAppWebhookPayload): {
  wabaId: string | null;
  phoneNumberId: string | null;
  messages: ParsedMessage[];
  statuses: ParsedStatus[];
} {
  const messages: ParsedMessage[] = [];
  const statuses: ParsedStatus[] = [];
  let wabaId: string | null = null;
  let phoneNumberId: string | null = null;

  for (const entry of payload.entry || []) {
    wabaId = entry.id;

    for (const change of entry.changes || []) {
      if (change.field !== 'messages') continue;

      const value = change.value;
      phoneNumberId = value.metadata.phone_number_id;

      // Parse incoming messages
      for (const msg of value.messages || []) {
        const contactName = value.contacts?.[0]?.profile.name;

        messages.push({
          waMessageId: msg.id,
          from: msg.from,
          timestamp: new Date(parseInt(msg.timestamp) * 1000),
          type: mapMessageType(msg.type),
          text: msg.text?.body,
          mediaId: msg.image?.id,
          mediaCaption: msg.image?.caption,
          contactName,
          rawType: msg.type,
        });
      }

      // Parse status updates
      for (const status of value.statuses || []) {
        statuses.push({
          waMessageId: status.id,
          status: status.status,
          timestamp: new Date(parseInt(status.timestamp) * 1000),
          recipientId: status.recipient_id,
          errorCode: status.errors?.[0]?.code,
          errorMessage: status.errors?.[0]?.message || status.errors?.[0]?.title,
        });
      }
    }
  }

  return { wabaId, phoneNumberId, messages, statuses };
}

export interface ParsedMessage {
  waMessageId: string;
  from: string;
  timestamp: Date;
  type: 'text' | 'image' | 'unknown';
  text?: string;
  mediaId?: string;
  mediaCaption?: string;
  contactName?: string;
  rawType: string; // Original type for logging/debugging
}

export interface ParsedStatus {
  waMessageId: string;
  status: 'sent' | 'delivered' | 'read' | 'failed';
  timestamp: Date;
  recipientId: string;
  errorCode?: number;
  errorMessage?: string;
}

/**
 * Map WhatsApp message type to our simplified types.
 * Phase 2 only handles text and image; others marked as unknown.
 */
function mapMessageType(waType: string): 'text' | 'image' | 'unknown' {
  switch (waType) {
    case 'text':
      return 'text';
    case 'image':
      return 'image';
    default:
      return 'unknown';
  }
}

/**
 * Check if message type is supported in Phase 2.
 */
export function isSupportedMessageType(type: string): boolean {
  return type === 'text' || type === 'image';
}
```

Update barrel export to include webhook utilities.
  </action>
  <verify>
    - File exists: src/services/whatsapp/webhooks.ts
    - verifyWebhookSignature, parseWebhookPayload exported
    - TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>
    Webhook signature verification with timing-safe comparison and payload parser that separates messages from status updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WhatsApp webhook endpoints</name>
  <files>
    src/routes/webhooks.ts
  </files>
  <action>
Replace the placeholder WhatsApp webhook handlers in src/routes/webhooks.ts:

**Update imports at top of file:**
```typescript
import {
  verifyWebhookSignature,
  parseWebhookPayload,
  isSupportedMessageType,
  type WhatsAppWebhookPayload,
} from '../services/whatsapp/webhooks';
```

**Replace the GET /webhook/whatsapp handler:**
```typescript
/**
 * WhatsApp webhook verification (GET).
 * Meta sends this request to verify webhook URL during setup.
 *
 * Must return hub.challenge value to confirm ownership.
 */
webhookRoutes.get('/whatsapp', async (c) => {
  const mode = c.req.query('hub.mode');
  const token = c.req.query('hub.verify_token');
  const challenge = c.req.query('hub.challenge');

  const expectedToken = process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN;

  if (!expectedToken) {
    console.error('[whatsapp] WHATSAPP_WEBHOOK_VERIFY_TOKEN not configured');
    return c.text('Server misconfigured', 500);
  }

  if (mode === 'subscribe' && token === expectedToken) {
    console.log('[whatsapp] Webhook verification successful');
    // Must return the challenge as plain text, not JSON
    return c.text(challenge || '', 200);
  }

  console.warn('[whatsapp] Webhook verification failed', { mode, tokenMatch: token === expectedToken });
  return c.text('Forbidden', 403);
});
```

**Replace the POST /webhook/whatsapp handler:**
```typescript
/**
 * WhatsApp webhook receiver (POST).
 * Receives incoming messages and status updates from Meta.
 *
 * CRITICAL: Must respond within 500ms. All processing is async via queue.
 */
webhookRoutes.post('/whatsapp', async (c) => {
  const startTime = Date.now();

  // IMPORTANT: Get raw body BEFORE any parsing for signature verification
  const rawBody = await c.req.text();
  const signature = c.req.header('X-Hub-Signature-256');

  // Verify signature
  if (!signature || !verifyWebhookSignature(rawBody, signature)) {
    console.warn('[whatsapp] Webhook signature verification failed');
    return c.text('Invalid signature', 401);
  }

  // Parse the payload after verification
  let payload: WhatsAppWebhookPayload;
  try {
    payload = JSON.parse(rawBody);
  } catch (error) {
    console.error('[whatsapp] Failed to parse webhook payload:', error);
    return c.text('Invalid JSON', 400);
  }

  // Extract structured data
  const { wabaId, phoneNumberId, messages, statuses } = parseWebhookPayload(payload);

  // Generate event ID for idempotency
  const eventId = `wa_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

  // Queue messages for processing
  if (messages.length > 0) {
    // Check idempotency for first message (batch dedup)
    const redis = getRedis();
    const idempotencyKey = `webhook:idempotency:whatsapp:${messages[0].waMessageId}`;
    const alreadyProcessed = await redis.get(idempotencyKey);

    if (!alreadyProcessed) {
      await redis.set(idempotencyKey, '1', 'EX', 86400); // 24 hour TTL

      await webhookQueue.add(
        'whatsapp-messages',
        {
          source: 'whatsapp',
          eventId,
          eventType: 'messages.received',
          payload: {
            wabaId,
            phoneNumberId,
            messages,
          },
          receivedAt: new Date().toISOString(),
        },
        {
          jobId: `msg_${messages[0].waMessageId}`,
        }
      );

      console.log(`[whatsapp] Queued ${messages.length} message(s) for processing`);
    }
  }

  // Queue status updates separately (batch processing)
  if (statuses.length > 0) {
    // Status updates can be batched, use timestamp-based dedup
    await webhookQueue.add(
      'whatsapp-statuses',
      {
        source: 'whatsapp',
        eventId: `status_${eventId}`,
        eventType: 'statuses.received',
        payload: {
          wabaId,
          phoneNumberId,
          statuses,
        },
        receivedAt: new Date().toISOString(),
      },
      {
        // Don't deduplicate status updates (they're idempotent by design)
      }
    );

    console.log(`[whatsapp] Queued ${statuses.length} status update(s) for processing`);
  }

  const processingTime = Date.now() - startTime;
  console.log(`[whatsapp] Webhook processed in ${processingTime}ms`);

  // Always return 200 OK to acknowledge receipt
  // Meta will retry if we don't respond quickly enough
  return c.text('OK', 200);
});
```

Make sure to add the getRedis import if not already present:
```typescript
import { getRedis } from '../lib/redis';
```
  </action>
  <verify>
    - GET /webhook/whatsapp responds with challenge when token matches
    - POST /webhook/whatsapp verifies signature before processing
    - Messages are queued to webhookQueue
    - Server starts: `pnpm dev`
    - Manual test:
      ```bash
      # Verification test
      curl "http://localhost:3000/webhook/whatsapp?hub.mode=subscribe&hub.verify_token=YOUR_TOKEN&hub.challenge=test123"
      # Should return: test123
      ```
  </verify>
  <done>
    WhatsApp webhook endpoints handle Meta verification and incoming messages with signature verification and queue-based async processing.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Verification endpoint test:**
   ```bash
   # Set WHATSAPP_WEBHOOK_VERIFY_TOKEN env var
   curl "http://localhost:3000/webhook/whatsapp?hub.mode=subscribe&hub.verify_token=YOUR_TOKEN&hub.challenge=test123"
   # Expected: test123 (plain text)
   ```

2. **Signature verification test:**
   ```bash
   # Without signature - should return 401
   curl -X POST http://localhost:3000/webhook/whatsapp \
     -H "Content-Type: application/json" \
     -d '{"object":"whatsapp_business_account","entry":[]}'
   # Expected: Invalid signature (401)
   ```

3. **TypeScript verification:**
   - `pnpm tsc --noEmit` passes with no errors

4. **Queue verification:**
   - With valid signature, messages should appear in webhookQueue
   - Check Redis for queued jobs
</verification>

<success_criteria>
- GET /webhook/whatsapp returns challenge when hub.verify_token matches WHATSAPP_WEBHOOK_VERIFY_TOKEN
- GET /webhook/whatsapp returns 403 when token doesn't match
- POST /webhook/whatsapp verifies X-Hub-Signature-256 using HMAC-SHA256
- Invalid signatures return 401
- Valid webhooks queue messages to webhookQueue with source: 'whatsapp'
- Status updates are queued separately from messages
- Response time is under 500ms (verified via log output)
</success_criteria>

<output>
After completion, create `.planning/phases/02-whatsapp-integration/02-03-SUMMARY.md`
</output>
