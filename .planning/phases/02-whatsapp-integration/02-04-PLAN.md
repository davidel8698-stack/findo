---
phase: 02-whatsapp-integration
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - src/queue/workers/whatsapp-message.worker.ts
  - src/queue/workers/whatsapp-status.worker.ts
  - src/queue/index.ts
  - src/services/whatsapp/conversations.ts
  - src/services/whatsapp/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Incoming text messages are saved to whatsapp_messages table"
    - "Incoming image messages are saved with mediaId"
    - "Conversation 24-hour window is opened/extended on customer message"
    - "Unknown message types trigger auto-reply explaining limitation"
    - "Status updates update message delivery/read status in database"
    - "Status updates are processed in batches"
  artifacts:
    - path: "src/queue/workers/whatsapp-message.worker.ts"
      provides: "Message processing worker"
      contains: "whatsapp-messages"
    - path: "src/queue/workers/whatsapp-status.worker.ts"
      provides: "Status update batch worker"
      contains: "whatsapp-statuses"
    - path: "src/services/whatsapp/conversations.ts"
      provides: "Conversation window management"
      exports: ["openConversationWindow", "getConversation"]
  key_links:
    - from: "src/queue/workers/whatsapp-message.worker.ts"
      to: "whatsapp_messages table"
      via: "db.insert"
      pattern: "whatsappMessages"
    - from: "src/queue/workers/whatsapp-message.worker.ts"
      to: "whatsapp_conversations table"
      via: "openConversationWindow"
      pattern: "openConversationWindow"
    - from: "src/queue/workers/whatsapp-status.worker.ts"
      to: "whatsapp_messages table"
      via: "db.update"
      pattern: "whatsappMessages"
---

<objective>
Create queue workers to process incoming WhatsApp messages and status updates. Messages are stored in the database with conversation window tracking. Status updates batch-update delivery/read status.

Purpose: Complete the incoming message processing pipeline. When webhooks queue messages, these workers persist them to the database and manage conversation windows for the 24-hour reply rule.

Output: Message worker, status worker, conversation service. Workers auto-start with the server.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\דודאלמועלם\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-whatsapp-integration/02-CONTEXT.md
@.planning/phases/02-whatsapp-integration/02-RESEARCH.md

# From 02-01 and 02-03
@src/db/schema/whatsapp.ts
@src/services/whatsapp/client.ts
@src/services/whatsapp/messages.ts
@src/services/whatsapp/webhooks.ts
@src/queue/queues.ts
@src/queue/workers/webhook.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation service</name>
  <files>
    src/services/whatsapp/conversations.ts
    src/services/whatsapp/index.ts
  </files>
  <action>
Create conversation management service for 24-hour window tracking:

**src/services/whatsapp/conversations.ts:**

```typescript
import { db } from '../../db/index';
import { whatsappConversations } from '../../db/schema/index';
import { eq, and } from 'drizzle-orm';

const WINDOW_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours

export interface ConversationInfo {
  id: string;
  tenantId: string;
  customerPhone: string;
  customerName: string | null;
  windowOpenedAt: Date;
  windowExpiresAt: Date;
  isWindowOpen: boolean;
  messageCount: number;
}

/**
 * Open or extend a conversation window.
 *
 * Called when customer sends a message. Window opens/extends for 24 hours.
 * Within this window, business can send freeform messages (not templates).
 */
export async function openConversationWindow(
  tenantId: string,
  customerPhone: string,
  customerName?: string
): Promise<ConversationInfo> {
  const now = new Date();
  const windowExpiresAt = new Date(now.getTime() + WINDOW_DURATION_MS);

  // Try to find existing conversation
  const existing = await db.query.whatsappConversations.findFirst({
    where: and(
      eq(whatsappConversations.tenantId, tenantId),
      eq(whatsappConversations.customerPhone, customerPhone)
    ),
  });

  if (existing) {
    // Update existing conversation - extend window
    await db
      .update(whatsappConversations)
      .set({
        windowOpenedAt: now,
        windowExpiresAt,
        lastMessageAt: now,
        messageCount: existing.messageCount + 1,
        ...(customerName && { customerName }),
        updatedAt: now,
      })
      .where(eq(whatsappConversations.id, existing.id));

    return {
      id: existing.id,
      tenantId,
      customerPhone,
      customerName: customerName || existing.customerName,
      windowOpenedAt: now,
      windowExpiresAt,
      isWindowOpen: true,
      messageCount: existing.messageCount + 1,
    };
  }

  // Create new conversation
  const [inserted] = await db
    .insert(whatsappConversations)
    .values({
      tenantId,
      customerPhone,
      customerName,
      windowOpenedAt: now,
      windowExpiresAt,
      lastMessageAt: now,
      messageCount: 1,
    })
    .returning();

  return {
    id: inserted.id,
    tenantId,
    customerPhone,
    customerName: customerName || null,
    windowOpenedAt: now,
    windowExpiresAt,
    isWindowOpen: true,
    messageCount: 1,
  };
}

/**
 * Get conversation for a customer.
 * Returns null if no conversation exists.
 */
export async function getConversation(
  tenantId: string,
  customerPhone: string
): Promise<ConversationInfo | null> {
  const conversation = await db.query.whatsappConversations.findFirst({
    where: and(
      eq(whatsappConversations.tenantId, tenantId),
      eq(whatsappConversations.customerPhone, customerPhone)
    ),
  });

  if (!conversation) {
    return null;
  }

  const now = new Date();
  const isWindowOpen = conversation.windowExpiresAt
    ? conversation.windowExpiresAt > now
    : false;

  return {
    id: conversation.id,
    tenantId: conversation.tenantId,
    customerPhone: conversation.customerPhone,
    customerName: conversation.customerName,
    windowOpenedAt: conversation.windowOpenedAt,
    windowExpiresAt: conversation.windowExpiresAt,
    isWindowOpen,
    messageCount: conversation.messageCount,
  };
}

/**
 * Check if conversation window is currently open.
 */
export async function isWindowOpen(
  tenantId: string,
  customerPhone: string
): Promise<boolean> {
  const conversation = await getConversation(tenantId, customerPhone);
  return conversation?.isWindowOpen ?? false;
}

/**
 * Increment message count for outbound message.
 */
export async function incrementMessageCount(
  tenantId: string,
  customerPhone: string
): Promise<void> {
  await db
    .update(whatsappConversations)
    .set({
      messageCount: db.raw('message_count + 1'),
      lastMessageAt: new Date(),
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(whatsappConversations.tenantId, tenantId),
        eq(whatsappConversations.customerPhone, customerPhone)
      )
    );
}
```

Update barrel export to include conversation functions.
  </action>
  <verify>
    - File exists: src/services/whatsapp/conversations.ts
    - openConversationWindow, getConversation, isWindowOpen exported
    - TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>
    Conversation service manages 24-hour windows with open, get, and check functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message processing worker</name>
  <files>
    src/queue/workers/whatsapp-message.worker.ts
    src/queue/index.ts
    src/index.ts
  </files>
  <action>
Create worker to process incoming WhatsApp messages:

**src/queue/workers/whatsapp-message.worker.ts:**

```typescript
import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { db } from '../../db/index';
import { whatsappMessages, whatsappConnections } from '../../db/schema/index';
import { openConversationWindow } from '../../services/whatsapp/conversations';
import { createWhatsAppClient, sendTextMessage } from '../../services/whatsapp/index';
import { activityService } from '../../services/activity';
import { eq } from 'drizzle-orm';
import type { ParsedMessage } from '../../services/whatsapp/webhooks';

interface WhatsAppMessagesJobData {
  source: 'whatsapp';
  eventId: string;
  eventType: 'messages.received';
  payload: {
    wabaId: string;
    phoneNumberId: string;
    messages: ParsedMessage[];
  };
  receivedAt: string;
}

// Auto-reply for unsupported message types (per CONTEXT.md)
const UNSUPPORTED_TYPE_REPLY = 'מצטערים, אני יכול לטפל רק בהודעות טקסט ותמונות.';
// Translation: "Sorry, I can only handle text messages and images."

export const whatsappMessageWorker = new Worker<WhatsAppMessagesJobData>(
  'webhooks', // Same queue as other webhooks
  async (job: Job<WhatsAppMessagesJobData>) => {
    // Only process whatsapp-messages jobs
    if (job.name !== 'whatsapp-messages') {
      return; // Skip non-message jobs
    }

    const { payload } = job.data;
    const { wabaId, phoneNumberId, messages } = payload;

    console.log(`[whatsapp-worker] Processing ${messages.length} message(s) from WABA ${wabaId}`);

    // Find tenant by WABA ID
    const connection = await db.query.whatsappConnections.findFirst({
      where: eq(whatsappConnections.wabaId, wabaId),
    });

    if (!connection) {
      console.warn(`[whatsapp-worker] No connection found for WABA ${wabaId}`);
      return;
    }

    const tenantId = connection.tenantId;

    for (const msg of messages) {
      try {
        // Open/extend conversation window (customer initiated contact)
        const conversation = await openConversationWindow(
          tenantId,
          msg.from,
          msg.contactName
        );

        // Determine if message type is supported
        const isSupported = msg.type === 'text' || msg.type === 'image';

        // Save message to database
        const [savedMessage] = await db
          .insert(whatsappMessages)
          .values({
            tenantId,
            conversationId: conversation.id,
            waMessageId: msg.waMessageId,
            direction: 'inbound',
            type: msg.type,
            content: msg.text,
            mediaId: msg.mediaId,
            senderPhone: msg.from,
            recipientPhone: phoneNumberId,
            status: 'delivered', // Inbound messages are already delivered
            createdAt: msg.timestamp,
          })
          .returning({ id: whatsappMessages.id });

        console.log(`[whatsapp-worker] Saved message ${msg.waMessageId} as ${savedMessage.id}`);

        // Publish activity event
        await activityService.createAndPublish(tenantId, {
          eventType: 'whatsapp.message.received',
          title: 'הודעת WhatsApp התקבלה',
          description: isSupported
            ? `${msg.contactName || msg.from}: ${msg.text?.slice(0, 100) || '[תמונה]'}`
            : `${msg.contactName || msg.from}: [${msg.rawType}]`,
          source: 'whatsapp',
          sourceId: savedMessage.id,
          metadata: {
            messageType: msg.type,
            from: msg.from,
            conversationId: conversation.id,
          },
        });

        // Send auto-reply for unsupported types
        if (!isSupported) {
          const client = await createWhatsAppClient(tenantId);
          if (client) {
            try {
              const reply = await sendTextMessage(client, msg.from, UNSUPPORTED_TYPE_REPLY);

              // Save auto-reply to database
              await db.insert(whatsappMessages).values({
                tenantId,
                conversationId: conversation.id,
                waMessageId: reply.messageId,
                direction: 'outbound',
                type: 'text',
                content: UNSUPPORTED_TYPE_REPLY,
                recipientPhone: msg.from,
                senderPhone: phoneNumberId,
                status: 'sent',
              });

              console.log(`[whatsapp-worker] Sent unsupported type auto-reply to ${msg.from}`);
            } catch (replyError) {
              console.error(`[whatsapp-worker] Failed to send auto-reply:`, replyError);
              // Don't fail the job for auto-reply failures
            }
          }
        }
      } catch (error) {
        console.error(`[whatsapp-worker] Failed to process message ${msg.waMessageId}:`, error);
        // Continue processing other messages
      }
    }
  },
  {
    connection: createRedisConnection(),
    concurrency: 5, // Process up to 5 message batches in parallel
  }
);

// Error handling
whatsappMessageWorker.on('failed', (job, error) => {
  console.error(`[whatsapp-worker] Job ${job?.id} failed:`, error.message);
});

whatsappMessageWorker.on('completed', (job) => {
  console.log(`[whatsapp-worker] Job ${job.id} completed`);
});

export function startWhatsAppMessageWorker() {
  console.log('[whatsapp-worker] Message worker started');
  return whatsappMessageWorker;
}

export async function stopWhatsAppMessageWorker() {
  await whatsappMessageWorker.close();
  console.log('[whatsapp-worker] Message worker stopped');
}
```

**Update src/queue/index.ts** to export the worker:
```typescript
export { startWhatsAppMessageWorker, stopWhatsAppMessageWorker } from './workers/whatsapp-message.worker';
```

**Update src/index.ts** to start the worker:
Add to imports:
```typescript
import { startWhatsAppMessageWorker, stopWhatsAppMessageWorker } from './queue/index';
```

Add to worker startup section:
```typescript
// Start WhatsApp message worker
startWhatsAppMessageWorker();
```

Add to graceful shutdown:
```typescript
await stopWhatsAppMessageWorker();
```
  </action>
  <verify>
    - File exists: src/queue/workers/whatsapp-message.worker.ts
    - Worker exports correctly from src/queue/index.ts
    - Server starts with worker: `pnpm dev` shows "Message worker started"
    - TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>
    Message worker processes incoming WhatsApp messages, saves to database, opens conversation windows, and sends auto-reply for unsupported types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create status update worker</name>
  <files>
    src/queue/workers/whatsapp-status.worker.ts
    src/queue/index.ts
    src/index.ts
  </files>
  <action>
Create worker to batch-process WhatsApp status updates:

**src/queue/workers/whatsapp-status.worker.ts:**

```typescript
import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { db } from '../../db/index';
import { whatsappMessages } from '../../db/schema/index';
import { eq } from 'drizzle-orm';
import type { ParsedStatus } from '../../services/whatsapp/webhooks';

interface WhatsAppStatusJobData {
  source: 'whatsapp';
  eventId: string;
  eventType: 'statuses.received';
  payload: {
    wabaId: string;
    phoneNumberId: string;
    statuses: ParsedStatus[];
  };
  receivedAt: string;
}

export const whatsappStatusWorker = new Worker<WhatsAppStatusJobData>(
  'webhooks', // Same queue as other webhooks
  async (job: Job<WhatsAppStatusJobData>) => {
    // Only process whatsapp-statuses jobs
    if (job.name !== 'whatsapp-statuses') {
      return; // Skip non-status jobs
    }

    const { payload } = job.data;
    const { statuses } = payload;

    console.log(`[whatsapp-status-worker] Processing ${statuses.length} status update(s)`);

    // Batch process status updates
    for (const status of statuses) {
      try {
        // Find the message by WhatsApp message ID
        const message = await db.query.whatsappMessages.findFirst({
          where: eq(whatsappMessages.waMessageId, status.waMessageId),
        });

        if (!message) {
          // Message not found - might be from before our tracking started
          // This is normal for existing conversations
          continue;
        }

        // Build update object based on status
        const updateData: Record<string, unknown> = {
          status: status.status,
        };

        // Set timestamp based on status type
        switch (status.status) {
          case 'sent':
            updateData.sentAt = status.timestamp;
            break;
          case 'delivered':
            updateData.deliveredAt = status.timestamp;
            break;
          case 'read':
            updateData.readAt = status.timestamp;
            break;
          case 'failed':
            updateData.errorCode = status.errorCode?.toString();
            // Log failure for debugging
            console.warn(
              `[whatsapp-status-worker] Message ${status.waMessageId} failed:`,
              status.errorCode,
              status.errorMessage
            );
            break;
        }

        // Update the message
        await db
          .update(whatsappMessages)
          .set(updateData)
          .where(eq(whatsappMessages.id, message.id));

        console.log(
          `[whatsapp-status-worker] Updated message ${message.id} to status: ${status.status}`
        );
      } catch (error) {
        console.error(
          `[whatsapp-status-worker] Failed to process status for ${status.waMessageId}:`,
          error
        );
        // Continue processing other statuses
      }
    }
  },
  {
    connection: createRedisConnection(),
    concurrency: 3, // Lower concurrency for status updates (batch friendly)
  }
);

// Error handling
whatsappStatusWorker.on('failed', (job, error) => {
  console.error(`[whatsapp-status-worker] Job ${job?.id} failed:`, error.message);
});

export function startWhatsAppStatusWorker() {
  console.log('[whatsapp-status-worker] Status worker started');
  return whatsappStatusWorker;
}

export async function stopWhatsAppStatusWorker() {
  await whatsappStatusWorker.close();
  console.log('[whatsapp-status-worker] Status worker stopped');
}
```

**Update src/queue/index.ts** to export the worker:
```typescript
export { startWhatsAppStatusWorker, stopWhatsAppStatusWorker } from './workers/whatsapp-status.worker';
```

**Update src/index.ts** to start the worker:
Add to imports (combine with previous):
```typescript
import {
  startWhatsAppMessageWorker,
  stopWhatsAppMessageWorker,
  startWhatsAppStatusWorker,
  stopWhatsAppStatusWorker,
} from './queue/index';
```

Add to worker startup section:
```typescript
// Start WhatsApp status worker
startWhatsAppStatusWorker();
```

Add to graceful shutdown:
```typescript
await stopWhatsAppStatusWorker();
```
  </action>
  <verify>
    - File exists: src/queue/workers/whatsapp-status.worker.ts
    - Worker exports correctly from src/queue/index.ts
    - Server starts with both workers: `pnpm dev` shows both "started" messages
    - TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>
    Status worker processes delivery/read status updates in batches, updating message records with timestamps and handling failures.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Worker startup verification:**
   - `pnpm dev` shows:
     - "[whatsapp-worker] Message worker started"
     - "[whatsapp-status-worker] Status worker started"

2. **Database verification:**
   - Messages table can be written to
   - Conversations table tracks windows

3. **Integration test (manual):**
   - Send a webhook payload to /webhook/whatsapp with valid signature
   - Verify message appears in whatsapp_messages table
   - Verify conversation window created/updated

4. **TypeScript verification:**
   - `pnpm tsc --noEmit` passes
</verification>

<success_criteria>
- Message worker processes whatsapp-messages jobs from webhookQueue
- Incoming messages saved to whatsapp_messages with inbound direction
- Conversation window opened/extended on customer message (24-hour expiry)
- Unsupported message types trigger Hebrew auto-reply
- Status worker processes whatsapp-statuses jobs
- Message status (sent/delivered/read/failed) updated with timestamps
- Failed messages have errorCode recorded
- Both workers auto-start with server
- Graceful shutdown stops both workers properly
</success_criteria>

<output>
After completion, create `.planning/phases/02-whatsapp-integration/02-04-SUMMARY.md`
</output>
