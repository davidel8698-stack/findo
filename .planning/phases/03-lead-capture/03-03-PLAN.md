---
phase: 03-lead-capture
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/queue/workers/lead-outreach.worker.ts
  - src/services/lead-capture/messages.ts
  - src/queue/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "After 2-minute delay, initial WhatsApp message is sent to caller"
    - "Message feels like it comes from the business owner (warm, personal)"
    - "Lead record is created with status 'qualifying'"
    - "Lead conversation record is created with state 'awaiting_response'"
  artifacts:
    - path: "src/queue/workers/lead-outreach.worker.ts"
      provides: "Worker that sends initial lead capture WhatsApp"
      exports: ["startLeadOutreachWorker"]
    - path: "src/services/lead-capture/messages.ts"
      provides: "Hebrew message templates for lead capture"
      exports: ["LEAD_MESSAGES", "formatInitialMessage"]
  key_links:
    - from: "src/queue/workers/lead-outreach.worker.ts"
      to: "src/services/whatsapp/messages.ts"
      via: "sendTextMessage for initial outreach"
      pattern: "sendTextMessage"
    - from: "src/queue/workers/lead-outreach.worker.ts"
      to: "src/db/schema/leads.ts"
      via: "Insert lead and leadConversation records"
      pattern: "db\\.insert.*leads"
---

<objective>
Create lead outreach worker that sends initial WhatsApp message after 2-minute delay.

Purpose: First contact with missed call caller - warm, personal message that opens conversation.
Output: Lead outreach worker, Hebrew message templates, lead record creation.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/03-lead-capture/03-CONTEXT.md
@.planning/phases/03-lead-capture/03-RESEARCH.md
@src/services/whatsapp/messages.ts
@src/services/whatsapp/client.ts
@src/services/whatsapp/conversations.ts
@src/db/schema/leads.ts
@src/db/schema/tenants.ts
@src/queue/queues.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Hebrew message templates</name>
  <files>src/services/lead-capture/messages.ts</files>
  <action>
Create src/services/lead-capture/messages.ts with Hebrew lead capture messages per CONTEXT.md decisions:

```typescript
/**
 * Hebrew message templates for lead capture flow.
 *
 * Per CONTEXT.md:
 * - Tone: Warm and personal - feels like it comes from the owner
 * - Identity: Appears from owner, no mention of automation or assistant
 * - Content: Include business name to remind caller who they called
 */

export const LEAD_MESSAGES = {
  /**
   * Initial message sent to missed call caller (after 2-min delay).
   * Pattern: "Hey, I saw you tried to call [business] and I couldn't answer. How can I help?"
   */
  initial: (businessName: string): string =>
    `היי, ראיתי שניסית להתקשר ל${businessName} ולא הצלחתי לענות. איך אפשר לעזור?`,

  /**
   * Follow-up asking for name (after initial response).
   */
  askName: (): string =>
    `אשמח לעזור! איך קוראים לך?`,

  /**
   * Ask about their need (after getting name).
   * Uses name if available for personalization.
   */
  askNeed: (name?: string): string =>
    name
      ? `שלום ${name}! במה אפשר לעזור לך?`
      : `במה אפשר לעזור לך?`,

  /**
   * Ask for contact preference (when to call back).
   */
  askPreference: (): string =>
    `מתי נוח לך שנחזור אליך?`,

  /**
   * Completion message (all info collected).
   * Promise callback per CONTEXT.md decision.
   */
  complete: (): string =>
    `תודה! אנחנו נחזור אליך בהקדם.`,

  /**
   * First reminder (2 hours after initial message, no response).
   */
  reminder1: (businessName: string): string =>
    `היי, ראיתי שניסית להתקשר ל${businessName}. עדיין צריך עזרה?`,

  /**
   * Second/final reminder (24 hours after initial message).
   */
  reminder2: (): string =>
    `שלום, זו תזכורת אחרונה - אם עדיין צריך עזרה, אשמח לשמוע ממך.`,
};

/**
 * Format the initial message for a specific tenant.
 */
export function formatInitialMessage(businessName: string): string {
  return LEAD_MESSAGES.initial(businessName);
}

/**
 * Get the appropriate chatbot response based on conversation state.
 */
export function getChatbotResponse(
  state: string,
  context: { businessName: string; customerName?: string }
): string | null {
  switch (state) {
    case 'awaiting_name':
      return LEAD_MESSAGES.askName();
    case 'awaiting_need':
      return LEAD_MESSAGES.askNeed(context.customerName);
    case 'awaiting_preference':
      return LEAD_MESSAGES.askPreference();
    case 'completed':
      return LEAD_MESSAGES.complete();
    default:
      return null; // No response for other states
  }
}
```

Create barrel file src/services/lead-capture/index.ts with exports.
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify all message templates are in Hebrew.
Verify formatInitialMessage and getChatbotResponse are exported.
  </verify>
  <done>
Hebrew message templates for entire lead capture flow created. Messages match CONTEXT.md tone (warm, personal, owner voice).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lead outreach worker</name>
  <files>src/queue/workers/lead-outreach.worker.ts, src/queue/index.ts, src/index.ts</files>
  <action>
Create src/queue/workers/lead-outreach.worker.ts:

```typescript
import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { db } from '../../db/index';
import { leads, leadConversations, missedCalls, tenants, whatsappConnections } from '../../db/schema/index';
import { eq, and } from 'drizzle-orm';
import { LeadOutreachJobData, leadReminderQueue } from '../queues';
import { formatInitialMessage } from '../../services/lead-capture/messages';
import { createWhatsAppClient, sendTextMessage } from '../../services/whatsapp';
import { openConversationWindow } from '../../services/whatsapp/conversations';

async function processLeadOutreach(job: Job<LeadOutreachJobData>): Promise<void> {
  const { tenantId, missedCallId, callerPhone } = job.data;

  console.log(`[lead-outreach] Processing outreach for ${callerPhone} (missed call: ${missedCallId})`);

  // Get tenant info for business name
  const tenant = await db.query.tenants.findFirst({
    where: eq(tenants.id, tenantId),
  });

  if (!tenant) {
    console.error(`[lead-outreach] Tenant ${tenantId} not found`);
    return;
  }

  // Check if WhatsApp connection exists and is active
  const connection = await db.query.whatsappConnections.findFirst({
    where: and(
      eq(whatsappConnections.tenantId, tenantId),
      eq(whatsappConnections.status, 'active')
    ),
  });

  if (!connection) {
    console.error(`[lead-outreach] No active WhatsApp connection for tenant ${tenantId}`);
    return;
  }

  // Check if a lead already exists for this phone (maybe they called multiple times)
  const existingLead = await db.query.leads.findFirst({
    where: and(
      eq(leads.tenantId, tenantId),
      eq(leads.customerPhone, callerPhone)
    ),
  });

  if (existingLead) {
    console.log(`[lead-outreach] Lead already exists for ${callerPhone}, skipping initial message`);
    // Update missed call to link to existing lead
    await db.update(missedCalls)
      .set({ leadId: existingLead.id, processedAt: new Date() })
      .where(eq(missedCalls.id, missedCallId));
    return;
  }

  // Create WhatsApp client
  const client = await createWhatsAppClient(tenantId);
  if (!client) {
    console.error(`[lead-outreach] Failed to create WhatsApp client for tenant ${tenantId}`);
    return;
  }

  // Format initial message with business name
  const businessName = tenant.businessName || tenant.name || 'העסק';
  const message = formatInitialMessage(businessName);

  // Send initial WhatsApp message
  try {
    const result = await sendTextMessage(client, callerPhone, message);
    console.log(`[lead-outreach] Sent initial message to ${callerPhone}: ${result.messages?.[0]?.id || 'success'}`);
  } catch (error) {
    console.error(`[lead-outreach] Failed to send message to ${callerPhone}:`, error);
    throw error; // Retry via BullMQ
  }

  // Create lead record
  const [lead] = await db.insert(leads).values({
    tenantId,
    source: 'missed_call',
    sourceId: missedCallId,
    customerPhone: callerPhone,
    status: 'qualifying',
    capturedAt: new Date(),
  }).returning();

  console.log(`[lead-outreach] Created lead ${lead.id} for ${callerPhone}`);

  // Open WhatsApp conversation window (for tracking 24-hour window)
  const conversation = await openConversationWindow(tenantId, callerPhone);

  // Create lead conversation tracking record
  const [leadConversation] = await db.insert(leadConversations).values({
    leadId: lead.id,
    state: 'awaiting_response',
    whatsappConversationId: conversation?.id,
  }).returning();

  console.log(`[lead-outreach] Created lead conversation ${leadConversation.id}`);

  // Update missed call with lead reference
  await db.update(missedCalls)
    .set({ leadId: lead.id, processedAt: new Date() })
    .where(eq(missedCalls.id, missedCallId));

  // Schedule reminder 1 (2 hours from now)
  await leadReminderQueue.add(
    'send-reminder',
    {
      leadId: lead.id,
      leadConversationId: leadConversation.id,
      reminderNumber: 1,
    },
    {
      delay: 2 * 60 * 60 * 1000, // 2 hours
      jobId: `lead-reminder-1-${lead.id}`,
    }
  );

  // Schedule reminder 2 (24 hours from now)
  await leadReminderQueue.add(
    'send-reminder',
    {
      leadId: lead.id,
      leadConversationId: leadConversation.id,
      reminderNumber: 2,
    },
    {
      delay: 24 * 60 * 60 * 1000, // 24 hours
      jobId: `lead-reminder-2-${lead.id}`,
    }
  );

  console.log(`[lead-outreach] Scheduled reminders for lead ${lead.id}`);
}

export function startLeadOutreachWorker(): Worker<LeadOutreachJobData> {
  const worker = new Worker<LeadOutreachJobData>(
    'lead-outreach',
    async (job) => {
      await processLeadOutreach(job);
    },
    {
      connection: createRedisConnection(),
      concurrency: 5,
    }
  );

  worker.on('completed', (job) => {
    console.log(`[lead-outreach] Job ${job.id} completed`);
  });

  worker.on('failed', (job, err) => {
    console.error(`[lead-outreach] Job ${job?.id} failed:`, err.message);
  });

  console.log('[lead-outreach] Worker started');
  return worker;
}
```

Update src/queue/index.ts to export startLeadOutreachWorker.

Update src/index.ts to start the worker in the worker startup section (alongside other workers).
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify startLeadOutreachWorker is exported from src/queue/index.ts.
Verify worker is started in src/index.ts.
  </verify>
  <done>
Lead outreach worker creates lead, sends initial WhatsApp, creates conversation tracker, schedules reminders. Handles existing leads gracefully.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm tsc --noEmit` passes with no errors
2. src/services/lead-capture/messages.ts exports Hebrew message templates
3. src/queue/workers/lead-outreach.worker.ts exists and is exported
4. Worker is started in src/index.ts
5. Initial message includes business name in warm, personal tone
</verification>

<success_criteria>
- Lead outreach worker sends warm Hebrew message to caller
- Lead record created with status 'qualifying'
- Lead conversation record created with state 'awaiting_response'
- Reminders scheduled for 2h and 24h
- Existing leads not duplicated (idempotent)
</success_criteria>

<output>
After completion, create `.planning/phases/03-lead-capture/03-03-SUMMARY.md`
</output>
