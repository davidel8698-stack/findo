---
phase: 03-lead-capture
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/services/lead-capture/chatbot.ts
  - src/services/lead-capture/intent.ts
  - src/services/lead-capture/index.ts
autonomous: true

user_setup:
  - service: anthropic
    why: "AI intent extraction from Hebrew messages"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Anthropic Console -> API Keys -> Create Key"

must_haves:
  truths:
    - "Conversation state can transition based on events"
    - "AI extracts name, need, and contact preference from Hebrew messages"
    - "State machine handles linear chatbot flow without external library"
    - "Multiple fields can be extracted from single message"
  artifacts:
    - path: "src/services/lead-capture/chatbot.ts"
      provides: "Conversation state machine"
      exports: ["ConversationState", "transition", "getNextState"]
    - path: "src/services/lead-capture/intent.ts"
      provides: "AI intent extraction"
      exports: ["extractLeadInfo", "LeadInfo"]
  key_links:
    - from: "src/services/lead-capture/intent.ts"
      to: "@anthropic-ai/sdk"
      via: "Claude API for intent extraction"
      pattern: "anthropic.*messages\\.create"
---

<objective>
Create chatbot state machine and AI intent extraction for lead qualification.

Purpose: Track conversation state and extract customer info (name, need, preference) using AI.
Output: State machine, AI intent extraction with Claude Haiku 4.5, lead info schema.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/03-lead-capture/03-CONTEXT.md
@.planning/phases/03-lead-capture/03-RESEARCH.md
@src/db/schema/leads.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Anthropic SDK</name>
  <files>package.json</files>
  <action>
Install the Anthropic SDK:

```bash
pnpm add @anthropic-ai/sdk
```

This adds the official Anthropic TypeScript SDK for Claude API access.
Per RESEARCH.md: Use Claude Haiku 4.5 with structured outputs for cost-effective Hebrew intent extraction.
  </action>
  <verify>
Run `pnpm list @anthropic-ai/sdk` - package is installed.
Check package.json contains "@anthropic-ai/sdk" in dependencies.
  </verify>
  <done>
@anthropic-ai/sdk installed and available for import.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conversation state machine</name>
  <files>src/services/lead-capture/chatbot.ts</files>
  <action>
Create src/services/lead-capture/chatbot.ts with simple object-based state machine per RESEARCH.md:

```typescript
/**
 * Conversation state machine for lead qualification chatbot.
 *
 * Flow: awaiting_response -> awaiting_name -> awaiting_need -> awaiting_preference -> completed
 * Can jump states if AI extracts multiple fields from one message.
 *
 * Per CONTEXT.md: AI interprets unclear messages, doesn't ask for clarification.
 */

// Conversation states
export type ConversationState =
  | 'awaiting_response'      // Initial message sent, waiting for any reply
  | 'awaiting_name'          // Asked for name
  | 'awaiting_need'          // Asked about their need
  | 'awaiting_preference'    // Asked for contact preference
  | 'completed'              // All info collected
  | 'unresponsive';          // No response after reminders

// Events that trigger state transitions
export type ConversationEvent =
  | 'MESSAGE_RECEIVED'       // Customer sent a message
  | 'NAME_EXTRACTED'         // AI extracted customer name
  | 'NEED_EXTRACTED'         // AI extracted customer need
  | 'PREFERENCE_EXTRACTED'   // AI extracted contact preference
  | 'REMINDER_1_SENT'        // First reminder sent
  | 'REMINDER_2_SENT'        // Second reminder sent
  | 'TIMEOUT';               // No response after all reminders

// Lead info structure
export interface ExtractedLeadInfo {
  name: string | null;
  need: string | null;
  contactPreference: string | null;
}

/**
 * Determine the next state based on what info is still missing.
 *
 * This is smarter than simple event-based transitions:
 * - If we extracted name+need in one message, skip to awaiting_preference
 * - If all info collected, go to completed
 */
export function getNextState(
  currentState: ConversationState,
  currentLead: ExtractedLeadInfo
): ConversationState {
  // Terminal states
  if (currentState === 'completed' || currentState === 'unresponsive') {
    return currentState;
  }

  // If all info collected, mark completed
  if (currentLead.name && currentLead.need && currentLead.contactPreference) {
    return 'completed';
  }

  // Determine what we need next based on what's missing
  if (!currentLead.name && currentState !== 'awaiting_response') {
    return 'awaiting_name';
  }

  if (!currentLead.need) {
    return 'awaiting_need';
  }

  if (!currentLead.contactPreference) {
    return 'awaiting_preference';
  }

  // Shouldn't reach here, but return completed as fallback
  return 'completed';
}

/**
 * Simple event-based transition for specific events (reminders, timeout).
 */
export function transition(
  currentState: ConversationState,
  event: ConversationEvent
): ConversationState {
  // Timeout after reminders
  if (event === 'TIMEOUT') {
    return 'unresponsive';
  }

  // Reminders don't change state
  if (event === 'REMINDER_1_SENT' || event === 'REMINDER_2_SENT') {
    return currentState;
  }

  // For MESSAGE_RECEIVED, caller should use getNextState instead
  // This is a fallback that maintains current state
  if (event === 'MESSAGE_RECEIVED') {
    return currentState;
  }

  return currentState;
}

/**
 * Check if conversation is in a terminal state.
 */
export function isTerminalState(state: ConversationState): boolean {
  return state === 'completed' || state === 'unresponsive';
}

/**
 * Check if conversation should receive chatbot response.
 */
export function shouldSendResponse(state: ConversationState): boolean {
  // Don't respond in awaiting_response (waiting for first reply)
  // Don't respond in terminal states
  return !['awaiting_response', 'completed', 'unresponsive'].includes(state);
}
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify ConversationState, getNextState, transition, isTerminalState, shouldSendResponse are exported.
  </verify>
  <done>
State machine with smart state determination based on collected info. Handles linear flow and jumping states when multiple fields extracted.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AI intent extraction</name>
  <files>src/services/lead-capture/intent.ts, src/services/lead-capture/index.ts</files>
  <action>
Create src/services/lead-capture/intent.ts with Claude Haiku 4.5 structured outputs:

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { ConversationState } from './chatbot';

// Initialize Anthropic client (uses ANTHROPIC_API_KEY env var automatically)
const anthropic = new Anthropic();

/**
 * Extracted lead information from customer message.
 */
export interface LeadInfo {
  name: string | null;
  need: string | null;
  contactPreference: string | null;
  confidence: 'high' | 'medium' | 'low';
}

/**
 * Extract lead information from Hebrew WhatsApp message using Claude AI.
 *
 * Per CONTEXT.md: AI interprets intent from unclear messages, doesn't ask for clarification.
 *
 * @param message - The customer's message text
 * @param conversationHistory - Previous messages in the conversation
 * @param currentState - Current conversation state
 * @returns Extracted lead info with confidence level
 */
export async function extractLeadInfo(
  message: string,
  conversationHistory: string[],
  currentState: ConversationState
): Promise<LeadInfo> {
  const systemPrompt = `You are extracting lead information from Hebrew WhatsApp messages.
The conversation is with a potential customer who called a business and didn't get through.

Current conversation state: ${currentState}
Previous messages in conversation:
${conversationHistory.map((m, i) => `${i + 1}. ${m}`).join('\n') || '(no previous messages)'}

Extract the following from the customer's CURRENT message:
- name: Their name if they mentioned it (Hebrew or transliterated)
- need: What they need/want (their reason for calling, in Hebrew)
- contactPreference: When/how they want to be called back (morning, evening, ASAP, specific time, etc.)

Guidelines:
- Be generous in extraction - if they say "אני דני" or "ani dani", extract "דני" as name
- If they describe a problem or ask a question, that's their need
- If they mention timing like "מחר", "אחר הצהריים", "בערב", that's a contact preference
- Return null for fields that cannot be determined from THIS message
- Even partial info is useful - extract what you can

Return a JSON object with exactly these fields:
{
  "name": string | null,
  "need": string | null,
  "contactPreference": string | null,
  "confidence": "high" | "medium" | "low"
}

Set confidence to:
- "high" if extracted fields are clearly stated
- "medium" if inference was needed
- "low" if very uncertain about extraction`;

  try {
    const response = await anthropic.messages.create({
      model: 'claude-haiku-4-5-20250929',
      max_tokens: 256,
      system: systemPrompt,
      messages: [
        {
          role: 'user',
          content: `Customer message to analyze:\n"${message}"\n\nExtract lead info as JSON.`
        }
      ],
    });

    // Parse the response
    const content = response.content[0];
    if (content.type !== 'text') {
      console.warn('[intent] Unexpected response type:', content.type);
      return { name: null, need: null, contactPreference: null, confidence: 'low' };
    }

    // Extract JSON from response (may be wrapped in markdown code block)
    let jsonStr = content.text;
    const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (jsonMatch) {
      jsonStr = jsonMatch[1];
    }

    const result = JSON.parse(jsonStr.trim());

    return {
      name: result.name || null,
      need: result.need || null,
      contactPreference: result.contactPreference || null,
      confidence: result.confidence || 'medium',
    };
  } catch (error) {
    console.error('[intent] Failed to extract lead info:', error);
    return { name: null, need: null, contactPreference: null, confidence: 'low' };
  }
}

/**
 * Merge newly extracted info with existing lead info.
 * Only updates fields that are currently null in the existing info.
 */
export function mergeLeadInfo(
  existing: LeadInfo,
  extracted: LeadInfo
): LeadInfo {
  return {
    name: existing.name || extracted.name,
    need: existing.need || extracted.need,
    contactPreference: existing.contactPreference || extracted.contactPreference,
    confidence: extracted.confidence, // Use latest confidence
  };
}
```

Update src/services/lead-capture/index.ts to export all lead-capture services:

```typescript
export * from './messages';
export * from './chatbot';
export * from './intent';
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify extractLeadInfo, LeadInfo, mergeLeadInfo exported from src/services/lead-capture.
  </verify>
  <done>
AI intent extraction using Claude Haiku 4.5 for Hebrew messages. Handles transliterated names, implicit needs, and contact preferences.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm tsc --noEmit` passes with no errors
2. @anthropic-ai/sdk is in package.json dependencies
3. State machine exports ConversationState and transition functions
4. Intent extraction exports extractLeadInfo and LeadInfo
5. Barrel file exports all lead-capture services
</verification>

<success_criteria>
- State machine transitions correctly based on collected info
- AI extraction handles Hebrew and transliterated inputs
- Multiple fields can be extracted from single message
- Confidence level indicates extraction quality
- All exports available from src/services/lead-capture
</success_criteria>

<output>
After completion, create `.planning/phases/03-lead-capture/03-04-SUMMARY.md`
</output>
