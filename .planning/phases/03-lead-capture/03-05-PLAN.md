---
phase: 03-lead-capture
plan: 05
type: execute
wave: 3
depends_on: ["03-02", "03-03", "03-04"]
files_modified:
  - src/queue/workers/whatsapp-message.worker.ts
  - src/services/lead-capture/notifications.ts
  - src/services/lead-capture/index.ts
autonomous: true

must_haves:
  truths:
    - "Incoming messages from lead conversations are processed by chatbot"
    - "AI extracts info and updates lead record"
    - "Chatbot sends appropriate follow-up questions"
    - "Owner receives WhatsApp notification when lead info is collected"
    - "Owner notification includes structured summary with emoji headers"
  artifacts:
    - path: "src/queue/workers/whatsapp-message.worker.ts"
      provides: "Extended worker with lead conversation detection"
      contains: "handleLeadConversation"
    - path: "src/services/lead-capture/notifications.ts"
      provides: "Owner notification formatting and sending"
      exports: ["notifyOwnerOfLead", "formatLeadSummary"]
  key_links:
    - from: "src/queue/workers/whatsapp-message.worker.ts"
      to: "src/services/lead-capture/intent.ts"
      via: "extractLeadInfo for AI processing"
      pattern: "extractLeadInfo"
    - from: "src/queue/workers/whatsapp-message.worker.ts"
      to: "src/services/lead-capture/chatbot.ts"
      via: "getNextState for state transitions"
      pattern: "getNextState"
    - from: "src/services/lead-capture/notifications.ts"
      to: "src/services/whatsapp/messages.ts"
      via: "sendTextMessage to owner"
      pattern: "sendTextMessage"
---

<objective>
Extend WhatsApp message worker to handle lead conversations and notify business owner.

Purpose: Complete the lead qualification flow - chatbot collects info, owner gets notified.
Output: Extended message worker, owner notification service with Hebrew structured summaries.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/03-lead-capture/03-CONTEXT.md
@.planning/phases/03-lead-capture/03-RESEARCH.md
@src/queue/workers/whatsapp-message.worker.ts
@src/services/lead-capture/chatbot.ts
@src/services/lead-capture/intent.ts
@src/services/lead-capture/messages.ts
@src/services/whatsapp/messages.ts
@src/db/schema/leads.ts
@src/db/schema/tenants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create owner notification service</name>
  <files>src/services/lead-capture/notifications.ts</files>
  <action>
Create src/services/lead-capture/notifications.ts for owner WhatsApp notifications per CONTEXT.md:

```typescript
import { db } from '../../db/index';
import { leads, tenants, whatsappConnections } from '../../db/schema/index';
import { eq } from 'drizzle-orm';
import { createWhatsAppClient, sendTextMessage } from '../whatsapp';
import { formatPhoneDisplay } from '../../lib/phone';

/**
 * Lead summary for owner notification.
 */
export interface LeadSummary {
  id: string;
  customerPhone: string;
  customerName: string | null;
  need: string | null;
  contactPreference: string | null;
  isComplete: boolean;
}

/**
 * Format lead summary for WhatsApp notification to owner.
 *
 * Per CONTEXT.md:
 * - Structured summary with emoji headers
 * - Complete leads: "◊ú◊ô◊ì ◊ó◊ì◊©"
 * - Incomplete leads: "◊ú◊ô◊ì ◊ó◊ì◊© (◊ó◊ú◊ß◊ô)"
 * - Tap to call/message - clickable phone number
 */
export function formatLeadSummary(lead: LeadSummary): string {
  const lines: string[] = [];

  // Header with emoji (per CONTEXT.md format)
  if (lead.isComplete) {
    lines.push('üìû ◊ú◊ô◊ì ◊ó◊ì◊©');
  } else {
    lines.push('üìû ◊ú◊ô◊ì ◊ó◊ì◊© (◊ó◊ú◊ß◊ô)');
  }

  lines.push(''); // Empty line after header

  // Customer name
  if (lead.customerName) {
    lines.push(`◊©◊ù: ${lead.customerName}`);
  }

  // Need
  if (lead.need) {
    lines.push(`◊¶◊ï◊®◊ö: ${lead.need}`);
  }

  // Contact preference
  if (lead.contactPreference) {
    lines.push(`◊î◊¢◊ì◊§◊î: ${lead.contactPreference}`);
  }

  // Phone number (formatted for tap-to-call)
  lines.push(`üì± ${formatPhoneDisplay(lead.customerPhone)}`);

  return lines.join('\n');
}

/**
 * Get tenant's owner phone number.
 * For now, uses the WhatsApp connection's display phone as owner number.
 * TODO: Add owner_phone field to tenants table for proper separation.
 */
async function getOwnerPhone(tenantId: string): Promise<string | null> {
  // Get tenant info
  const tenant = await db.query.tenants.findFirst({
    where: eq(tenants.id, tenantId),
  });

  if (!tenant) {
    return null;
  }

  // For MVP, owner phone should be stored in tenant record
  // Fallback: use any configured contact method
  // This is a placeholder - in production, tenants table should have owner_phone column
  return tenant.contactEmail ? null : null; // No fallback for now

  // NOTE: In actual implementation, owner phone should come from:
  // 1. tenant.ownerPhone column (to be added)
  // 2. Or a separate owner_contacts table
}

/**
 * Notify business owner of new/updated lead via WhatsApp.
 *
 * Per CONTEXT.md:
 * - Real-time updates: notify on first message, update as info comes in
 * - Incomplete leads: Yes, notify with "◊ú◊ô◊ì ◊ó◊ì◊© (◊ó◊ú◊ß◊ô)"
 */
export async function notifyOwnerOfLead(leadId: string): Promise<void> {
  // Get lead with tenant info
  const lead = await db.query.leads.findFirst({
    where: eq(leads.id, leadId),
  });

  if (!lead) {
    console.warn(`[notifications] Lead ${leadId} not found`);
    return;
  }

  // Get tenant for owner phone and business context
  const tenant = await db.query.tenants.findFirst({
    where: eq(tenants.id, lead.tenantId),
  });

  if (!tenant) {
    console.warn(`[notifications] Tenant ${lead.tenantId} not found`);
    return;
  }

  // For MVP, we need owner phone to be configured
  // This will be addressed when we add owner_phone to tenants schema
  // For now, log a warning and skip notification
  const ownerPhone = (tenant as any).ownerPhone; // Will be null until schema updated

  if (!ownerPhone) {
    console.log(`[notifications] No owner phone configured for tenant ${lead.tenantId}, skipping notification`);
    return;
  }

  // Create WhatsApp client
  const client = await createWhatsAppClient(lead.tenantId);
  if (!client) {
    console.warn(`[notifications] No WhatsApp client for tenant ${lead.tenantId}`);
    return;
  }

  // Format lead summary
  const isComplete = !!(lead.customerName && lead.need && lead.contactPreference);
  const summary = formatLeadSummary({
    id: lead.id,
    customerPhone: lead.customerPhone,
    customerName: lead.customerName,
    need: lead.need,
    contactPreference: lead.contactPreference,
    isComplete,
  });

  // Send notification to owner
  try {
    await sendTextMessage(client, ownerPhone, summary);
    console.log(`[notifications] Sent lead notification to owner for lead ${leadId}`);
  } catch (error) {
    console.error(`[notifications] Failed to notify owner of lead ${leadId}:`, error);
    // Don't throw - notification failure shouldn't break lead flow
  }
}

/**
 * Create activity event for lead update.
 */
export async function createLeadActivity(
  tenantId: string,
  leadId: string,
  eventType: 'lead.created' | 'lead.updated' | 'lead.qualified' | 'lead.unresponsive',
  title: string,
  description?: string
): Promise<void> {
  const { activityQueue } = await import('../../queue/queues');

  await activityQueue.add('create-activity', {
    tenantId,
    eventType,
    title,
    description,
    metadata: { leadId },
    source: 'lead-capture',
    sourceId: leadId,
  });
}
```

Update src/services/lead-capture/index.ts to include notifications exports.
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify formatLeadSummary, notifyOwnerOfLead exported from lead-capture.
  </verify>
  <done>
Owner notification service with Hebrew structured summary format. Includes emoji headers, tap-to-call phone format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend WhatsApp message worker for lead conversations</name>
  <files>src/queue/workers/whatsapp-message.worker.ts</files>
  <action>
Extend src/queue/workers/whatsapp-message.worker.ts to detect and handle lead conversations:

Add these imports at the top:
```typescript
import { leads, leadConversations } from '../../db/schema/index';
import { extractLeadInfo, mergeLeadInfo, LeadInfo } from '../../services/lead-capture/intent';
import { getNextState, isTerminalState, ExtractedLeadInfo } from '../../services/lead-capture/chatbot';
import { getChatbotResponse } from '../../services/lead-capture/messages';
import { notifyOwnerOfLead, createLeadActivity } from '../../services/lead-capture/notifications';
import { leadReminderQueue } from '../queues';
```

Add new function to handle lead conversation messages:

```typescript
/**
 * Handle incoming message that's part of a lead conversation.
 */
async function handleLeadConversation(
  message: { text?: string; from: string },
  leadConvo: typeof leadConversations.$inferSelect,
  lead: typeof leads.$inferSelect,
  tenantId: string,
  wabaId: string
): Promise<void> {
  console.log(`[whatsapp-message] Processing lead conversation for ${message.from}`);

  // Skip if conversation is in terminal state
  if (isTerminalState(leadConvo.state as any)) {
    console.log(`[whatsapp-message] Lead conversation ${leadConvo.id} is in terminal state ${leadConvo.state}`);
    return;
  }

  // Extract info using AI
  const messageText = message.text || '';
  const existingInfo: ExtractedLeadInfo = {
    name: lead.customerName,
    need: lead.need,
    contactPreference: lead.contactPreference,
  };

  const extractedInfo = await extractLeadInfo(
    messageText,
    [], // TODO: Add conversation history tracking
    leadConvo.state as any
  );

  console.log(`[whatsapp-message] Extracted info:`, extractedInfo);

  // Merge with existing info
  const mergedInfo: ExtractedLeadInfo = {
    name: existingInfo.name || extractedInfo.name,
    need: existingInfo.need || extractedInfo.need,
    contactPreference: existingInfo.contactPreference || extractedInfo.contactPreference,
  };

  // Update lead with new info
  const updates: Partial<typeof leads.$inferInsert> = {
    updatedAt: new Date(),
  };

  if (extractedInfo.name && !lead.customerName) {
    updates.customerName = extractedInfo.name;
  }
  if (extractedInfo.need && !lead.need) {
    updates.need = extractedInfo.need;
  }
  if (extractedInfo.contactPreference && !lead.contactPreference) {
    updates.contactPreference = extractedInfo.contactPreference;
  }

  if (Object.keys(updates).length > 1) { // More than just updatedAt
    await db.update(leads)
      .set(updates)
      .where(eq(leads.id, lead.id));
    console.log(`[whatsapp-message] Updated lead ${lead.id} with new info`);
  }

  // Determine next state based on what's now collected
  const nextState = getNextState(leadConvo.state as any, mergedInfo);

  // Update conversation state
  if (nextState !== leadConvo.state) {
    await db.update(leadConversations)
      .set({ state: nextState, updatedAt: new Date() })
      .where(eq(leadConversations.id, leadConvo.id));
    console.log(`[whatsapp-message] Lead conversation ${leadConvo.id} transitioned to ${nextState}`);
  }

  // Cancel pending reminders if customer responded
  try {
    await leadReminderQueue.remove(`lead-reminder-1-${lead.id}`);
    await leadReminderQueue.remove(`lead-reminder-2-${lead.id}`);
    console.log(`[whatsapp-message] Cancelled pending reminders for lead ${lead.id}`);
  } catch {
    // Reminders may not exist or already processed
  }

  // Get tenant for business name
  const tenant = await db.query.tenants.findFirst({
    where: eq(tenants.id, tenantId),
  });

  // Send chatbot response if appropriate
  const responseText = getChatbotResponse(nextState, {
    businessName: tenant?.businessName || tenant?.name || '◊î◊¢◊°◊ß',
    customerName: mergedInfo.name || undefined,
  });

  if (responseText) {
    const client = await createWhatsAppClient(tenantId);
    if (client) {
      try {
        await sendTextMessage(client, lead.customerPhone, responseText);
        console.log(`[whatsapp-message] Sent chatbot response for state ${nextState}`);
      } catch (error) {
        console.error(`[whatsapp-message] Failed to send chatbot response:`, error);
      }
    }
  }

  // Update lead status if completed
  if (nextState === 'completed') {
    await db.update(leads)
      .set({ status: 'qualified', qualifiedAt: new Date(), updatedAt: new Date() })
      .where(eq(leads.id, lead.id));

    await createLeadActivity(
      tenantId,
      lead.id,
      'lead.qualified',
      '◊ú◊ô◊ì ◊û◊ï◊õ◊ü',
      `${mergedInfo.name || '◊ú◊ß◊ï◊ó'} - ${mergedInfo.need || '◊ú◊ê ◊¶◊ï◊ô◊ü'}`
    );
  }

  // Notify owner of new/updated lead info
  // Per CONTEXT.md: notify immediately, update as info comes in
  if (Object.keys(updates).length > 1 || nextState === 'completed') {
    await notifyOwnerOfLead(lead.id);
  }
}
```

Modify the main message processing function to check for lead conversations:

In the existing `processWhatsAppMessage` function, add lead conversation detection BEFORE the standard message processing:

```typescript
// Check if this is part of a lead conversation
const leadConvo = await db.query.leadConversations.findFirst({
  where: eq(leadConversations.whatsappConversationId, conversation.id),
});

if (leadConvo) {
  // Get the associated lead
  const lead = await db.query.leads.findFirst({
    where: eq(leads.id, leadConvo.leadId),
  });

  if (lead) {
    await handleLeadConversation(
      { text: messageData.text?.body, from: messageData.from },
      leadConvo,
      lead,
      tenantId,
      wabaId
    );
  }
}
```

Ensure all necessary imports are added.
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify handleLeadConversation function exists in whatsapp-message.worker.ts.
  </verify>
  <done>
WhatsApp message worker detects lead conversations, extracts info via AI, updates state, sends chatbot responses, and notifies owner.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm tsc --noEmit` passes with no errors
2. notifyOwnerOfLead and formatLeadSummary exported from lead-capture
3. handleLeadConversation exists in whatsapp-message.worker.ts
4. Lead conversations are detected and processed
5. Owner receives Hebrew notification with structured format
</verification>

<success_criteria>
- Incoming messages from leads are detected via conversation ID
- AI extracts customer info and updates lead record
- Chatbot sends appropriate follow-up questions based on state
- State transitions correctly when info is collected
- Owner receives notification with emoji-formatted summary
- Pending reminders cancelled when customer responds
</success_criteria>

<output>
After completion, create `.planning/phases/03-lead-capture/03-05-SUMMARY.md`
</output>
