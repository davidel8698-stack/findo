---
phase: 03-lead-capture
plan: 06
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - src/queue/workers/lead-reminder.worker.ts
  - src/queue/index.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "First reminder sent 2 hours after initial message if no response"
    - "Second reminder sent 24 hours after initial message if no response"
    - "Lead marked as unresponsive after second reminder times out"
    - "Reminders cancelled when customer responds"
    - "Maximum 2 reminders sent per lead (no spam)"
  artifacts:
    - path: "src/queue/workers/lead-reminder.worker.ts"
      provides: "Worker for sending lead reminders"
      exports: ["startLeadReminderWorker"]
  key_links:
    - from: "src/queue/workers/lead-reminder.worker.ts"
      to: "src/services/lead-capture/messages.ts"
      via: "LEAD_MESSAGES.reminder1 and reminder2"
      pattern: "LEAD_MESSAGES\\.reminder"
    - from: "src/queue/workers/lead-reminder.worker.ts"
      to: "src/db/schema/leads.ts"
      via: "Update lead conversation state"
      pattern: "leadConversations.*update"
---

<objective>
Create lead reminder worker for follow-up messages when customers don't respond.

Purpose: Re-engage unresponsive leads per CONTEXT.md: two reminders over 24 hours, then mark unresponsive.
Output: Reminder worker with proper state checking and timeout handling.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/03-lead-capture/03-CONTEXT.md
@.planning/phases/03-lead-capture/03-RESEARCH.md
@src/services/lead-capture/messages.ts
@src/services/lead-capture/chatbot.ts
@src/queue/queues.ts
@src/db/schema/leads.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lead reminder worker</name>
  <files>src/queue/workers/lead-reminder.worker.ts</files>
  <action>
Create src/queue/workers/lead-reminder.worker.ts:

```typescript
import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { db } from '../../db/index';
import { leads, leadConversations, tenants } from '../../db/schema/index';
import { eq } from 'drizzle-orm';
import { LeadReminderJobData } from '../queues';
import { LEAD_MESSAGES } from '../../services/lead-capture/messages';
import { isTerminalState, transition } from '../../services/lead-capture/chatbot';
import { createWhatsAppClient, sendTextMessage } from '../../services/whatsapp';
import { createLeadActivity } from '../../services/lead-capture/notifications';

/**
 * Process lead reminder job.
 *
 * Per CONTEXT.md:
 * - Two reminders over 24 hours (at 2h and 24h)
 * - After second reminder, wait and mark as unresponsive
 * - Reminders cancelled when customer responds (done in message worker)
 */
async function processLeadReminder(job: Job<LeadReminderJobData>): Promise<void> {
  const { leadId, leadConversationId, reminderNumber } = job.data;

  console.log(`[lead-reminder] Processing reminder ${reminderNumber} for lead ${leadId}`);

  // Get lead conversation
  const leadConvo = await db.query.leadConversations.findFirst({
    where: eq(leadConversations.id, leadConversationId),
  });

  if (!leadConvo) {
    console.log(`[lead-reminder] Lead conversation ${leadConversationId} not found, skipping`);
    return;
  }

  // Skip if already in terminal state (customer responded or already unresponsive)
  if (isTerminalState(leadConvo.state as any)) {
    console.log(`[lead-reminder] Lead ${leadId} is in terminal state ${leadConvo.state}, skipping reminder`);
    return;
  }

  // Skip if reminder already sent (idempotency)
  if (reminderNumber === 1 && leadConvo.reminder1SentAt) {
    console.log(`[lead-reminder] Reminder 1 already sent for lead ${leadId}, skipping`);
    return;
  }
  if (reminderNumber === 2 && leadConvo.reminder2SentAt) {
    console.log(`[lead-reminder] Reminder 2 already sent for lead ${leadId}, skipping`);
    return;
  }

  // Get lead and tenant info
  const lead = await db.query.leads.findFirst({
    where: eq(leads.id, leadId),
  });

  if (!lead) {
    console.log(`[lead-reminder] Lead ${leadId} not found, skipping`);
    return;
  }

  const tenant = await db.query.tenants.findFirst({
    where: eq(tenants.id, lead.tenantId),
  });

  if (!tenant) {
    console.log(`[lead-reminder] Tenant ${lead.tenantId} not found, skipping`);
    return;
  }

  // Create WhatsApp client
  const client = await createWhatsAppClient(lead.tenantId);
  if (!client) {
    console.error(`[lead-reminder] No WhatsApp client for tenant ${lead.tenantId}`);
    return;
  }

  // Get reminder message
  const businessName = tenant.businessName || tenant.name || 'העסק';
  const message = reminderNumber === 1
    ? LEAD_MESSAGES.reminder1(businessName)
    : LEAD_MESSAGES.reminder2();

  // Send reminder
  try {
    await sendTextMessage(client, lead.customerPhone, message);
    console.log(`[lead-reminder] Sent reminder ${reminderNumber} to ${lead.customerPhone}`);
  } catch (error) {
    console.error(`[lead-reminder] Failed to send reminder ${reminderNumber}:`, error);
    throw error; // Retry via BullMQ
  }

  // Update reminder sent timestamp
  const reminderUpdate = reminderNumber === 1
    ? { reminder1SentAt: new Date(), updatedAt: new Date() }
    : { reminder2SentAt: new Date(), updatedAt: new Date() };

  await db.update(leadConversations)
    .set(reminderUpdate)
    .where(eq(leadConversations.id, leadConversationId));

  // Update conversation state with reminder event
  const newState = transition(
    leadConvo.state as any,
    reminderNumber === 1 ? 'REMINDER_1_SENT' : 'REMINDER_2_SENT'
  );

  console.log(`[lead-reminder] Updated lead conversation ${leadConversationId}, state: ${newState}`);

  // If this was the second reminder, schedule timeout to mark unresponsive
  if (reminderNumber === 2) {
    // Schedule timeout check for 24 hours after reminder 2
    // The timeout worker will mark as unresponsive if no response
    const { leadReminderQueue } = await import('../queues');

    await leadReminderQueue.add(
      'mark-unresponsive',
      {
        leadId,
        leadConversationId,
        reminderNumber: 2, // Use 2 to indicate this is the timeout job
      },
      {
        delay: 24 * 60 * 60 * 1000, // 24 hours after reminder 2
        jobId: `lead-timeout-${leadId}`,
      }
    );

    console.log(`[lead-reminder] Scheduled unresponsive timeout for lead ${leadId}`);
  }
}

/**
 * Mark lead as unresponsive after final timeout.
 */
async function markLeadUnresponsive(job: Job<LeadReminderJobData>): Promise<void> {
  const { leadId, leadConversationId } = job.data;

  console.log(`[lead-reminder] Checking if lead ${leadId} should be marked unresponsive`);

  // Get lead conversation
  const leadConvo = await db.query.leadConversations.findFirst({
    where: eq(leadConversations.id, leadConversationId),
  });

  if (!leadConvo) {
    console.log(`[lead-reminder] Lead conversation ${leadConversationId} not found`);
    return;
  }

  // Only mark unresponsive if still not in terminal state
  if (isTerminalState(leadConvo.state as any)) {
    console.log(`[lead-reminder] Lead ${leadId} already in terminal state ${leadConvo.state}`);
    return;
  }

  // Verify both reminders were sent
  if (!leadConvo.reminder1SentAt || !leadConvo.reminder2SentAt) {
    console.log(`[lead-reminder] Not all reminders sent for lead ${leadId}, skipping unresponsive mark`);
    return;
  }

  // Get lead for tenant ID
  const lead = await db.query.leads.findFirst({
    where: eq(leads.id, leadId),
  });

  if (!lead) {
    console.log(`[lead-reminder] Lead ${leadId} not found`);
    return;
  }

  // Mark conversation as unresponsive
  await db.update(leadConversations)
    .set({ state: 'unresponsive', updatedAt: new Date() })
    .where(eq(leadConversations.id, leadConversationId));

  // Update lead status
  await db.update(leads)
    .set({ status: 'unresponsive', updatedAt: new Date() })
    .where(eq(leads.id, leadId));

  console.log(`[lead-reminder] Marked lead ${leadId} as unresponsive`);

  // Create activity event
  await createLeadActivity(
    lead.tenantId,
    leadId,
    'lead.unresponsive',
    'ליד לא מגיב',
    `${lead.customerPhone} - לא הגיב לאחר 2 תזכורות`
  );
}

export function startLeadReminderWorker(): Worker<LeadReminderJobData> {
  const worker = new Worker<LeadReminderJobData>(
    'lead-reminders',
    async (job) => {
      if (job.name === 'send-reminder') {
        await processLeadReminder(job);
      } else if (job.name === 'mark-unresponsive') {
        await markLeadUnresponsive(job);
      }
    },
    {
      connection: createRedisConnection(),
      concurrency: 5,
    }
  );

  worker.on('completed', (job) => {
    console.log(`[lead-reminder] Job ${job.id} (${job.name}) completed`);
  });

  worker.on('failed', (job, err) => {
    console.error(`[lead-reminder] Job ${job?.id} (${job?.name}) failed:`, err.message);
  });

  console.log('[lead-reminder] Worker started');
  return worker;
}
```
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify processLeadReminder and markLeadUnresponsive functions exist.
  </verify>
  <done>
Lead reminder worker sends reminders at 2h and 24h, marks unresponsive after timeout, respects terminal states and idempotency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register reminder worker in queue exports and startup</name>
  <files>src/queue/index.ts, src/index.ts</files>
  <action>
Update src/queue/index.ts to export startLeadReminderWorker:

```typescript
export { startLeadReminderWorker } from './workers/lead-reminder.worker';
```

Update src/index.ts to start the reminder worker alongside other workers.

In the worker initialization section (look for where other workers are started), add:

```typescript
import { startLeadReminderWorker } from './queue';

// In the worker startup section:
startLeadReminderWorker();
```

Ensure the worker is started after Redis connection is established.
  </action>
  <verify>
Run `pnpm tsc --noEmit` - no TypeScript errors.
Verify startLeadReminderWorker is exported from src/queue/index.ts.
Verify worker is started in src/index.ts.
  </verify>
  <done>
Lead reminder worker registered and started with application. Processes jobs from lead-reminders queue.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm tsc --noEmit` passes with no errors
2. src/queue/workers/lead-reminder.worker.ts exists
3. startLeadReminderWorker exported from queue/index.ts
4. Worker started in src/index.ts
5. Reminder 1 uses Hebrew message with business name
6. Reminder 2 uses final reminder message
7. Unresponsive timeout scheduled after reminder 2
</verification>

<success_criteria>
- Reminder 1 sent 2 hours after initial message (if no response)
- Reminder 2 sent 24 hours after initial message (if no response)
- Lead marked unresponsive 24 hours after reminder 2
- Reminders are idempotent (skip if already sent)
- Terminal states are respected (no reminders to completed/unresponsive)
- Activity events created for unresponsive leads
</success_criteria>

<output>
After completion, create `.planning/phases/03-lead-capture/03-06-SUMMARY.md`
</output>
