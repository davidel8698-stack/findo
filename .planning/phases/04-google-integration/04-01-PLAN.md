---
phase: 04-google-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/google.ts
  - src/db/schema/index.ts
  - src/services/google/oauth.ts
  - src/services/google/index.ts
  - src/routes/google/callback.ts
  - src/routes/google/index.ts
  - src/index.ts
autonomous: true

user_setup:
  - service: google
    why: "Google Business Profile API access"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client ID"
      - name: GOOGLE_REDIRECT_URI
        source: "Your app URL + /api/google/callback (e.g., https://app.findo.co.il/api/google/callback)"
    dashboard_config:
      - task: "Request GBP API access via contact form"
        location: "https://developers.google.com/my-business/content/prereqs"
      - task: "Enable Business Profile APIs (8 APIs)"
        location: "Google Cloud Console -> APIs & Services -> Library"
      - task: "Configure OAuth consent screen"
        location: "Google Cloud Console -> APIs & Services -> OAuth consent screen"
      - task: "Create OAuth 2.0 Client ID (Web application)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Add authorized redirect URI"
        location: "OAuth Client ID settings"

must_haves:
  truths:
    - "User can initiate Google OAuth flow by visiting auth URL"
    - "OAuth callback exchanges code for tokens"
    - "Access and refresh tokens are stored encrypted in token vault"
    - "Google connection record is created with account/location info"
  artifacts:
    - path: "src/db/schema/google.ts"
      provides: "Google connections table"
      contains: "googleConnections"
    - path: "src/services/google/oauth.ts"
      provides: "OAuth flow handling"
      exports: ["getAuthUrl", "handleCallback", "getGoogleConnection"]
    - path: "src/routes/google/callback.ts"
      provides: "HTTP endpoints for OAuth"
      exports: ["googleRoutes"]
  key_links:
    - from: "src/routes/google/callback.ts"
      to: "src/services/google/oauth.ts"
      via: "handleCallback function call"
      pattern: "handleCallback\\("
    - from: "src/services/google/oauth.ts"
      to: "src/services/token-vault.ts"
      via: "tokenVaultService.storeToken"
      pattern: "tokenVaultService\\.storeToken"
---

<objective>
Create Google OAuth foundation with database schema, OAuth service using googleapis library, and callback route for token exchange.

Purpose: Enable business owners to connect their Google Business Profile to Findo, storing credentials securely in the existing token vault infrastructure.

Output:
- google_connections table with account/location metadata
- OAuth service for auth URL generation and token exchange
- HTTP routes for /api/google/auth, /api/google/callback, /api/google/status
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-google-integration/04-RESEARCH.md

# Reference patterns from WhatsApp integration
@src/db/schema/whatsapp.ts
@src/services/token-vault.ts
@src/db/schema/token-vault.ts
@src/routes/whatsapp/callback.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google connections database schema</name>
  <files>src/db/schema/google.ts, src/db/schema/index.ts</files>
  <action>
Create Google connections schema following the WhatsApp pattern:

1. Create `src/db/schema/google.ts` with:
   - `googleConnectionStatusEnum`: pending, active, disconnected, invalid (same as WhatsApp)
   - `googleConnections` table with columns:
     - id: uuid primary key
     - tenantId: uuid foreign key to tenants (unique constraint - one Google per tenant)
     - accountId: varchar(50) - Google Business Account ID (from accounts.list)
     - accountName: varchar(255) - Account display name
     - locationId: varchar(50) - Primary location ID for reviews
     - locationName: varchar(255) - Location display name (business name)
     - status: googleConnectionStatusEnum default 'pending'
     - verifiedAt: timestamp with timezone
     - createdAt/updatedAt: timestamps
   - Index on status for finding invalid connections

2. Update `src/db/schema/index.ts` to export google schema

3. Generate migration with: `npm run db:generate`

Token vault already has 'google' provider in enum - no changes needed there.
  </action>
  <verify>
- `npm run db:generate` creates migration without errors
- TypeScript compiles: `npx tsc --noEmit`
- Schema exports GoogleConnection type
  </verify>
  <done>
- google_connections table defined with tenant uniqueness constraint
- Migration file generated in drizzle/
- Schema exported from src/db/schema/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Google OAuth service</name>
  <files>src/services/google/oauth.ts, src/services/google/index.ts</files>
  <action>
Create Google OAuth service using googleapis library:

1. Install googleapis: `npm install googleapis`

2. Create `src/services/google/oauth.ts` with:

```typescript
import { google } from 'googleapis';
import { db } from '../../db/index';
import { googleConnections } from '../../db/schema/google';
import { tokenVaultService } from '../token-vault';
import { eq } from 'drizzle-orm';

// Create OAuth2 client factory
function createOAuth2Client() {
  return new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI
  );
}

// Generate authorization URL with state for tenant tracking
export function getAuthUrl(tenantId: string): string {
  const client = createOAuth2Client();
  return client.generateAuthUrl({
    access_type: 'offline',  // Required for refresh token
    scope: ['https://www.googleapis.com/auth/business.manage'],
    prompt: 'consent',  // Always get refresh token (even on re-auth)
    state: tenantId,  // Pass tenant ID through OAuth flow
  });
}

// Handle OAuth callback - exchange code for tokens
export async function handleCallback(code: string, tenantId: string): Promise<{ accountId: string; locationId: string }> {
  const client = createOAuth2Client();

  // Exchange authorization code for tokens
  const { tokens } = await client.getToken(code);

  if (!tokens.access_token) {
    throw new Error('No access token received from Google');
  }

  // Set credentials for subsequent API calls
  client.setCredentials(tokens);

  // Get user's GBP accounts to find primary account/location
  const mybusiness = google.mybusinessaccountmanagement({ version: 'v1', auth: client });
  const accountsResponse = await mybusiness.accounts.list();
  const accounts = accountsResponse.data.accounts || [];

  if (accounts.length === 0) {
    throw new Error('No Google Business Profile accounts found');
  }

  // Use first account (business owners typically have one)
  const account = accounts[0];
  const accountId = account.name?.replace('accounts/', '') || '';
  const accountName = account.accountName || '';

  // Get locations for this account
  const businessInfo = google.mybusinessbusinessinformation({ version: 'v1', auth: client });
  const locationsResponse = await businessInfo.accounts.locations.list({
    parent: `accounts/${accountId}`,
    readMask: 'name,title',
  });
  const locations = locationsResponse.data.locations || [];

  if (locations.length === 0) {
    throw new Error('No locations found for this Google Business account');
  }

  // Use first location
  const location = locations[0];
  const locationId = location.name?.split('/').pop() || '';
  const locationName = location.title || '';

  // Store tokens in vault
  await tokenVaultService.storeToken(tenantId, 'google', 'access_token', {
    value: tokens.access_token,
    expiresAt: tokens.expiry_date ? new Date(tokens.expiry_date) : new Date(Date.now() + 3600000),
    identifier: accountId,
  });

  if (tokens.refresh_token) {
    await tokenVaultService.storeToken(tenantId, 'google', 'refresh_token', {
      value: tokens.refresh_token,
      identifier: accountId,
    });
  }

  // Create or update connection record
  const existing = await db.query.googleConnections.findFirst({
    where: eq(googleConnections.tenantId, tenantId),
  });

  if (existing) {
    await db.update(googleConnections)
      .set({
        accountId,
        accountName,
        locationId,
        locationName,
        status: 'active',
        verifiedAt: new Date(),
        updatedAt: new Date(),
      })
      .where(eq(googleConnections.id, existing.id));
  } else {
    await db.insert(googleConnections).values({
      tenantId,
      accountId,
      accountName,
      locationId,
      locationName,
      status: 'active',
      verifiedAt: new Date(),
    });
  }

  return { accountId, locationId };
}

// Get Google connection status for tenant
export async function getGoogleConnection(tenantId: string) {
  return db.query.googleConnections.findFirst({
    where: eq(googleConnections.tenantId, tenantId),
  });
}

// Disconnect Google (mark as disconnected, delete tokens)
export async function disconnectGoogle(tenantId: string): Promise<void> {
  await db.update(googleConnections)
    .set({ status: 'disconnected', updatedAt: new Date() })
    .where(eq(googleConnections.tenantId, tenantId));

  await tokenVaultService.deleteProviderTokens(tenantId, 'google');
}

// Create authenticated client for API calls
export async function createAuthenticatedClient(tenantId: string, accountId: string) {
  const accessToken = await tokenVaultService.getAccessToken(tenantId, 'google', accountId, 5);

  if (!accessToken) {
    throw new Error('No valid Google access token');
  }

  const client = createOAuth2Client();
  client.setCredentials({ access_token: accessToken.token.value });

  // Listen for token refresh events (googleapis auto-refreshes)
  client.on('tokens', async (newTokens) => {
    if (newTokens.access_token) {
      await tokenVaultService.storeToken(tenantId, 'google', 'access_token', {
        value: newTokens.access_token,
        expiresAt: newTokens.expiry_date ? new Date(newTokens.expiry_date) : undefined,
        identifier: accountId,
      });
    }
    if (newTokens.refresh_token) {
      await tokenVaultService.storeToken(tenantId, 'google', 'refresh_token', {
        value: newTokens.refresh_token,
        identifier: accountId,
      });
    }
  });

  return { client, needsRefresh: accessToken.needsRefresh };
}
```

3. Create `src/services/google/index.ts` barrel export:
```typescript
export * from './oauth';
```

Key decisions:
- Use googleapis library (handles auto-refresh, retry)
- Store accountId as identifier (one token pair per account)
- prompt: 'consent' ensures refresh token on re-auth
- Listen to 'tokens' event for auto-refresh updates
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- googleapis package installed in package.json
- Exports: getAuthUrl, handleCallback, getGoogleConnection, disconnectGoogle, createAuthenticatedClient
  </verify>
  <done>
- OAuth service handles full flow: auth URL -> code exchange -> token storage
- Connection record created with account/location info
- Authenticated client factory for future API calls
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Google OAuth routes</name>
  <files>src/routes/google/callback.ts, src/routes/google/index.ts, src/index.ts</files>
  <action>
Create HTTP routes for Google OAuth following WhatsApp pattern:

1. Create `src/routes/google/callback.ts`:

```typescript
import { Hono } from 'hono';
import { getAuthUrl, handleCallback, getGoogleConnection, disconnectGoogle } from '../../services/google/oauth';

const googleRoutes = new Hono();

// GET /api/google/auth - Redirect to Google OAuth
googleRoutes.get('/auth', async (c) => {
  // Get tenant ID from context (set by tenant middleware)
  const tenantId = c.get('tenantId');

  if (!tenantId) {
    return c.json({ error: 'Tenant ID required' }, 400);
  }

  // Check for required env vars
  if (!process.env.GOOGLE_CLIENT_ID || !process.env.GOOGLE_CLIENT_SECRET) {
    return c.json({ error: 'Google OAuth not configured' }, 500);
  }

  const authUrl = getAuthUrl(tenantId);
  return c.json({ authUrl });
});

// GET /api/google/callback - OAuth callback from Google
googleRoutes.get('/callback', async (c) => {
  const code = c.req.query('code');
  const state = c.req.query('state'); // Contains tenantId
  const error = c.req.query('error');

  if (error) {
    // User denied access or other OAuth error
    return c.redirect('/connect/google?error=' + encodeURIComponent(error));
  }

  if (!code || !state) {
    return c.redirect('/connect/google?error=missing_params');
  }

  try {
    const { accountId, locationId } = await handleCallback(code, state);

    // Redirect to success page with connection info
    return c.redirect(`/connect/google?success=true&account=${encodeURIComponent(accountId)}&location=${encodeURIComponent(locationId)}`);
  } catch (err: any) {
    console.error('Google OAuth callback error:', err);
    return c.redirect('/connect/google?error=' + encodeURIComponent(err.message || 'callback_failed'));
  }
});

// GET /api/google/status - Get connection status
googleRoutes.get('/status', async (c) => {
  const tenantId = c.get('tenantId');

  if (!tenantId) {
    return c.json({ error: 'Tenant ID required' }, 400);
  }

  const connection = await getGoogleConnection(tenantId);

  if (!connection) {
    return c.json({ connected: false });
  }

  return c.json({
    connected: connection.status === 'active',
    status: connection.status,
    accountName: connection.accountName,
    locationName: connection.locationName,
    verifiedAt: connection.verifiedAt,
  });
});

// POST /api/google/disconnect - Disconnect Google
googleRoutes.post('/disconnect', async (c) => {
  const tenantId = c.get('tenantId');

  if (!tenantId) {
    return c.json({ error: 'Tenant ID required' }, 400);
  }

  await disconnectGoogle(tenantId);

  return c.json({ success: true });
});

export { googleRoutes };
```

2. Create `src/routes/google/index.ts`:
```typescript
export { googleRoutes } from './callback';
```

3. Update `src/index.ts` to mount Google routes:
- Add import: `import { googleRoutes } from './routes/google/index';`
- Mount routes: `app.route('/api/google', googleRoutes);`
- Ensure tenant context middleware applies to /api/google routes
  </action>
  <verify>
- Server starts without errors: `npm run dev`
- GET /api/google/auth returns authUrl (or error if env vars missing)
- GET /api/google/status returns { connected: false } for new tenant
  </verify>
  <done>
- /api/google/auth generates OAuth URL with tenant state
- /api/google/callback handles code exchange and redirects
- /api/google/status returns connection info
- /api/google/disconnect removes connection
  </done>
</task>

</tasks>

<verification>
1. Database migration generated successfully
2. TypeScript compiles without errors
3. Server starts and Google routes respond
4. Manual test: GET /api/google/auth returns authUrl (if env vars configured)
</verification>

<success_criteria>
- google_connections table exists in schema with migration
- OAuth service exports all required functions
- Routes mounted at /api/google/*
- Token storage integrates with existing token vault
</success_criteria>

<output>
After completion, create `.planning/phases/04-google-integration/04-01-SUMMARY.md`
</output>
