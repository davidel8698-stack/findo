---
phase: 04-google-integration
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/services/google/token-refresh.ts
  - src/services/google/index.ts
  - src/scheduler/jobs.ts
  - src/queue/workers/test.worker.ts
autonomous: true

must_haves:
  truths:
    - "System proactively refreshes Google tokens before expiry"
    - "Token refresh runs on schedule (every 5 minutes)"
    - "Invalid tokens are marked with error reason"
    - "Connection status updated when token becomes invalid"
  artifacts:
    - path: "src/services/google/token-refresh.ts"
      provides: "Proactive token refresh logic"
      exports: ["refreshExpiringGoogleTokens"]
    - path: "src/scheduler/jobs.ts"
      provides: "Google token refresh job registration"
      contains: "google-token-refresh"
  key_links:
    - from: "src/services/google/token-refresh.ts"
      to: "src/services/token-vault.ts"
      via: "findExpiringTokens and storeToken"
      pattern: "tokenVaultService\\.(findExpiringTokens|storeToken)"
    - from: "src/queue/workers/test.worker.ts"
      to: "src/services/google/token-refresh.ts"
      via: "job handler calling refreshExpiringGoogleTokens"
      pattern: "refreshExpiringGoogleTokens\\("
---

<objective>
Implement proactive Google token refresh to ensure continuous API access without interruption.

Purpose: Google access tokens expire after ~1 hour. Proactive refresh ensures the system never encounters expired tokens during review polling or reply posting, maintaining 24/7 autonomous operation.

Output:
- Token refresh service using googleapis auto-refresh mechanism
- Scheduled job running every 5 minutes to check expiring tokens
- Handler in test worker for token-refresh job type with google provider
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-google-integration/04-RESEARCH.md
@.planning/phases/04-google-integration/04-01-SUMMARY.md

# Token vault service
@src/services/token-vault.ts

# Scheduler patterns from Phase 1
@src/scheduler/jobs.ts
@src/queue/workers/test.worker.ts

# WhatsApp validation pattern (similar approach)
@src/services/whatsapp/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google token refresh service</name>
  <files>src/services/google/token-refresh.ts, src/services/google/index.ts</files>
  <action>
Create token refresh service following the pattern from RESEARCH.md:

```typescript
import { google } from 'googleapis';
import { db } from '../../db/index';
import { googleConnections } from '../../db/schema/google';
import { tokenVaultService } from '../token-vault';
import { eq } from 'drizzle-orm';

// Refresh expiring Google tokens proactively
// Called by scheduled job every 5 minutes
export async function refreshExpiringGoogleTokens(): Promise<{
  checked: number;
  refreshed: number;
  failed: number;
}> {
  // Find Google access tokens expiring within 10 minutes
  const expiring = await tokenVaultService.findExpiringTokens(10, 'google');

  const results = {
    checked: expiring.length,
    refreshed: 0,
    failed: 0,
  };

  for (const entry of expiring) {
    try {
      await refreshTokenForTenant(entry.tenantId, entry.identifier || '');
      results.refreshed++;
    } catch (error: any) {
      console.error(`Failed to refresh Google token for tenant ${entry.tenantId}:`, error.message);
      results.failed++;
    }

    // Small delay between refreshes to avoid rate limiting
    await new Promise((resolve) => setTimeout(resolve, 100));
  }

  console.log(`Google token refresh: ${results.checked} checked, ${results.refreshed} refreshed, ${results.failed} failed`);
  return results;
}

// Refresh token for a specific tenant
async function refreshTokenForTenant(tenantId: string, accountId: string): Promise<void> {
  // Get refresh token
  const refreshToken = await tokenVaultService.getRefreshToken(tenantId, 'google', accountId);

  if (!refreshToken) {
    throw new Error('No refresh token found');
  }

  // Create OAuth client and set refresh token
  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET
  );

  oauth2Client.setCredentials({
    refresh_token: refreshToken.value,
  });

  // Force refresh the access token
  const { credentials } = await oauth2Client.refreshAccessToken();

  if (!credentials.access_token) {
    throw new Error('No access token received from refresh');
  }

  // Store new access token
  await tokenVaultService.storeToken(tenantId, 'google', 'access_token', {
    value: credentials.access_token,
    expiresAt: credentials.expiry_date ? new Date(credentials.expiry_date) : new Date(Date.now() + 3600000),
    identifier: accountId,
  });

  // If we got a new refresh token (rare), store it too
  if (credentials.refresh_token) {
    await tokenVaultService.storeToken(tenantId, 'google', 'refresh_token', {
      value: credentials.refresh_token,
      identifier: accountId,
    });
  }

  console.log(`Refreshed Google token for tenant ${tenantId}`);
}

// Validate a Google token by calling /me endpoint (for daily validation job)
// Similar to WhatsApp validation pattern
export async function validateGoogleToken(tenantId: string, accountId: string): Promise<boolean> {
  try {
    const accessToken = await tokenVaultService.getAccessToken(tenantId, 'google', accountId, 0);

    if (!accessToken) {
      return false;
    }

    const oauth2Client = new google.auth.OAuth2();
    oauth2Client.setCredentials({ access_token: accessToken.token.value });

    // Try to get account info as validation check
    const accountManagement = google.mybusinessaccountmanagement({
      version: 'v1',
      auth: oauth2Client,
    });

    await accountManagement.accounts.get({
      name: `accounts/${accountId}`,
    });

    return true;
  } catch (error: any) {
    console.error(`Google token validation failed for tenant ${tenantId}:`, error.message);

    // Mark token as invalid
    const accessToken = await tokenVaultService.getToken(tenantId, 'google', 'access_token', accountId);
    if (accessToken) {
      await tokenVaultService.markTokenInvalid(accessToken.id, `Validation failed: ${error.message}`);
    }

    // Update connection status to invalid
    await db.update(googleConnections)
      .set({ status: 'invalid', updatedAt: new Date() })
      .where(eq(googleConnections.tenantId, tenantId));

    return false;
  }
}

// Run daily validation for all Google connections
export async function validateAllGoogleTokens(): Promise<{
  checked: number;
  valid: number;
  invalid: number;
}> {
  const connections = await db.query.googleConnections.findMany({
    where: eq(googleConnections.status, 'active'),
  });

  const results = {
    checked: connections.length,
    valid: 0,
    invalid: 0,
  };

  for (const conn of connections) {
    const isValid = await validateGoogleToken(conn.tenantId, conn.accountId);
    if (isValid) {
      results.valid++;
    } else {
      results.invalid++;
    }

    // Rate limit protection
    await new Promise((resolve) => setTimeout(resolve, 100));
  }

  console.log(`Google token validation: ${results.checked} checked, ${results.valid} valid, ${results.invalid} invalid`);
  return results;
}
```

Update `src/services/google/index.ts`:
```typescript
export * from './oauth';
export * from './profile';
export * from './reviews';
export * from './token-refresh';
```
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Exports: refreshExpiringGoogleTokens, validateGoogleToken, validateAllGoogleTokens
- Service integrates with tokenVaultService.findExpiringTokens
  </verify>
  <done>
- Token refresh service finds expiring tokens and refreshes them
- Validation service checks token validity against Google API
- 100ms delay between operations for rate limit protection
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Google token refresh scheduled job</name>
  <files>src/scheduler/jobs.ts, src/queue/workers/test.worker.ts</files>
  <action>
Add Google token refresh to the scheduler and worker:

1. Update `src/scheduler/jobs.ts` - add Google token refresh job:

In the `scheduleRecurringJobs` function, add:
```typescript
// Google token refresh - every 5 minutes
await scheduledQueue.add(
  'google-token-refresh',
  {
    jobType: 'token-refresh',
    provider: 'google',
    mode: 'proactive',
  },
  {
    repeat: {
      pattern: '*/5 * * * *',  // Every 5 minutes
      tz: 'Asia/Jerusalem',
    },
  }
);
```

Also add a daily validation job (similar to WhatsApp):
```typescript
// Google token validation - daily at 3:30 AM
await scheduledQueue.add(
  'google-token-validation',
  {
    jobType: 'token-refresh',
    provider: 'google',
    mode: 'daily-validation',
  },
  {
    repeat: {
      pattern: '30 3 * * *',  // 3:30 AM Israel time
      tz: 'Asia/Jerusalem',
    },
  }
);
```

2. Update `src/queue/workers/test.worker.ts` - add handler for Google refresh:

Add imports at top:
```typescript
import { refreshExpiringGoogleTokens, validateAllGoogleTokens } from '../services/google/token-refresh';
```

In the job processor, extend the token-refresh handler to support Google:
```typescript
case 'token-refresh':
  if (job.data.provider === 'whatsapp') {
    if (job.data.mode === 'daily-validation') {
      // Existing WhatsApp validation
      await validateAllWhatsAppTokens();
    }
  } else if (job.data.provider === 'google') {
    if (job.data.mode === 'proactive') {
      // Proactive token refresh (every 5 min)
      await refreshExpiringGoogleTokens();
    } else if (job.data.mode === 'daily-validation') {
      // Daily validation (3:30 AM)
      await validateAllGoogleTokens();
    }
  }
  break;
```

Note: The existing token-refresh job at :00 and :30 is for WhatsApp. Google gets its own jobs with specific naming.
  </action>
  <verify>
- Server starts without errors: `npm run dev`
- Check scheduled jobs exist: look for 'google-token-refresh' and 'google-token-validation' in BullMQ dashboard or logs
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
- google-token-refresh job runs every 5 minutes
- google-token-validation job runs daily at 3:30 AM (offset from WhatsApp at 3:00 AM)
- Handler processes Google token refresh and validation
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Server starts and schedules Google token jobs
3. Token refresh service exported from src/services/google/index.ts
4. Job handler processes google provider in token-refresh job type
</verification>

<success_criteria>
- Proactive refresh runs every 5 minutes, refreshing tokens expiring within 10 minutes
- Daily validation at 3:30 AM checks all active Google connections
- Invalid tokens marked in vault and connection status updated
- Rate limiting (100ms delay) prevents Google API throttling
</success_criteria>

<output>
After completion, create `.planning/phases/04-google-integration/04-03-SUMMARY.md`
</output>
