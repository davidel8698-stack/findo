---
phase: 05-review-management
plan: 05
type: execute
wave: 3
depends_on: ["05-03", "05-04"]
files_modified:
  - src/services/review-management/response-handler.ts
  - src/services/whatsapp/webhooks.ts
  - src/queue/workers/whatsapp-message.worker.ts
  - src/services/review-management/index.ts
autonomous: true

must_haves:
  truths:
    - "Owner button clicks are detected and processed"
    - "Approve posts the draft reply to Google"
    - "Edit prompts owner for custom reply"
    - "Owner text responses are captured as edited replies"
    - "Existing lead capture functionality continues to work"
  artifacts:
    - path: "src/services/review-management/response-handler.ts"
      provides: "Owner response processing"
      exports: ["handleOwnerReviewResponse", "approveReviewReply", "submitEditedReply"]
    - path: "src/services/whatsapp/webhooks.ts"
      provides: "ParsedMessage with buttonId field"
      contains: "buttonId?: string"
    - path: "src/queue/workers/whatsapp-message.worker.ts"
      provides: "Integration with review response handling"
      contains: "handleOwnerReviewResponse"
  key_links:
    - from: "src/services/review-management/response-handler.ts"
      to: "src/services/google/reviews.ts"
      via: "postReviewReply import"
      pattern: "import.*postReviewReply.*from.*google/reviews"
    - from: "src/queue/workers/whatsapp-message.worker.ts"
      to: "src/services/review-management"
      via: "handleOwnerReviewResponse import"
      pattern: "import.*handleOwnerReviewResponse.*from.*review-management"
    - from: "src/services/whatsapp/webhooks.ts"
      to: "button_reply.id"
      via: "interactive message parsing"
      pattern: "button_reply"
---

<objective>
Implement owner response handling for review approval workflow.

Purpose: Process owner's approval or edit of negative review responses. Handle both interactive button clicks and text message responses (for when buttons aren't available).
Output: Response handler integrated into WhatsApp message worker.
</objective>

<context>
@.planning/PROJECT.md
@.planning/phases/05-review-management/05-CONTEXT.md

# Existing patterns
@src/queue/workers/whatsapp-message.worker.ts
@src/services/lead-capture/notifications.ts
@src/services/whatsapp/webhooks.ts

# From this phase
@.planning/phases/05-review-management/05-03-SUMMARY.md
@.planning/phases/05-review-management/05-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create owner response handler service</name>
  <files>src/services/review-management/response-handler.ts</files>
  <action>
Create service for processing owner responses to review approvals:

1. **handleOwnerReviewResponse function:**
   - Parameters: tenantId, messageFrom, messageText, buttonId (optional)
   - Returns: boolean (true if handled, false if not a review response)

   Logic:
   - If buttonId starts with 'approve_': call approveReviewReply
   - If buttonId starts with 'edit_': call requestEditedReply
   - If messageText === 'אשר': find latest pending approval and approve
   - If has pending edit request: treat as edited reply submission
   - Otherwise return false (not a review response)

2. **approveReviewReply function:**
   - Parameters: tenantId, reviewId (from processedReviews)
   - Load processedReview, googleConnection
   - Post draftReply via postReviewReply
   - Update processedReview:
     * status = 'approved' -> 'replied'
     * postedReply = draftReply
     * repliedAt = now
   - Send confirmation to owner: "התשובה פורסמה בהצלחה!"
   - Create activity event 'review.replied'

3. **requestEditedReply function:**
   - Parameters: tenantId, reviewId
   - Update processedReview.status = 'edited' (marks as awaiting edit)
   - Send message: "אנא כתוב/י את התשובה שברצונך לפרסם:"
   - Store reviewId in temporary tracking (use ownerResponse field with 'AWAITING_EDIT:{reviewId}')

4. **submitEditedReply function:**
   - Parameters: tenantId, reviewId, editedText
   - Validate byte length <= 4096
   - Post editedText via postReviewReply
   - Update processedReview:
     * status = 'replied'
     * postedReply = editedText
     * ownerResponse = editedText
     * repliedAt = now
   - Send confirmation: "התשובה פורסמה בהצלחה!"
   - Create activity event 'review.replied'

5. **getPendingEditForOwner helper:**
   - Find processedReview where status = 'edited' and ownerResponse starts with 'AWAITING_EDIT:'
   - Match by tenantId and most recent approvalSentAt
   - Return reviewId or null

6. **getLatestPendingApproval helper:**
   - Find processedReview where status = 'pending_approval' or 'reminded'
   - Match by tenantId, order by approvalSentAt desc
   - Return record or null
  </action>
  <verify>
TypeScript compiles without errors.
All three response paths work (button approve, button edit, text approve).
  </verify>
  <done>
response-handler.ts handles all owner response scenarios.
approveReviewReply posts draft to Google.
submitEditedReply posts owner's custom text.
Pending edit tracking uses ownerResponse field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add buttonId to ParsedMessage and parse from webhook</name>
  <files>src/services/whatsapp/webhooks.ts</files>
  <action>
Modify webhooks.ts to extract button reply ID from interactive messages:

1. **Update ParsedMessage interface (around line 171):**
   Add buttonId field:
   ```typescript
   export interface ParsedMessage {
     waMessageId: string;
     from: string;
     timestamp: Date;
     type: 'text' | 'image' | 'interactive' | 'unknown';  // Add 'interactive'
     text?: string;
     mediaId?: string;
     mediaCaption?: string;
     contactName?: string;
     rawType: string;
     buttonId?: string;  // NEW: Button reply ID from interactive messages
   }
   ```

2. **Update mapMessageType function (around line 196):**
   Add interactive type mapping:
   ```typescript
   case 'interactive':
     return 'interactive';
   ```

3. **In processWhatsAppMessages function, where messages are parsed:**
   After extracting text from message, add interactive button parsing:
   ```typescript
   // Extract button reply ID from interactive messages
   let buttonId: string | undefined;
   if (message.type === 'interactive' && message.interactive?.type === 'button_reply') {
     buttonId = message.interactive.button_reply?.id;
   }
   ```

4. **Include buttonId in the ParsedMessage object being pushed:**
   ```typescript
   messages.push({
     waMessageId: message.id,
     from: message.from,
     timestamp: new Date(parseInt(message.timestamp) * 1000),
     type: mapMessageType(message.type),
     text: message.text?.body || message.interactive?.button_reply?.title,
     mediaId: message.image?.id,
     mediaCaption: message.image?.caption,
     contactName: contacts?.find((c: { wa_id: string }) => c.wa_id === message.from)?.profile?.name,
     rawType: message.type,
     buttonId,  // NEW
   });
   ```

This ensures button clicks are captured at the webhook parsing layer, not detected later.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles.
Grep for 'buttonId' in webhooks.ts to confirm field exists in interface and parsing logic.
  </verify>
  <done>
ParsedMessage interface includes buttonId?: string field.
Interactive message type is recognized (not mapped to 'unknown').
Button reply ID is extracted from message.interactive.button_reply.id.
buttonId is included in parsed message output.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate response handler into WhatsApp message worker</name>
  <files>src/queue/workers/whatsapp-message.worker.ts</files>
  <action>
Modify the whatsapp-message worker to detect and handle owner review responses:

1. **Add import:**
   ```typescript
   import { handleOwnerReviewResponse } from '../../services/review-management';
   ```

2. **After lead conversation handling, before saving message:**
   Add check for owner review response:
   ```typescript
   // Check if this is an owner review response
   const isOwner = message.from === tenant?.ownerPhone;
   if (isOwner && (message.buttonId || message.text)) {
     const handled = await handleOwnerReviewResponse(
       tenantId,
       message.from,
       message.text || '',
       message.buttonId  // Now typed as string | undefined from ParsedMessage
     );
     if (handled) {
       console.log('[whatsapp-message] Processed as owner review response');
       // Still save message but skip lead processing
     }
   }
   ```

3. **Ensure tenant is loaded early:**
   Tenant should be loaded at the start of message processing (before the owner check).
   If not already loaded, add:
   ```typescript
   const tenant = await db.query.tenants.findFirst({
     where: eq(tenants.id, tenantId),
   });
   ```

4. **IMPORTANT - Preserve existing lead capture behavior:**
   The owner check should NOT interfere with non-owner messages.
   Structure the logic so:
   - If isOwner AND handled by review response handler -> skip lead processing
   - If NOT isOwner -> continue with existing lead capture flow unchanged
   - If isOwner but NOT handled (handleOwnerReviewResponse returns false) -> could be owner asking about something else, handle appropriately
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm TypeScript compiles.
Manually verify logic by tracing:
1. Non-owner message -> should hit existing lead capture (unchanged)
2. Owner message with buttonId -> should call handleOwnerReviewResponse
3. Owner text 'אשר' -> should call handleOwnerReviewResponse
  </verify>
  <done>
Worker imports and calls handleOwnerReviewResponse for owner messages.
Button ID is passed from ParsedMessage.buttonId (no additional parsing needed).
Owner review responses are processed before other handlers.
Non-owner messages continue through existing lead capture flow unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 4: Export response handler from index</name>
  <files>src/services/review-management/index.ts</files>
  <action>
Add export for response-handler module:

```typescript
export * from './response-handler';
```

This makes handleOwnerReviewResponse importable from 'services/review-management'.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm handleOwnerReviewResponse is importable from services/review-management.
  </verify>
  <done>
index.ts exports response-handler module.
All response handler functions are accessible.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. ParsedMessage interface includes buttonId field
3. Interactive messages are parsed with button_reply.id extracted
4. Button click with approve_{id} triggers approveReviewReply
5. Button click with edit_{id} triggers requestEditedReply
6. Text "אשר" approves latest pending review
7. Reply is posted to Google and confirmed to owner
8. Activity events created for audit trail
9. **CRITICAL:** Send a test text message from non-owner phone, verify it still triggers lead capture flow
</verification>

<success_criteria>
- Owner button clicks (approve/edit) are detected from webhook via ParsedMessage.buttonId
- Approve posts draft reply to Google immediately
- Edit prompts owner and waits for custom reply
- Custom reply is validated and posted to Google
- Owner receives Hebrew confirmation after posting
- Status transitions: pending_approval -> approved -> replied
- Status transitions: pending_approval -> edited -> replied
- Existing lead capture for non-owner messages works unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-review-management/05-05-SUMMARY.md`
</output>
