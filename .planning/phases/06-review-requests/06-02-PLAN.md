---
phase: 06-review-requests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/greeninvoice/index.ts
  - src/services/greeninvoice/documents.ts
  - src/services/greeninvoice/types.ts
autonomous: true

must_haves:
  truths:
    - "System can authenticate with Greeninvoice API using API key credentials"
    - "System can fetch invoices from Greeninvoice by date range"
    - "JWT token is cached and refreshed before expiration"
  artifacts:
    - path: "src/services/greeninvoice/index.ts"
      provides: "GreeninvoiceClient class with authentication"
      exports: ["GreeninvoiceClient", "createGreeninvoiceClient"]
    - path: "src/services/greeninvoice/documents.ts"
      provides: "Document search function"
      exports: ["fetchInvoices"]
    - path: "src/services/greeninvoice/types.ts"
      provides: "TypeScript types for Greeninvoice API"
      exports: ["GreeninvoiceCredentials", "GreeninvoiceDocument", "DetectedInvoice"]
  key_links:
    - from: "src/services/greeninvoice/index.ts"
      to: "https://api.greeninvoice.co.il/api/v1"
      via: "HTTP fetch"
      pattern: "api.greeninvoice.co.il"
---

<objective>
Create Greeninvoice API client for invoice detection via polling.

Purpose: Enable hourly polling of Greeninvoice to detect new invoices and trigger review request flows. Research confirmed webhooks are NOT available for invoice creation - polling is required.

Output: Greeninvoice client service with JWT authentication, token caching, and document search functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-review-requests/06-RESEARCH.md
@src/services/token-vault/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Greeninvoice types</name>
  <files>src/services/greeninvoice/types.ts</files>
  <action>
Create types file with:

```typescript
/**
 * Greeninvoice API credentials stored in token vault.
 */
export interface GreeninvoiceCredentials {
  id: string;      // API Key ID
  secret: string;  // API Key Secret
}

/**
 * Greeninvoice document (invoice) from API response.
 * Document types per API:
 * - 300: Proforma Invoice
 * - 305: Tax Invoice (main type we want)
 * - 320: Invoice/Receipt
 * - 400: Receipt
 */
export interface GreeninvoiceDocument {
  id: string;
  number: string;
  type: number;  // 305 for tax invoice, 320 for invoice/receipt
  createdAt: string;
  total: number;
  currency: string;
  client?: {
    name?: string;
    phone?: string;
    emails?: string[];
  };
}

/**
 * Search response from /documents/search endpoint.
 */
export interface GreeninvoiceSearchResponse {
  items: GreeninvoiceDocument[];
  total: number;
  page: number;
  pageSize: number;
}

/**
 * Token response from /account/token endpoint.
 */
export interface GreeninvoiceTokenResponse {
  token: string;
  expiresIn: number; // seconds, typically 3600 (1 hour)
}

/**
 * Normalized invoice for internal use across providers.
 */
export interface DetectedInvoice {
  invoiceId: string;
  invoiceNumber: string;
  customerName: string;
  customerPhone: string | null;
  customerEmail: string | null;
  amount: number;
  currency: string;
  createdAt: string;
  provider: 'greeninvoice' | 'icount';
}
```
  </action>
  <verify>
`npx tsc --noEmit` - types file compiles without errors.
  </verify>
  <done>
Types file exists with all Greeninvoice API types and DetectedInvoice interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Greeninvoice client with JWT authentication</name>
  <files>src/services/greeninvoice/index.ts</files>
  <action>
Create client class with JWT token caching:

```typescript
import { GreeninvoiceCredentials, GreeninvoiceTokenResponse } from './types';

const GREENINVOICE_API = 'https://api.greeninvoice.co.il/api/v1';

// Token cache: tenantId -> { token, expiresAt }
const tokenCache = new Map<string, { token: string; expiresAt: Date }>();

/**
 * Greeninvoice API client with automatic JWT token management.
 */
export class GreeninvoiceClient {
  private tenantId: string;
  private credentials: GreeninvoiceCredentials;

  constructor(tenantId: string, credentials: GreeninvoiceCredentials) {
    this.tenantId = tenantId;
    this.credentials = credentials;
  }

  /**
   * Get a valid JWT token, refreshing if expired or about to expire.
   * Tokens are cached per tenant. Refreshes 5 minutes before expiration.
   */
  async getToken(): Promise<string> {
    const cached = tokenCache.get(this.tenantId);

    // Check if token is valid (with 5 minute buffer)
    if (cached) {
      const bufferMs = 5 * 60 * 1000; // 5 minutes
      if (new Date(Date.now() + bufferMs) < cached.expiresAt) {
        return cached.token;
      }
    }

    // Fetch new token
    const response = await fetch(`${GREENINVOICE_API}/account/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        id: this.credentials.id,
        secret: this.credentials.secret,
      }),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Greeninvoice auth failed: ${response.status} ${text}`);
    }

    const data: GreeninvoiceTokenResponse = await response.json();

    // Cache token with expiration
    const expiresAt = new Date(Date.now() + data.expiresIn * 1000);
    tokenCache.set(this.tenantId, { token: data.token, expiresAt });

    return data.token;
  }

  /**
   * Make authenticated request to Greeninvoice API.
   */
  async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const token = await this.getToken();

    const response = await fetch(`${GREENINVOICE_API}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        ...options.headers,
      },
    });

    if (!response.ok) {
      // If 401, clear cache and retry once
      if (response.status === 401) {
        tokenCache.delete(this.tenantId);
        const retryToken = await this.getToken();
        const retryResponse = await fetch(`${GREENINVOICE_API}${endpoint}`, {
          ...options,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${retryToken}`,
            ...options.headers,
          },
        });
        if (!retryResponse.ok) {
          throw new Error(`Greeninvoice API error: ${retryResponse.status}`);
        }
        return retryResponse.json();
      }
      throw new Error(`Greeninvoice API error: ${response.status}`);
    }

    return response.json();
  }
}

/**
 * Create Greeninvoice client for a tenant.
 * Credentials should be decrypted from token vault before calling.
 */
export function createGreeninvoiceClient(
  tenantId: string,
  credentials: GreeninvoiceCredentials
): GreeninvoiceClient {
  return new GreeninvoiceClient(tenantId, credentials);
}

// Re-export types
export * from './types';
export * from './documents';
```

Key features:
- JWT token caching with 5-minute expiration buffer (per research pitfall #1)
- Automatic retry on 401 (token expired)
- Clean factory function for creating clients
  </action>
  <verify>
`npx tsc --noEmit` - client compiles without errors.
  </verify>
  <done>
Client class exists with JWT authentication, token caching, 401 retry logic, and request helper method.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create document search function</name>
  <files>src/services/greeninvoice/documents.ts</files>
  <action>
Create document search function:

```typescript
import { GreeninvoiceClient } from './index';
import { GreeninvoiceSearchResponse, DetectedInvoice } from './types';

/**
 * Fetch invoices from Greeninvoice since a given date.
 * Searches for document types 305 (Tax Invoice) and 320 (Invoice/Receipt).
 *
 * @param client - Authenticated Greeninvoice client
 * @param fromDate - Only return invoices created after this date
 * @param pageSize - Number of results per page (default 100)
 * @returns Array of detected invoices normalized for internal use
 */
export async function fetchInvoices(
  client: GreeninvoiceClient,
  fromDate: Date,
  pageSize: number = 100
): Promise<DetectedInvoice[]> {
  const response = await client.request<GreeninvoiceSearchResponse>(
    '/documents/search',
    {
      method: 'POST',
      body: JSON.stringify({
        type: [305, 320], // Tax Invoice and Invoice/Receipt
        fromDate: fromDate.toISOString().split('T')[0], // YYYY-MM-DD
        toDate: new Date().toISOString().split('T')[0],
        pageSize,
        sort: 'createdAt',
        sortType: 'desc',
      }),
    }
  );

  // Normalize to DetectedInvoice format
  return response.items.map((doc) => ({
    invoiceId: doc.id,
    invoiceNumber: doc.number,
    customerName: doc.client?.name || 'Unknown',
    customerPhone: doc.client?.phone || null,
    customerEmail: doc.client?.emails?.[0] || null,
    amount: doc.total,
    currency: doc.currency,
    createdAt: doc.createdAt,
    provider: 'greeninvoice' as const,
  }));
}
```

Note: Date format is YYYY-MM-DD per Greeninvoice API requirements.
  </action>
  <verify>
`npx tsc --noEmit` - document search compiles without errors.
  </verify>
  <done>
Document search function exists that fetches invoices (types 305, 320) and normalizes them to DetectedInvoice format.
  </done>
</task>

</tasks>

<verification>
- [ ] src/services/greeninvoice/types.ts exists with all types
- [ ] src/services/greeninvoice/index.ts exists with client class
- [ ] src/services/greeninvoice/documents.ts exists with fetchInvoices function
- [ ] TypeScript compiles without errors
- [ ] JWT token caching is implemented with 5-minute buffer
- [ ] 401 retry logic is implemented
</verification>

<success_criteria>
- GreeninvoiceClient can authenticate and cache JWT tokens
- fetchInvoices returns normalized DetectedInvoice array
- Token caching prevents unnecessary auth calls
- 401 errors trigger token refresh and retry
</success_criteria>

<output>
After completion, create `.planning/phases/06-review-requests/06-02-SUMMARY.md`
</output>
