---
phase: 06-review-requests
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/icount/index.ts
  - src/services/icount/documents.ts
  - src/services/icount/types.ts
autonomous: true

must_haves:
  truths:
    - "System can authenticate with iCount API using session login"
    - "System can fetch invoices from iCount by date range"
    - "Session ID is obtained per polling cycle (not shared)"
  artifacts:
    - path: "src/services/icount/index.ts"
      provides: "IcountClient class with session authentication"
      exports: ["IcountClient", "createIcountClient"]
    - path: "src/services/icount/documents.ts"
      provides: "Document search function"
      exports: ["fetchInvoices"]
    - path: "src/services/icount/types.ts"
      provides: "TypeScript types for iCount API"
      exports: ["IcountCredentials", "IcountDocument"]
  key_links:
    - from: "src/services/icount/index.ts"
      to: "https://api.icount.co.il"
      via: "HTTP fetch"
      pattern: "api.icount.co.il"
---

<objective>
Create iCount API client for invoice detection via polling.

Purpose: Enable hourly polling of iCount to detect new invoices and trigger review request flows. Research confirmed iCount has NO webhook system - polling is the only option.

Output: iCount client service with session-based authentication and document search functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-review-requests/06-RESEARCH.md
@src/services/greeninvoice/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create iCount types</name>
  <files>src/services/icount/types.ts</files>
  <action>
Create types file with:

```typescript
/**
 * iCount API credentials stored in token vault.
 */
export interface IcountCredentials {
  companyId: string;  // Company ID (cid)
  username: string;   // User login
  password: string;   // User password
}

/**
 * iCount session response from /api/login endpoint.
 */
export interface IcountLoginResponse {
  status: 'ok' | 'error';
  sid?: string;   // Session ID (only if status='ok')
  reason?: string; // Error reason (only if status='error')
}

/**
 * iCount document from doc_search response.
 * Document types: invoice, invrec (invoice+receipt), receipt, refund, order, offer, delivery, deal
 */
export interface IcountDocument {
  docnum: string;      // Document number
  doctype: string;     // 'invoice', 'invrec', etc.
  docdate: string;     // Document date (YYYY-MM-DD)
  total: number;       // Total amount
  client_name?: string;
  client_phone?: string;
  client_email?: string;
}

/**
 * iCount doc_search response.
 */
export interface IcountSearchResponse {
  status: 'ok' | 'error';
  docs?: IcountDocument[];
  reason?: string;
}

/**
 * Re-export DetectedInvoice for use across providers.
 * Using same type as Greeninvoice for consistency.
 */
export interface DetectedInvoice {
  invoiceId: string;
  invoiceNumber: string;
  customerName: string;
  customerPhone: string | null;
  customerEmail: string | null;
  amount: number;
  currency: string;
  createdAt: string;
  provider: 'greeninvoice' | 'icount';
}
```
  </action>
  <verify>
`npx tsc --noEmit` - types file compiles without errors.
  </verify>
  <done>
Types file exists with all iCount API types and DetectedInvoice interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create iCount client with session authentication</name>
  <files>src/services/icount/index.ts</files>
  <action>
Create client class with session management:

```typescript
import { IcountCredentials, IcountLoginResponse } from './types';

const ICOUNT_API = 'https://api.icount.co.il';

/**
 * iCount API client with session-based authentication.
 *
 * IMPORTANT: iCount uses session IDs (sid) that may not support concurrency.
 * Create a new client per polling cycle and avoid sharing sessions.
 * Per research pitfall #2: Use single session per polling cycle.
 */
export class IcountClient {
  private credentials: IcountCredentials;
  private sessionId: string | null = null;

  constructor(credentials: IcountCredentials) {
    this.credentials = credentials;
  }

  /**
   * Login to iCount and obtain session ID.
   * Session IDs typically expire after 1 hour.
   */
  async login(): Promise<string> {
    if (this.sessionId) {
      return this.sessionId;
    }

    const response = await fetch(`${ICOUNT_API}/api/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        cid: this.credentials.companyId,
        user: this.credentials.username,
        pass: this.credentials.password,
      }),
    });

    if (!response.ok) {
      throw new Error(`iCount login failed: HTTP ${response.status}`);
    }

    const data: IcountLoginResponse = await response.json();

    if (data.status !== 'ok' || !data.sid) {
      throw new Error(`iCount login failed: ${data.reason || 'Unknown error'}`);
    }

    this.sessionId = data.sid;
    return this.sessionId;
  }

  /**
   * Logout and invalidate session.
   * Call this after completing a polling cycle.
   */
  async logout(): Promise<void> {
    if (!this.sessionId) return;

    try {
      await fetch(`${ICOUNT_API}/api/logout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({ sid: this.sessionId }),
      });
    } catch (error) {
      // Logout failures are non-critical, log and continue
      console.warn('[icount] Logout failed:', error);
    }

    this.sessionId = null;
  }

  /**
   * Make authenticated request to iCount API.
   * Requires login() to be called first.
   */
  async request<T>(endpoint: string, params: Record<string, string> = {}): Promise<T> {
    if (!this.sessionId) {
      await this.login();
    }

    const response = await fetch(`${ICOUNT_API}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        sid: this.sessionId!,
        ...params,
      }),
    });

    if (!response.ok) {
      throw new Error(`iCount API error: HTTP ${response.status}`);
    }

    const data = await response.json();

    // iCount returns status field in responses
    if (data.status === 'error') {
      // Session may have expired
      if (data.reason?.includes('session') || data.reason?.includes('auth')) {
        this.sessionId = null;
        throw new Error(`iCount session expired: ${data.reason}`);
      }
      throw new Error(`iCount API error: ${data.reason}`);
    }

    return data;
  }
}

/**
 * Create iCount client for a polling cycle.
 * Credentials should be decrypted from token vault before calling.
 *
 * Usage pattern:
 * ```typescript
 * const client = createIcountClient(credentials);
 * try {
 *   await client.login();
 *   const invoices = await fetchInvoices(client, fromDate);
 *   // Process invoices...
 * } finally {
 *   await client.logout(); // Always logout after use
 * }
 * ```
 */
export function createIcountClient(credentials: IcountCredentials): IcountClient {
  return new IcountClient(credentials);
}

// Re-export types
export * from './types';
export * from './documents';
```

Key features:
- Session-based auth (not cached across polling cycles per research pitfall #2)
- Logout after use pattern
- Session expiration handling
  </action>
  <verify>
`npx tsc --noEmit` - client compiles without errors.
  </verify>
  <done>
Client class exists with session authentication, login/logout methods, and request helper.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create document search function</name>
  <files>src/services/icount/documents.ts</files>
  <action>
Create document search function:

```typescript
import { IcountClient } from './index';
import { IcountSearchResponse, DetectedInvoice } from './types';

/**
 * Fetch invoices from iCount since a given date.
 * Searches for document types 'invoice' and 'invrec' (invoice+receipt).
 *
 * @param client - Authenticated iCount client (must have called login())
 * @param fromDate - Only return invoices created after this date
 * @returns Array of detected invoices normalized for internal use
 */
export async function fetchInvoices(
  client: IcountClient,
  fromDate: Date
): Promise<DetectedInvoice[]> {
  const response = await client.request<IcountSearchResponse>('/api/doc_search', {
    doctype: 'invoice,invrec', // Both invoice types
    from_date: fromDate.toISOString().split('T')[0], // YYYY-MM-DD
    to_date: new Date().toISOString().split('T')[0],
  });

  // Handle empty response
  if (!response.docs || response.docs.length === 0) {
    return [];
  }

  // Normalize to DetectedInvoice format
  return response.docs.map((doc) => ({
    invoiceId: doc.docnum,
    invoiceNumber: doc.docnum,
    customerName: doc.client_name || 'Unknown',
    customerPhone: doc.client_phone || null,
    customerEmail: doc.client_email || null,
    amount: doc.total,
    currency: 'ILS', // iCount is Israeli, always ILS
    createdAt: doc.docdate,
    provider: 'icount' as const,
  }));
}
```

Note:
- Date format is YYYY-MM-DD per iCount API
- Currency hardcoded to ILS (Israeli Shekels) as iCount is Israel-only platform
  </action>
  <verify>
`npx tsc --noEmit` - document search compiles without errors.
  </verify>
  <done>
Document search function exists that fetches invoices and normalizes them to DetectedInvoice format.
  </done>
</task>

</tasks>

<verification>
- [ ] src/services/icount/types.ts exists with all types
- [ ] src/services/icount/index.ts exists with client class
- [ ] src/services/icount/documents.ts exists with fetchInvoices function
- [ ] TypeScript compiles without errors
- [ ] Session-based auth is implemented (not cached across cycles)
- [ ] Logout pattern is documented in JSDoc
</verification>

<success_criteria>
- IcountClient can authenticate via session login
- fetchInvoices returns normalized DetectedInvoice array
- Client follows single-session-per-cycle pattern
- Session expiration errors are handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/06-review-requests/06-03-SUMMARY.md`
</output>
