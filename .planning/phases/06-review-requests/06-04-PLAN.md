---
phase: 06-review-requests
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - src/queue/workers/invoice-poll.worker.ts
  - src/queue/queues.ts
  - src/queue/index.ts
  - src/scheduler/jobs.ts
autonomous: true

must_haves:
  truths:
    - "System polls for new invoices every hour"
    - "New invoices trigger 24-hour delayed review request jobs"
    - "Duplicate invoices are not processed twice"
    - "Each provider connection is polled independently"
  artifacts:
    - path: "src/queue/workers/invoice-poll.worker.ts"
      provides: "Invoice poll worker processing scheduled jobs"
      contains: "invoice-poll"
    - path: "src/scheduler/jobs.ts"
      provides: "Scheduled job registration for invoice-poll"
      contains: "invoice-poll"
  key_links:
    - from: "src/queue/workers/invoice-poll.worker.ts"
      to: "src/services/greeninvoice/index.ts"
      via: "import and client creation"
      pattern: "createGreeninvoiceClient"
    - from: "src/queue/workers/invoice-poll.worker.ts"
      to: "src/services/icount/index.ts"
      via: "import and client creation"
      pattern: "createIcountClient"
    - from: "src/queue/workers/invoice-poll.worker.ts"
      to: "src/queue/queues.ts"
      via: "queue job addition"
      pattern: "reviewRequestQueue"
---

<objective>
Create hourly invoice polling worker that detects new invoices and schedules review requests.

Purpose: Poll Greeninvoice and iCount every hour to detect new invoices, then schedule 24-hour delayed review request jobs (per REVW-04: wait 24 hours after service).

Output: Invoice poll worker, review request queue, and scheduled job registration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-review-requests/06-RESEARCH.md
@.planning/phases/06-review-requests/06-01-PLAN.md
@src/queue/workers/review-poll.worker.ts
@src/scheduler/jobs.ts
@src/services/token-vault/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add review request queue</name>
  <files>src/queue/queues.ts, src/queue/index.ts</files>
  <action>
Add review request queue to queues.ts:

```typescript
// Add to existing queues.ts

/**
 * Review request queue for sending review request WhatsApp messages.
 * Jobs are delayed 24 hours from invoice detection (REVW-04).
 */
export const reviewRequestQueue = new Queue<ReviewRequestJobData>('review-requests', {
  ...defaultQueueOptions,
  connection: createRedisConnection(),
});

/**
 * Job data for review request jobs.
 */
export interface ReviewRequestJobData {
  reviewRequestId: string;
}
```

Add export to index.ts:
```typescript
export { reviewRequestQueue, type ReviewRequestJobData } from './queues';
```
  </action>
  <verify>
`npx tsc --noEmit` - queue compiles without errors.
  </verify>
  <done>
Review request queue exists and is exported from queue module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create invoice poll worker</name>
  <files>src/queue/workers/invoice-poll.worker.ts</files>
  <action>
Create worker that polls both Greeninvoice and iCount:

```typescript
import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { db } from '../../db/index';
import { accountingConnections, reviewRequests } from '../../db/schema/index';
import { eq, and } from 'drizzle-orm';
import { reviewRequestQueue } from '../queues';
import { getToken, decryptToken } from '../../services/token-vault/index';
import { createGreeninvoiceClient, fetchInvoices as fetchGreeninvoiceInvoices } from '../../services/greeninvoice/index';
import { createIcountClient, fetchInvoices as fetchIcountInvoices } from '../../services/icount/index';
import type { DetectedInvoice } from '../../services/greeninvoice/types';
import type { ScheduledJobData } from '../queues';

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Process invoice polling for a single accounting connection.
 */
async function pollConnection(
  connection: typeof accountingConnections.$inferSelect
): Promise<number> {
  // Get credentials from token vault
  const vaultEntry = await getToken(connection.credentialsVaultId);
  if (!vaultEntry) {
    throw new Error(`No credentials found for connection ${connection.id}`);
  }

  const credentials = JSON.parse(decryptToken(vaultEntry.encryptedValue));

  // Calculate from date (last poll or 7 days back for first poll)
  const fromDate = connection.lastInvoiceDate
    ? new Date(connection.lastInvoiceDate)
    : new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

  let invoices: DetectedInvoice[];

  if (connection.provider === 'greeninvoice') {
    const client = createGreeninvoiceClient(connection.tenantId, credentials);
    invoices = await fetchGreeninvoiceInvoices(client, fromDate);
  } else {
    // iCount - use single session per cycle
    const client = createIcountClient(credentials);
    try {
      await client.login();
      invoices = await fetchIcountInvoices(client, fromDate);
    } finally {
      await client.logout();
    }
  }

  let processedCount = 0;
  let latestInvoiceDate: Date | null = null;

  for (const invoice of invoices) {
    // Check if already processed (unique constraint will catch this too)
    const existing = await db.query.reviewRequests.findFirst({
      where: and(
        eq(reviewRequests.tenantId, connection.tenantId),
        eq(reviewRequests.source, connection.provider),
        eq(reviewRequests.invoiceId, invoice.invoiceId)
      ),
    });

    if (existing) {
      console.log(`[invoice-poll] Skipping duplicate: ${invoice.invoiceId}`);
      continue;
    }

    // Track latest invoice date
    const invoiceDate = new Date(invoice.createdAt);
    if (!latestInvoiceDate || invoiceDate > latestInvoiceDate) {
      latestInvoiceDate = invoiceDate;
    }

    // Check for customer phone (per research pitfall #3)
    if (!invoice.customerPhone) {
      console.log(`[invoice-poll] Skipping ${invoice.invoiceId} - no phone`);
      // Still record it to avoid re-processing
      await db.insert(reviewRequests).values({
        tenantId: connection.tenantId,
        source: connection.provider,
        invoiceId: invoice.invoiceId,
        invoiceNumber: invoice.invoiceNumber,
        customerName: invoice.customerName,
        customerEmail: invoice.customerEmail,
        status: 'skipped',
      });
      continue;
    }

    // Calculate scheduled time (24 hours from now per REVW-04)
    const scheduledForAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

    // Create review request record
    const [request] = await db.insert(reviewRequests).values({
      tenantId: connection.tenantId,
      source: connection.provider,
      invoiceId: invoice.invoiceId,
      invoiceNumber: invoice.invoiceNumber,
      customerPhone: invoice.customerPhone,
      customerName: invoice.customerName,
      customerEmail: invoice.customerEmail,
      status: 'pending',
      scheduledForAt,
    }).returning();

    // Schedule delayed job (24 hours)
    await reviewRequestQueue.add(
      'send-review-request',
      { reviewRequestId: request.id },
      {
        delay: 24 * 60 * 60 * 1000, // 24 hours
        jobId: `review-req-${request.id}`,
        removeOnComplete: true,
      }
    );

    console.log(
      `[invoice-poll] Scheduled review request for ${invoice.invoiceId} in 24h`
    );
    processedCount++;
  }

  // Update connection poll state
  await db.update(accountingConnections)
    .set({
      lastPollAt: new Date(),
      lastInvoiceDate: latestInvoiceDate || connection.lastInvoiceDate,
      lastError: null,
      updatedAt: new Date(),
    })
    .where(eq(accountingConnections.id, connection.id));

  return processedCount;
}

/**
 * Invoice poll worker - processes scheduled invoice-poll jobs.
 */
export function startInvoicePollWorker(): Worker<ScheduledJobData> {
  const worker = new Worker<ScheduledJobData>(
    'scheduled',
    async (job: Job<ScheduledJobData>) => {
      if (job.name !== 'invoice-poll') return;

      console.log('[invoice-poll] Starting hourly invoice check');

      // Get all active accounting connections
      const connections = await db.query.accountingConnections.findMany({
        where: eq(accountingConnections.status, 'active'),
      });

      console.log(`[invoice-poll] Checking ${connections.length} connections`);

      let totalProcessed = 0;

      for (const connection of connections) {
        try {
          const count = await pollConnection(connection);
          totalProcessed += count;

          // Rate limit between connections (per research: 100ms delay)
          await sleep(100);
        } catch (error) {
          console.error(
            `[invoice-poll] Error for ${connection.tenantId}/${connection.provider}:`,
            error
          );
          // Update connection with error (don't throw - continue to next)
          await db.update(accountingConnections)
            .set({
              lastError: String(error),
              updatedAt: new Date(),
            })
            .where(eq(accountingConnections.id, connection.id));
        }
      }

      console.log(
        `[invoice-poll] Completed. Processed ${totalProcessed} new invoices.`
      );
    },
    {
      connection: createRedisConnection(),
      concurrency: 1, // Single concurrency per research recommendation
    }
  );

  console.log('[invoice-poll] Worker started');
  return worker;
}
```

Key features:
- Polls both Greeninvoice and iCount connections
- 24-hour delayed job scheduling (REVW-04)
- Skips invoices without customer phone (pitfall #3)
- 100ms delay between connections (rate limiting)
- Single concurrency to respect API rate limits
- Error isolation per tenant (one failure doesn't stop others)
  </action>
  <verify>
`npx tsc --noEmit` - worker compiles without errors.
  </verify>
  <done>
Invoice poll worker exists with polling logic for both providers, 24-hour delayed job scheduling, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register scheduled job and export worker</name>
  <files>src/scheduler/jobs.ts, src/queue/workers/index.ts</files>
  <action>
Add invoice-poll job to scheduler/jobs.ts:

```typescript
// Add to existing registerScheduledJobs function

await scheduledQueue.add(
  'invoice-poll',
  {
    jobType: 'invoice-poll',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '15 * * * *', // Every hour at minute :15 (offset from review-check at :00)
    },
    jobId: 'invoice-poll-hourly',
  }
);
console.log('[scheduler] Registered: invoice-poll (hourly at :15)');
```

Add worker export to workers/index.ts or wherever workers are started:

```typescript
export { startInvoicePollWorker } from './invoice-poll.worker';
```

Note: The :15 minute offset spreads load - review-check runs at :00, invoice-poll at :15, and review-reminder at :30 (from Phase 5).
  </action>
  <verify>
- `npx tsc --noEmit` - scheduler compiles without errors
- Grep for 'invoice-poll' in jobs.ts shows registration
  </verify>
  <done>
Invoice poll job registered to run hourly at minute :15, worker exported for startup.
  </done>
</task>

</tasks>

<verification>
- [ ] src/queue/queues.ts has reviewRequestQueue
- [ ] src/queue/workers/invoice-poll.worker.ts exists
- [ ] src/scheduler/jobs.ts registers invoice-poll job
- [ ] Worker is exported from workers module
- [ ] TypeScript compiles without errors
- [ ] Job runs at :15 (offset from other hourly jobs)
</verification>

<success_criteria>
- Invoice poll worker processes both Greeninvoice and iCount connections
- New invoices create review request records with 'pending' status
- 24-hour delayed jobs are scheduled for each new invoice
- Invoices without customer phone are marked 'skipped'
- Errors are logged per connection but don't stop other connections
- Hourly job registered at :15 offset
</success_criteria>

<output>
After completion, create `.planning/phases/06-review-requests/06-04-SUMMARY.md`
</output>
