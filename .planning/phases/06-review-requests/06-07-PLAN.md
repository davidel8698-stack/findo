---
phase: 06-review-requests
plan: 07
type: execute
wave: 3
depends_on: ["06-01", "06-04", "06-05"]
files_modified:
  - src/queue/workers/review-poll.worker.ts
  - src/services/review-request/completion.ts
autonomous: true

must_haves:
  truths:
    - "When customer leaves review, pending review request is marked completed"
    - "Scheduled reminder job is cancelled when review detected"
    - "Review completion detection runs during existing review poll"
  artifacts:
    - path: "src/services/review-request/completion.ts"
      provides: "Review completion detection service"
      exports: ["checkReviewCompletion"]
  key_links:
    - from: "src/queue/workers/review-poll.worker.ts"
      to: "src/services/review-request/completion.ts"
      via: "import and call"
      pattern: "checkReviewCompletion"
    - from: "src/services/review-request/completion.ts"
      to: "src/db/schema/review-requests.ts"
      via: "database update"
      pattern: "reviewRequests"
---

<objective>
Add review completion detection to existing review poll worker.

Purpose: When a customer leaves a Google review, detect it during hourly review polling (Phase 5) and mark any pending review request as 'completed'. This prevents sending a reminder after the customer has already reviewed (per research pitfall #6).

Output: Completion detection service integrated into review poll worker.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-review-requests/06-RESEARCH.md
@src/queue/workers/review-poll.worker.ts
@src/db/schema/reviews.ts
@src/db/schema/review-requests.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create review completion detection service</name>
  <files>src/services/review-request/completion.ts</files>
  <action>
Create completion detection service:

```typescript
import { db } from '../../db/index';
import { reviewRequests, processedReviews } from '../../db/schema/index';
import { eq, and, inArray } from 'drizzle-orm';
import { reviewRequestQueue } from '../../queue/queues';

/**
 * Check if any pending review requests were completed by new reviews.
 *
 * Strategy: Match reviews to requests by phone number (last 4 digits in reviewer name)
 * or by detecting any new review within 48h of a pending request.
 *
 * This runs during the existing review-poll worker after new reviews are detected.
 *
 * @param tenantId - Tenant to check
 * @param newReviewIds - IDs of newly detected reviews
 */
export async function checkReviewCompletion(
  tenantId: string,
  newReviewIds: string[]
): Promise<number> {
  if (newReviewIds.length === 0) return 0;

  // Get pending review requests (status = 'pending' or 'requested')
  const pendingRequests = await db.query.reviewRequests.findMany({
    where: and(
      eq(reviewRequests.tenantId, tenantId),
      inArray(reviewRequests.status, ['pending', 'requested'])
    ),
  });

  if (pendingRequests.length === 0) return 0;

  // Get the new reviews
  const newReviews = await db.query.processedReviews.findMany({
    where: and(
      eq(processedReviews.tenantId, tenantId),
      inArray(processedReviews.id, newReviewIds)
    ),
  });

  let completedCount = 0;

  for (const review of newReviews) {
    // Try to match review to a pending request
    const matchedRequest = findMatchingRequest(review, pendingRequests);

    if (matchedRequest) {
      // Mark request as completed
      await db.update(reviewRequests)
        .set({
          status: 'completed',
          completedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(reviewRequests.id, matchedRequest.id));

      // Cancel scheduled reminder job if exists
      try {
        const reminderJobId = `review-reminder-${matchedRequest.id}`;
        const job = await reviewRequestQueue.getJob(reminderJobId);
        if (job) {
          await job.remove();
          console.log(
            `[review-completion] Cancelled reminder for ${matchedRequest.id}`
          );
        }
      } catch (error) {
        // Job may not exist or already completed
        console.warn(`[review-completion] Could not cancel reminder:`, error);
      }

      console.log(
        `[review-completion] Marked request ${matchedRequest.id} as completed`
      );
      completedCount++;

      // Remove from pending list to avoid double-matching
      const index = pendingRequests.indexOf(matchedRequest);
      if (index > -1) pendingRequests.splice(index, 1);
    }
  }

  return completedCount;
}

/**
 * Find a pending request that matches the review.
 *
 * Matching strategies:
 * 1. Phone number last 4 digits in reviewer name (some customers include phone)
 * 2. Review timestamp within 48h after request was sent (time-based correlation)
 * 3. Reviewer name matches customer name (fuzzy)
 *
 * @param review - The new review
 * @param pendingRequests - List of pending requests
 * @returns Matched request or null
 */
function findMatchingRequest(
  review: typeof processedReviews.$inferSelect,
  pendingRequests: (typeof reviewRequests.$inferSelect)[]
): (typeof reviewRequests.$inferSelect) | null {
  const reviewerName = review.reviewerName?.toLowerCase() || '';
  const reviewTime = review.createTime ? new Date(review.createTime) : new Date();

  for (const request of pendingRequests) {
    // Strategy 1: Check for phone digits in reviewer name
    if (request.customerPhone) {
      const lastFourDigits = request.customerPhone.replace(/\D/g, '').slice(-4);
      if (lastFourDigits && reviewerName.includes(lastFourDigits)) {
        return request;
      }
    }

    // Strategy 2: Time-based correlation
    // Review within 48h of request being sent = likely match
    if (request.requestedAt) {
      const requestTime = new Date(request.requestedAt);
      const hoursSinceRequest = (reviewTime.getTime() - requestTime.getTime()) / (1000 * 60 * 60);

      // Review came within 48 hours after request was sent
      if (hoursSinceRequest >= 0 && hoursSinceRequest <= 48) {
        return request;
      }
    }

    // Strategy 3: Name matching (fuzzy)
    if (request.customerName) {
      const customerName = request.customerName.toLowerCase();
      // Check if reviewer name contains customer first name
      const firstName = customerName.split(' ')[0];
      if (firstName.length >= 2 && reviewerName.includes(firstName)) {
        return request;
      }
    }
  }

  return null;
}

// Export for use in index
export { checkReviewCompletion };
```

Key features:
- Multiple matching strategies (phone digits, time correlation, name)
- Cancels scheduled reminder when review detected
- Removes matched requests from list to avoid double-matching
  </action>
  <verify>
`npx tsc --noEmit` - completion service compiles without errors.
  </verify>
  <done>
Completion detection service exists with matching logic and job cancellation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate completion check into review poll worker</name>
  <files>src/queue/workers/review-poll.worker.ts</files>
  <action>
Modify existing review poll worker to call completion check after detecting new reviews.

Add import at top of file:
```typescript
import { checkReviewCompletion } from '../../services/review-request/completion';
```

After the section where new reviews are inserted/processed, add:

```typescript
// Check if any pending review requests were completed by these new reviews
if (newReviewIds.length > 0) {
  const completedCount = await checkReviewCompletion(tenantId, newReviewIds);
  if (completedCount > 0) {
    console.log(
      `[review-poll] Marked ${completedCount} review requests as completed`
    );
  }
}
```

Where `newReviewIds` is an array of the IDs of reviews that were just processed.

The integration point is after reviews are detected and inserted, but before moving to the next tenant.
  </action>
  <verify>
- `npx tsc --noEmit` - worker compiles without errors
- Grep for 'checkReviewCompletion' in review-poll.worker.ts shows integration
  </verify>
  <done>
Review poll worker calls completion check after detecting new reviews.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export completion service from review-request module</name>
  <files>src/services/review-request/index.ts</files>
  <action>
Update the review-request service index to export completion:

```typescript
export * from './messages';
export * from './completion';
```
  </action>
  <verify>
`npx tsc --noEmit` - exports compile without errors.
  </verify>
  <done>
Completion service exported from review-request module.
  </done>
</task>

</tasks>

<verification>
- [ ] src/services/review-request/completion.ts exists
- [ ] checkReviewCompletion function has matching logic
- [ ] Scheduled reminder jobs are cancelled when review detected
- [ ] review-poll.worker.ts calls checkReviewCompletion
- [ ] src/services/review-request/index.ts exports completion
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
- New reviews trigger completion check for pending requests
- Matched requests are marked 'completed' with timestamp
- Scheduled reminder jobs are cancelled when customer reviews
- Multiple matching strategies catch most review-to-request correlations
- Integration doesn't break existing review poll worker
</success_criteria>

<output>
After completion, create `.planning/phases/06-review-requests/06-07-SUMMARY.md`
</output>
