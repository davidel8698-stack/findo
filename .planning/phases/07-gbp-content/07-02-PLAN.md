---
phase: 07-gbp-content
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/media/whatsapp-download.ts
  - src/services/media/image-validator.ts
  - src/services/google/media.ts
  - src/services/google/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "System can download photos from WhatsApp media URLs"
    - "System validates image quality (size, blur, format)"
    - "System can upload photos to GBP with correct category"
  artifacts:
    - path: "src/services/media/whatsapp-download.ts"
      provides: "WhatsApp media download service"
      exports: ["downloadWhatsAppMedia"]
    - path: "src/services/media/image-validator.ts"
      provides: "Image quality validation"
      exports: ["validateImage", "ImageValidationResult"]
    - path: "src/services/google/media.ts"
      provides: "GBP media upload service"
      exports: ["uploadPhotoFromUrl", "listPhotos"]
  key_links:
    - from: "whatsapp-download.ts"
      to: "Graph API"
      via: "fetch with access token"
      pattern: "graph\\.facebook\\.com.*mediaId"
    - from: "image-validator.ts"
      to: "sharp"
      via: "image processing"
      pattern: "sharp\\(buffer\\)"
    - from: "google/media.ts"
      to: "GBP API v4"
      via: "createAuthenticatedClient"
      pattern: "mybusiness\\.googleapis\\.com/v4.*media"
---

<objective>
Create the media services layer for downloading photos from WhatsApp, validating image quality, and uploading to Google Business Profile.

Purpose: These services form the core media pipeline. WhatsApp media URLs expire in 5 minutes, so immediate download is critical. Image validation prevents poor-quality uploads.
Output: Three service modules for the photo upload flow
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-gbp-content/07-RESEARCH.md
@src/services/google/reviews.ts
@src/services/google/oauth.ts
@src/services/whatsapp/send.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Dependencies and Create WhatsApp Media Download Service</name>
  <files>package.json, src/services/media/whatsapp-download.ts</files>
  <action>
1. Install sharp (image processing):
   ```bash
   pnpm add sharp
   pnpm add -D @types/sharp
   ```

2. Create `src/services/media/whatsapp-download.ts`:

```typescript
/**
 * WhatsApp Media Download Service
 *
 * Downloads media from WhatsApp Cloud API using two-step process:
 * 1. Get media URL from Graph API
 * 2. Download from lookaside URL (expires in 5 minutes!)
 *
 * CRITICAL: WhatsApp media URLs expire in 5 minutes. Always download
 * immediately when webhook received, never store the URL for later.
 */

const GRAPH_API_VERSION = 'v21.0';
const GRAPH_API_BASE = `https://graph.facebook.com/${GRAPH_API_VERSION}`;

export interface WhatsAppMediaMetadata {
  url: string;
  mime_type: string;
  sha256: string;
  file_size: number;
  id: string;
}

export interface DownloadedMedia {
  buffer: Buffer;
  mimeType: string;
  fileSize: number;
  mediaId: string;
}

/**
 * Get media metadata including download URL.
 * The URL expires in 5 minutes!
 */
export async function getMediaMetadata(
  mediaId: string,
  accessToken: string
): Promise<WhatsAppMediaMetadata> {
  const response = await fetch(`${GRAPH_API_BASE}/${mediaId}`, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
    },
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to get media metadata: ${response.status} ${error}`);
  }

  return response.json();
}

/**
 * Download media from WhatsApp.
 *
 * Two-step process:
 * 1. Get media URL from Graph API
 * 2. Download from lookaside URL with auth header
 *
 * @param mediaId - WhatsApp media ID from webhook
 * @param accessToken - WhatsApp access token
 * @returns Downloaded media buffer with metadata
 */
export async function downloadWhatsAppMedia(
  mediaId: string,
  accessToken: string
): Promise<DownloadedMedia> {
  // Step 1: Get the download URL
  const metadata = await getMediaMetadata(mediaId, accessToken);

  // Step 2: Download from lookaside URL (requires auth header)
  const mediaResponse = await fetch(metadata.url, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'User-Agent': 'Findo/1.0',
    },
  });

  if (!mediaResponse.ok) {
    throw new Error(`Failed to download media: ${mediaResponse.status}`);
  }

  const buffer = Buffer.from(await mediaResponse.arrayBuffer());

  return {
    buffer,
    mimeType: metadata.mime_type,
    fileSize: metadata.file_size,
    mediaId: metadata.id,
  };
}
```

Export from new index file `src/services/media/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>WhatsApp media download service exists with two-step download process</done>
</task>

<task type="auto">
  <name>Task 2: Create Image Validation Service</name>
  <files>src/services/media/image-validator.ts</files>
  <action>
Create `src/services/media/image-validator.ts`:

```typescript
/**
 * Image Validation Service
 *
 * Validates images before upload to GBP:
 * - Minimum dimensions: 250x250px (GBP requirement)
 * - Supported formats: JPEG, PNG, WebP
 * - Blur detection using Laplacian variance
 *
 * Per RESEARCH.md: Use sharp for all image processing.
 */

import sharp from 'sharp';

export interface ImageValidationResult {
  valid: boolean;
  reason?: string;
  width: number;
  height: number;
  format: string;
  sharpnessScore: number;
}

// Minimum dimensions for GBP
const MIN_DIMENSION = 250;
// Blur threshold (empirical, adjust based on feedback)
const BLUR_THRESHOLD = 50;
// Supported formats
const SUPPORTED_FORMATS = ['jpeg', 'png', 'webp'];

/**
 * Validate an image for GBP upload.
 *
 * Checks:
 * - Dimensions >= 250x250
 * - Format is JPEG, PNG, or WebP
 * - Image is not blurry (Laplacian variance)
 *
 * @param buffer - Image buffer
 * @returns Validation result with details
 */
export async function validateImage(buffer: Buffer): Promise<ImageValidationResult> {
  try {
    const image = sharp(buffer);
    const metadata = await image.metadata();

    // Check if we can read the image
    if (!metadata.width || !metadata.height) {
      return {
        valid: false,
        reason: 'Could not read image dimensions',
        width: 0,
        height: 0,
        format: '',
        sharpnessScore: 0,
      };
    }

    // Check dimensions
    if (metadata.width < MIN_DIMENSION || metadata.height < MIN_DIMENSION) {
      return {
        valid: false,
        reason: `התמונה קטנה מדי (${metadata.width}x${metadata.height}). צריך לפחות ${MIN_DIMENSION}x${MIN_DIMENSION}`,
        width: metadata.width,
        height: metadata.height,
        format: metadata.format || '',
        sharpnessScore: 0,
      };
    }

    // Check format
    const format = metadata.format || '';
    if (!SUPPORTED_FORMATS.includes(format)) {
      return {
        valid: false,
        reason: `פורמט לא נתמך: ${format}. נא לשלוח JPEG, PNG או WebP`,
        width: metadata.width,
        height: metadata.height,
        format,
        sharpnessScore: 0,
      };
    }

    // Blur detection using Laplacian variance
    // Apply Laplacian kernel and measure variance
    const stats = await image
      .greyscale()
      .convolve({
        width: 3,
        height: 3,
        kernel: [0, 1, 0, 1, -4, 1, 0, 1, 0], // Laplacian kernel
      })
      .stats();

    // Use standard deviation as sharpness indicator
    // Higher values = more edges = sharper image
    const sharpnessScore = stats.channels[0]?.stdev || 0;
    const isBlurry = sharpnessScore < BLUR_THRESHOLD;

    if (isBlurry) {
      return {
        valid: false,
        reason: 'התמונה נראית מטושטשת. נא לשלוח תמונה חדה יותר',
        width: metadata.width,
        height: metadata.height,
        format,
        sharpnessScore,
      };
    }

    return {
      valid: true,
      width: metadata.width,
      height: metadata.height,
      format,
      sharpnessScore,
    };
  } catch (error) {
    return {
      valid: false,
      reason: 'לא הצלחנו לקרוא את התמונה. נא לנסות שוב',
      width: 0,
      height: 0,
      format: '',
      sharpnessScore: 0,
    };
  }
}

/**
 * Prepare image for upload by optimizing and converting to JPEG.
 *
 * - Converts to JPEG (most compatible)
 * - Strips EXIF data for privacy
 * - Maintains orientation
 * - Quality 85 (good balance of size/quality)
 *
 * @param buffer - Original image buffer
 * @returns Optimized JPEG buffer
 */
export async function prepareImageForUpload(buffer: Buffer): Promise<Buffer> {
  return sharp(buffer)
    .rotate() // Auto-rotate based on EXIF orientation
    .jpeg({
      quality: 85,
      mozjpeg: true, // Better compression
    })
    .toBuffer();
}
```

Add to exports in `src/services/media/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Image validation service validates size, format, and blur detection with Hebrew error messages</done>
</task>

<task type="auto">
  <name>Task 3: Create GBP Media Upload Service</name>
  <files>src/services/google/media.ts, src/services/google/index.ts</files>
  <action>
Create `src/services/google/media.ts` following the pattern from reviews.ts:

```typescript
/**
 * Google Business Profile Media Service
 *
 * Upload and manage photos on GBP using My Business API v4.
 * Photos must be uploaded via public URL (sourceUrl).
 *
 * Per RESEARCH.md: Use direct HTTP like reviews.ts pattern.
 */

import { createAuthenticatedClient } from './oauth';

const GBP_API_BASE = 'https://mybusiness.googleapis.com/v4';

// GBP photo categories
export type PhotoCategory =
  | 'COVER'
  | 'PROFILE'
  | 'EXTERIOR'
  | 'INTERIOR'
  | 'PRODUCT'
  | 'AT_WORK'
  | 'FOOD_AND_DRINK'
  | 'MENU'
  | 'COMMON_AREA'
  | 'ROOMS'
  | 'TEAMS'
  | 'ADDITIONAL';

export interface GBPPhoto {
  mediaItemId: string;
  name: string;
  category: PhotoCategory;
  googleUrl?: string;
  thumbnailUrl?: string;
  createTime: string;
}

interface MediaCreateRequest {
  mediaFormat: 'PHOTO';
  locationAssociation: {
    category: PhotoCategory;
  };
  sourceUrl: string;
}

interface MediaApiResponse {
  name: string;
  mediaFormat?: string;
  googleUrl?: string;
  thumbnailUrl?: string;
  createTime?: string;
  locationAssociation?: {
    category?: string;
  };
}

interface ListMediaApiResponse {
  mediaItems?: MediaApiResponse[];
  nextPageToken?: string;
}

/**
 * Upload a photo to GBP from a public URL.
 *
 * The sourceUrl must be publicly accessible for Google to fetch.
 * Use S3 or similar with public read access.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param sourceUrl - Public URL of the image
 * @param category - Photo category
 * @returns Uploaded photo metadata
 */
export async function uploadPhotoFromUrl(
  tenantId: string,
  accountId: string,
  locationId: string,
  sourceUrl: string,
  category: PhotoCategory
): Promise<GBPPhoto> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}/media`;

  const body: MediaCreateRequest = {
    mediaFormat: 'PHOTO',
    locationAssociation: { category },
    sourceUrl,
  };

  const response = await client.request<MediaApiResponse>({
    url,
    method: 'POST',
    data: body,
  });

  return {
    mediaItemId: response.data.name?.split('/').pop() || '',
    name: response.data.name || '',
    category,
    googleUrl: response.data.googleUrl,
    thumbnailUrl: response.data.thumbnailUrl,
    createTime: response.data.createTime || new Date().toISOString(),
  };
}

/**
 * List photos for a location.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param pageToken - Pagination token
 * @returns List of photos
 */
export async function listPhotos(
  tenantId: string,
  accountId: string,
  locationId: string,
  pageToken?: string
): Promise<{ photos: GBPPhoto[]; nextPageToken?: string }> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const params = new URLSearchParams();
  if (pageToken) params.set('pageToken', pageToken);

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}/media?${params}`;

  const response = await client.request<ListMediaApiResponse>({ url });

  const photos = (response.data.mediaItems || []).map((item) => ({
    mediaItemId: item.name?.split('/').pop() || '',
    name: item.name || '',
    category: (item.locationAssociation?.category as PhotoCategory) || 'ADDITIONAL',
    googleUrl: item.googleUrl,
    thumbnailUrl: item.thumbnailUrl,
    createTime: item.createTime || '',
  }));

  return {
    photos,
    nextPageToken: response.data.nextPageToken,
  };
}

/**
 * Delete a photo from GBP.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param mediaItemId - Media item ID to delete
 */
export async function deletePhoto(
  tenantId: string,
  accountId: string,
  locationId: string,
  mediaItemId: string
): Promise<void> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}/media/${mediaItemId}`;

  await client.request({
    url,
    method: 'DELETE',
  });
}
```

Export from `src/services/google/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>GBP media service can upload photos from public URLs and list existing photos</done>
</task>

</tasks>

<verification>
1. sharp package installed in package.json
2. WhatsApp media download:
   - Gets metadata from Graph API
   - Downloads from lookaside URL with auth header
   - Returns buffer with mime type
3. Image validation:
   - Checks minimum 250x250 dimensions
   - Validates JPEG/PNG/WebP formats
   - Detects blur using Laplacian variance
   - Returns Hebrew error messages
4. GBP media service:
   - Uses direct HTTP to mybusiness.googleapis.com/v4
   - Follows reviews.ts pattern with createAuthenticatedClient
   - Supports upload, list, delete operations
</verification>

<success_criteria>
- All three services export correctly
- TypeScript compiles without errors
- Services follow established codebase patterns
- Error messages are in Hebrew for user-facing text
</success_criteria>

<output>
After completion, create `.planning/phases/07-gbp-content/07-02-SUMMARY.md`
</output>
