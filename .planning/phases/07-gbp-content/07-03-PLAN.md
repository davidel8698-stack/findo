---
phase: 07-gbp-content
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/queue/workers/photo-upload.worker.ts
  - src/queue/workers/whatsapp-message.worker.ts
  - src/services/gbp-content/photo-processor.ts
  - src/services/storage/r2.ts
  - src/services/storage/index.ts
autonomous: true
user_setup:
  - service: cloudflare-r2
    why: "Public photo storage for GBP upload"
    env_vars:
      - name: R2_ACCOUNT_ID
        source: "Cloudflare Dashboard -> R2 -> Overview -> Account ID"
      - name: R2_ACCESS_KEY_ID
        source: "Cloudflare Dashboard -> R2 -> Manage R2 API Tokens -> Create API Token"
      - name: R2_SECRET_ACCESS_KEY
        source: "Cloudflare Dashboard -> R2 -> Manage R2 API Tokens -> Create API Token"
      - name: R2_BUCKET_NAME
        source: "Create bucket named 'findo-photos' in R2 dashboard"
      - name: R2_PUBLIC_URL
        source: "Cloudflare Dashboard -> R2 -> findo-photos -> Settings -> Public access (enable and copy URL)"

must_haves:
  truths:
    - "Photos sent via WhatsApp are downloaded immediately"
    - "Invalid photos get friendly Hebrew rejection message"
    - "Valid photos are uploaded to R2 with public URL"
    - "Photos are uploaded to GBP within 24 hours"
    - "Owner confirms upload with category confirmation"
  artifacts:
    - path: "src/queue/workers/photo-upload.worker.ts"
      provides: "Photo upload processing worker"
      exports: ["photoUploadWorker"]
    - path: "src/services/gbp-content/photo-processor.ts"
      provides: "Photo processing orchestration"
      exports: ["processReceivedPhoto", "handleCategorySelection"]
    - path: "src/services/storage/r2.ts"
      provides: "Cloudflare R2 storage service"
      exports: ["uploadToR2", "getPublicUrl"]
  key_links:
    - from: "photo-processor.ts"
      to: "media/whatsapp-download.ts"
      via: "downloadWhatsAppMedia"
      pattern: "downloadWhatsAppMedia"
    - from: "photo-processor.ts"
      to: "media/image-validator.ts"
      via: "validateImage"
      pattern: "validateImage"
    - from: "photo-upload.worker.ts"
      to: "storage/r2.ts"
      via: "uploadToR2"
      pattern: "uploadToR2"
    - from: "photo-upload.worker.ts"
      to: "google/media.ts"
      via: "uploadPhotoFromUrl"
      pattern: "uploadPhotoFromUrl"
---

<objective>
Implement the photo upload flow that processes photos received via WhatsApp: download immediately, validate quality, ask for category confirmation, upload to R2 for public URL, and upload to GBP.

Purpose: Completes the photo collection pipeline. Per CONTEXT.md: download immediately (URLs expire in 5 min), ask owner to confirm category, upload within 24 hours, confirm successful upload.
Output: Photo processing service, R2 storage integration, and upload worker
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-gbp-content/07-CONTEXT.md
@.planning/phases/07-gbp-content/07-RESEARCH.md
@src/services/media/whatsapp-download.ts
@src/services/media/image-validator.ts
@src/services/google/media.ts
@src/queue/workers/whatsapp-message.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Photo Processor Service</name>
  <files>src/services/gbp-content/photo-processor.ts, src/services/gbp-content/index.ts</files>
  <action>
Create `src/services/gbp-content/photo-processor.ts`:

```typescript
/**
 * Photo Processor Service
 *
 * Orchestrates the photo collection flow:
 * 1. Download photo from WhatsApp immediately (URL expires in 5 min!)
 * 2. Validate image quality
 * 3. Ask owner to confirm category
 * 4. Queue for upload to GBP
 *
 * Per CONTEXT.md: Basic quality checks, ask for category, upload within 24h.
 */

import { downloadWhatsAppMedia, type DownloadedMedia } from '../media/whatsapp-download';
import { validateImage, prepareImageForUpload, type ImageValidationResult } from '../media/image-validator';
import { sendWhatsAppMessage } from '../whatsapp/send';
import { notificationsQueue } from '../../queue';
import { db } from '../../db';
import { photoRequests, gbpPhotos } from '../../db/schema';
import { eq, and, or } from 'drizzle-orm';
import type { PhotoCategory } from '../google/media';

// Simple category mapping for user-friendly Hebrew prompts
const CATEGORY_MAP: Record<string, PhotoCategory> = {
  'חנות': 'INTERIOR',
  'בית עסק': 'INTERIOR',
  'פנים': 'INTERIOR',
  'חוץ': 'EXTERIOR',
  'מבחוץ': 'EXTERIOR',
  'מוצר': 'PRODUCT',
  'מוצרים': 'PRODUCT',
  'צוות': 'TEAMS',
  'עובדים': 'TEAMS',
  'אוכל': 'FOOD_AND_DRINK',
  'מנה': 'FOOD_AND_DRINK',
  'תפריט': 'MENU',
  'עבודה': 'AT_WORK',
  'כללי': 'ADDITIONAL',
  'אחר': 'ADDITIONAL',
};

export interface ProcessedPhoto {
  mediaId: string;
  buffer: Buffer;
  validation: ImageValidationResult;
  tenantId: string;
  photoRequestId?: string;
}

// Temporary storage for photos pending category confirmation
// In production, use Redis or similar with TTL
const pendingPhotos = new Map<string, ProcessedPhoto>();

/**
 * Get ISO week number.
 * Used to match photos to weekly photo requests.
 */
export function getISOWeek(date: Date): { week: number; year: number } {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  const week = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
  return { week, year: d.getUTCFullYear() };
}

/**
 * Process a photo received from WhatsApp.
 *
 * Downloads immediately (critical - URL expires in 5 min!),
 * validates quality, and responds to owner.
 *
 * @param tenantId - Tenant UUID
 * @param mediaId - WhatsApp media ID
 * @param accessToken - WhatsApp access token
 * @param ownerPhone - Owner's phone number
 * @returns Processing result
 */
export async function processReceivedPhoto(
  tenantId: string,
  mediaId: string,
  accessToken: string,
  ownerPhone: string
): Promise<{ success: boolean; message: string }> {
  console.log(`[photo-processor] Processing photo ${mediaId} for tenant ${tenantId}`);

  try {
    // Step 1: Download immediately (URL expires in 5 minutes!)
    const downloaded = await downloadWhatsAppMedia(mediaId, accessToken);
    console.log(`[photo-processor] Downloaded ${downloaded.fileSize} bytes`);

    // Step 2: Validate image quality
    const validation = await validateImage(downloaded.buffer);

    if (!validation.valid) {
      // Send friendly rejection message in Hebrew
      await sendWhatsAppMessage(tenantId, ownerPhone, validation.reason || 'התמונה לא מתאימה');
      return { success: false, message: validation.reason || 'Validation failed' };
    }

    // Step 3: Find active photo request for this week
    const { week, year } = getISOWeek(new Date());
    const [activeRequest] = await db
      .select()
      .from(photoRequests)
      .where(
        and(
          eq(photoRequests.tenantId, tenantId),
          eq(photoRequests.week, week),
          eq(photoRequests.year, year),
          or(eq(photoRequests.status, 'sent'), eq(photoRequests.status, 'received'))
        )
      )
      .limit(1);

    // Step 4: Prepare image for upload
    const preparedBuffer = await prepareImageForUpload(downloaded.buffer);

    // Step 5: Store pending photo and ask for category
    const pendingKey = `${tenantId}:${mediaId}`;
    pendingPhotos.set(pendingKey, {
      mediaId,
      buffer: preparedBuffer,
      validation,
      tenantId,
      photoRequestId: activeRequest?.id,
    });

    // Ask for category in Hebrew
    await sendWhatsAppMessage(
      tenantId,
      ownerPhone,
      `תמונה מצוינת! זה נראה כמו:\n` +
      `1. חנות/בית עסק\n` +
      `2. מוצר\n` +
      `3. צוות\n` +
      `4. אוכל\n` +
      `5. אחר\n\n` +
      `שלח את המספר או תאר במילים`
    );

    // Update photo request status
    if (activeRequest) {
      await db
        .update(photoRequests)
        .set({
          status: 'received',
          receivedAt: new Date(),
          mediaIds: [...(activeRequest.mediaIds || []), mediaId],
          updatedAt: new Date(),
        })
        .where(eq(photoRequests.id, activeRequest.id));
    }

    return { success: true, message: 'Photo received, waiting for category' };
  } catch (error) {
    console.error(`[photo-processor] Error processing photo:`, error);
    await sendWhatsAppMessage(
      tenantId,
      ownerPhone,
      'לא הצלחנו לעבד את התמונה. נא לנסות שוב'
    );
    return { success: false, message: String(error) };
  }
}

/**
 * Handle category selection from owner.
 *
 * @param tenantId - Tenant UUID
 * @param mediaId - WhatsApp media ID of pending photo
 * @param categoryText - Category text from owner
 * @param ownerPhone - Owner's phone number
 * @returns Whether category was recognized and upload queued
 */
export async function handleCategorySelection(
  tenantId: string,
  mediaId: string,
  categoryText: string,
  ownerPhone: string
): Promise<boolean> {
  const pendingKey = `${tenantId}:${mediaId}`;
  const pendingPhoto = pendingPhotos.get(pendingKey);

  if (!pendingPhoto) {
    console.log(`[photo-processor] No pending photo for ${pendingKey}`);
    return false;
  }

  // Parse category
  const category = parseCategory(categoryText);

  // Queue for upload
  await notificationsQueue.add(
    'photo-upload',
    {
      tenantId,
      mediaId,
      category,
      buffer: pendingPhoto.buffer.toString('base64'),
      photoRequestId: pendingPhoto.photoRequestId,
    },
    {
      delay: 0, // Upload immediately, but batched via worker
      attempts: 3,
      backoff: { type: 'exponential', delay: 60000 },
    }
  );

  // Clean up pending
  pendingPhotos.delete(pendingKey);

  // Confirm to owner
  await sendWhatsAppMessage(
    tenantId,
    ownerPhone,
    'מעולה! התמונה בתהליך העלאה לגוגל. נעדכן אותך כשזה יסתיים.'
  );

  return true;
}

/**
 * Check if there's a pending photo for this tenant.
 * Used to detect category response context.
 */
export function hasPendingPhoto(tenantId: string): string | null {
  for (const [key, photo] of pendingPhotos.entries()) {
    if (photo.tenantId === tenantId) {
      return photo.mediaId;
    }
  }
  return null;
}

/**
 * Parse category from user text input.
 */
function parseCategory(text: string): PhotoCategory {
  const normalized = text.trim().toLowerCase();

  // Check for number selection
  const numberMap: Record<string, PhotoCategory> = {
    '1': 'INTERIOR',
    '2': 'PRODUCT',
    '3': 'TEAMS',
    '4': 'FOOD_AND_DRINK',
    '5': 'ADDITIONAL',
  };
  if (numberMap[normalized]) {
    return numberMap[normalized];
  }

  // Check for text match
  for (const [key, value] of Object.entries(CATEGORY_MAP)) {
    if (normalized.includes(key)) {
      return value;
    }
  }

  // Default to ADDITIONAL
  return 'ADDITIONAL';
}
```

Update `src/services/gbp-content/index.ts` to export:
```typescript
export * from './photo-processor';
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Photo processor downloads immediately, validates, asks for category, and queues upload</done>
</task>

<task type="auto">
  <name>Task 2: Create R2 Storage Service and Photo Upload Worker</name>
  <files>src/services/storage/r2.ts, src/services/storage/index.ts, src/queue/workers/photo-upload.worker.ts</files>
  <action>
1. Create `src/services/storage/r2.ts` for Cloudflare R2 (S3-compatible):

```typescript
/**
 * Cloudflare R2 Storage Service
 *
 * S3-compatible storage for photo uploads.
 * Provides public URLs for GBP media uploads.
 *
 * Requires env vars:
 * - R2_ACCOUNT_ID
 * - R2_ACCESS_KEY_ID
 * - R2_SECRET_ACCESS_KEY
 * - R2_BUCKET_NAME
 * - R2_PUBLIC_URL (the public access URL for the bucket)
 */

import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize S3-compatible client for R2
const r2Client = new S3Client({
  region: 'auto',
  endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID || '',
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY || '',
  },
});

const BUCKET_NAME = process.env.R2_BUCKET_NAME || 'findo-photos';
const PUBLIC_URL = process.env.R2_PUBLIC_URL || '';

export interface UploadResult {
  key: string;
  publicUrl: string;
}

/**
 * Upload a photo buffer to R2 storage.
 *
 * @param tenantId - Tenant UUID (used in path)
 * @param filename - Filename (e.g., mediaId.jpg)
 * @param buffer - Image buffer
 * @param contentType - MIME type (default: image/jpeg)
 * @returns Upload result with public URL
 */
export async function uploadToR2(
  tenantId: string,
  filename: string,
  buffer: Buffer,
  contentType: string = 'image/jpeg'
): Promise<UploadResult> {
  const key = `photos/${tenantId}/${filename}`;

  await r2Client.send(
    new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: key,
      Body: buffer,
      ContentType: contentType,
      CacheControl: 'public, max-age=31536000', // 1 year cache
    })
  );

  const publicUrl = getPublicUrl(key);
  console.log(`[r2] Uploaded ${key} -> ${publicUrl}`);

  return { key, publicUrl };
}

/**
 * Get the public URL for an R2 object.
 *
 * @param key - Object key in bucket
 * @returns Public URL
 */
export function getPublicUrl(key: string): string {
  if (!PUBLIC_URL) {
    throw new Error('R2_PUBLIC_URL environment variable not set');
  }
  // Ensure no double slashes
  const baseUrl = PUBLIC_URL.endsWith('/') ? PUBLIC_URL.slice(0, -1) : PUBLIC_URL;
  return `${baseUrl}/${key}`;
}

/**
 * Check if R2 is configured.
 */
export function isR2Configured(): boolean {
  return !!(
    process.env.R2_ACCOUNT_ID &&
    process.env.R2_ACCESS_KEY_ID &&
    process.env.R2_SECRET_ACCESS_KEY &&
    process.env.R2_BUCKET_NAME &&
    process.env.R2_PUBLIC_URL
  );
}
```

2. Create `src/services/storage/index.ts`:
```typescript
export * from './r2';
```

3. Create `src/queue/workers/photo-upload.worker.ts`:

```typescript
/**
 * Photo Upload Worker
 *
 * Processes photo upload jobs:
 * 1. Upload photo buffer to R2 storage (public URL)
 * 2. Upload to GBP via sourceUrl
 * 3. Notify owner of success
 *
 * Per CONTEXT.md: Upload within 24 hours, confirm with link.
 */

import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { uploadToR2, isR2Configured } from '../../services/storage/r2';
import { uploadPhotoFromUrl, type PhotoCategory } from '../../services/google/media';
import { sendWhatsAppMessage } from '../../services/whatsapp/send';
import { db } from '../../db';
import { gbpPhotos, photoRequests, tenants, googleConnections } from '../../db/schema';
import { eq, and } from 'drizzle-orm';

interface PhotoUploadJob {
  tenantId: string;
  mediaId: string;
  category: PhotoCategory;
  buffer: string; // Base64 encoded
  photoRequestId?: string;
}

export const photoUploadWorker = new Worker<PhotoUploadJob>(
  'notifications',
  async (job: Job<PhotoUploadJob>) => {
    if (job.name !== 'photo-upload') return;

    const { tenantId, mediaId, category, buffer, photoRequestId } = job.data;
    console.log(`[photo-upload] Processing upload for tenant ${tenantId}`);

    // Check R2 configuration
    if (!isR2Configured()) {
      throw new Error('R2 storage not configured. Set R2_ACCOUNT_ID, R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY, R2_BUCKET_NAME, R2_PUBLIC_URL');
    }

    try {
      // Get tenant and Google connection
      const [tenant] = await db
        .select()
        .from(tenants)
        .where(eq(tenants.id, tenantId))
        .limit(1);

      if (!tenant) {
        throw new Error(`Tenant ${tenantId} not found`);
      }

      const [googleConn] = await db
        .select()
        .from(googleConnections)
        .where(and(
          eq(googleConnections.tenantId, tenantId),
          eq(googleConnections.isActive, true)
        ))
        .limit(1);

      if (!googleConn) {
        throw new Error(`No active Google connection for tenant ${tenantId}`);
      }

      // Convert base64 to buffer
      const imageBuffer = Buffer.from(buffer, 'base64');

      // Upload to R2 storage
      const filename = `${mediaId}.jpg`;
      const { publicUrl } = await uploadToR2(tenantId, filename, imageBuffer);
      console.log(`[photo-upload] Uploaded to R2: ${publicUrl}`);

      // Upload to GBP
      const gbpPhoto = await uploadPhotoFromUrl(
        tenantId,
        googleConn.accountId,
        googleConn.locationId,
        publicUrl,
        category
      );

      console.log(`[photo-upload] Uploaded to GBP: ${gbpPhoto.mediaItemId}`);

      // Record in database
      await db.insert(gbpPhotos).values({
        id: crypto.randomUUID(),
        tenantId,
        photoRequestId: photoRequestId || null,
        mediaItemId: gbpPhoto.mediaItemId,
        category,
        sourceUrl: publicUrl,
        status: 'processing', // GBP takes 24-48h to process
        uploadedAt: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Update photo request if linked
      if (photoRequestId) {
        const [request] = await db
          .select()
          .from(photoRequests)
          .where(eq(photoRequests.id, photoRequestId))
          .limit(1);

        if (request) {
          await db
            .update(photoRequests)
            .set({
              status: 'uploaded',
              uploadedAt: new Date(),
              gbpMediaIds: [...(request.gbpMediaIds || []), gbpPhoto.mediaItemId],
              updatedAt: new Date(),
            })
            .where(eq(photoRequests.id, photoRequestId));
        }
      }

      // Notify owner
      if (tenant.ownerPhone) {
        await sendWhatsAppMessage(
          tenantId,
          tenant.ownerPhone,
          `התמונה עלתה לגוגל! יכול לקחת 24-48 שעות עד שתופיע בפרופיל.\n` +
          `תודה שאתה שומר על הפרופיל מעודכן!`
        );
      }

    } catch (error) {
      console.error(`[photo-upload] Error:`, error);

      // Notify owner of failure
      const [tenant] = await db
        .select()
        .from(tenants)
        .where(eq(tenants.id, tenantId))
        .limit(1);

      if (tenant?.ownerPhone) {
        await sendWhatsAppMessage(
          tenantId,
          tenant.ownerPhone,
          'לא הצלחנו להעלות את התמונה לגוגל. נסה שוב מאוחר יותר או פנה לתמיכה.'
        );
      }

      throw error; // Re-throw for retry
    }
  },
  {
    connection: createRedisConnection(),
    concurrency: 3,
  }
);

photoUploadWorker.on('completed', (job) => {
  console.log(`[photo-upload] Job ${job.id} completed`);
});

photoUploadWorker.on('failed', (job, err) => {
  console.error(`[photo-upload] Job ${job?.id} failed:`, err.message);
});
```

4. Install AWS SDK for S3 (R2 is S3-compatible):
```bash
pnpm add @aws-sdk/client-s3
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit` and R2 service exports correctly</verify>
  <done>R2 storage service uploads photos to Cloudflare R2 with public URLs, worker processes queue and uploads to GBP</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Photo Handler with WhatsApp Message Processing</name>
  <files>src/queue/workers/whatsapp-message.worker.ts</files>
  <action>
Update `src/queue/workers/whatsapp-message.worker.ts` to handle image messages from owners:

**Location:** Add photo handling AFTER the review response check (line ~247) and BEFORE the lead conversation check (line ~254). This ensures photos are handled with higher priority than lead chatbot.

1. Add imports at the top of the file (after line 21):
```typescript
import { processReceivedPhoto, handleCategorySelection, hasPendingPhoto, getISOWeek } from '../../services/gbp-content/photo-processor';
import { photoRequests } from '../../db/schema';
import { or } from 'drizzle-orm';
```

2. Add photo handling inside the message processing loop. Insert AFTER `if (handledAsReviewResponse)` block (around line 248) and BEFORE `if (!handledAsReviewResponse)` lead conversation check:

```typescript
      // 1.7 Check if this is a photo from owner (after review response, before lead chatbot)
      // Photos have higher priority than lead chatbot when there's an active photo request
      let handledAsPhotoResponse = false;

      if (isOwner && !handledAsReviewResponse) {
        // Check for image message
        if (message.type === 'image' && message.mediaId) {
          // Check if we're expecting photos (active photo request this week)
          const { week, year } = getISOWeek(new Date());
          const [activePhotoRequest] = await db
            .select()
            .from(photoRequests)
            .where(
              and(
                eq(photoRequests.tenantId, tenantId),
                eq(photoRequests.week, week),
                eq(photoRequests.year, year),
                // Accept photos if sent or already received (multi-photo)
                or(eq(photoRequests.status, 'sent'), eq(photoRequests.status, 'received'))
              )
            )
            .limit(1);

          if (activePhotoRequest) {
            console.log(`[whatsapp-message] Owner sent image with active photo request`);

            // Get WhatsApp access token for media download
            const waConnection = await db.query.whatsappConnections.findFirst({
              where: eq(whatsappConnections.tenantId, tenantId),
            });

            if (waConnection?.accessToken) {
              await processReceivedPhoto(
                tenantId,
                message.mediaId,
                waConnection.accessToken,
                message.from
              );
              handledAsPhotoResponse = true;
              console.log(`[whatsapp-message] Processed as photo for GBP`);
            }
          }
        }

        // Check for category response (short text after sending photo)
        // Pattern: single digit 1-5 or short Hebrew word
        if (!handledAsPhotoResponse && message.type === 'text' && message.text) {
          const text = message.text.trim();
          const isCategoryResponse = /^[1-5]$/.test(text) ||
            ['חנות', 'מוצר', 'צוות', 'אוכל', 'אחר', 'פנים', 'חוץ'].some(cat =>
              text.toLowerCase().includes(cat)
            );

          if (isCategoryResponse) {
            const pendingMediaId = hasPendingPhoto(tenantId);
            if (pendingMediaId) {
              const handled = await handleCategorySelection(
                tenantId,
                pendingMediaId,
                text,
                message.from
              );
              if (handled) {
                handledAsPhotoResponse = true;
                console.log(`[whatsapp-message] Processed as photo category selection`);
              }
            }
          }
        }
      }

      // 1.8 Check if this is part of a lead conversation (skip if already handled)
      if (!handledAsReviewResponse && !handledAsPhotoResponse) {
```

3. Update the existing lead conversation check to use the new condition. Find line ~254 and change:
```typescript
      // OLD:
      if (!handledAsReviewResponse) {
        const leadConvo = await db.query.leadConversations.findFirst({

      // NEW:
      if (!handledAsReviewResponse && !handledAsPhotoResponse) {
        const leadConvo = await db.query.leadConversations.findFirst({
```

4. Add comment documenting message processing priority at top of processWhatsAppMessages function:
```typescript
/**
 * Message Processing Priority (owner messages):
 * 1. Review approval responses (button clicks, text replies)
 * 2. Photo responses (images when photo request active)
 * 3. Photo category selection (1-5 or Hebrew category words)
 * 4. Hours responses (DD/MM: format - handled by plan 07-06)
 * 5. Lead chatbot flow (fallback for non-owner messages)
 */
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Grep confirms integration: `grep -n "processReceivedPhoto\|handleCategorySelection" src/queue/workers/whatsapp-message.worker.ts` shows imports and usage
3. Grep confirms priority order: `grep -n "handledAsPhotoResponse" src/queue/workers/whatsapp-message.worker.ts` shows photo handling before lead chatbot
  </verify>
  <done>WhatsApp message handler routes image messages from owners to photo processor when photo request is active, handles category selection, and skips lead chatbot for photo flows</done>
</task>

</tasks>

<verification>
1. Photo processor:
   - Downloads immediately from WhatsApp
   - Validates with sharp
   - Sends Hebrew rejection messages for invalid photos
   - Asks for category with numbered options
   - Queues valid photos for upload
2. R2 storage service:
   - Uploads to Cloudflare R2 (S3-compatible)
   - Returns public URL for GBP
   - Validates configuration on startup
3. Photo upload worker:
   - Processes jobs from notifications queue
   - Uploads to R2 first, then GBP via public URL
   - Records in gbpPhotos table
   - Updates photoRequests status
   - Notifies owner of success/failure in Hebrew
4. Message handler integration:
   - Detects image messages from owners
   - Only processes when photo request is active
   - Routes to photo processor before lead chatbot
   - Handles category selection responses
</verification>

<success_criteria>
- Photos received via WhatsApp are downloaded immediately
- Invalid photos receive friendly Hebrew rejection message
- Valid photos trigger category selection prompt
- Category response queues photo for R2 + GBP upload
- Upload worker processes, stores in R2, uploads to GBP
- Owner notified of success
- Photo handling doesn't interfere with lead chatbot (only for owners with active requests)
</success_criteria>

<output>
After completion, create `.planning/phases/07-gbp-content/07-03-SUMMARY.md`
</output>
