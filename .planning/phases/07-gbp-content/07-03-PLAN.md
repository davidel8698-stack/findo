---
phase: 07-gbp-content
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/queue/workers/photo-upload.worker.ts
  - src/services/whatsapp/message-handler.ts
  - src/services/gbp-content/photo-processor.ts
autonomous: true

must_haves:
  truths:
    - "Photos sent via WhatsApp are downloaded immediately"
    - "Invalid photos get friendly Hebrew rejection message"
    - "Valid photos are uploaded to GBP within 24 hours"
    - "Owner confirms upload with category confirmation"
  artifacts:
    - path: "src/queue/workers/photo-upload.worker.ts"
      provides: "Photo upload processing worker"
      exports: ["photoUploadWorker"]
    - path: "src/services/gbp-content/photo-processor.ts"
      provides: "Photo processing orchestration"
      exports: ["processReceivedPhoto", "askForCategory"]
  key_links:
    - from: "photo-processor.ts"
      to: "media/whatsapp-download.ts"
      via: "downloadWhatsAppMedia"
      pattern: "downloadWhatsAppMedia"
    - from: "photo-processor.ts"
      to: "media/image-validator.ts"
      via: "validateImage"
      pattern: "validateImage"
    - from: "photo-upload.worker.ts"
      to: "google/media.ts"
      via: "uploadPhotoFromUrl"
      pattern: "uploadPhotoFromUrl"
---

<objective>
Implement the photo upload flow that processes photos received via WhatsApp: download immediately, validate quality, ask for category confirmation, and upload to GBP.

Purpose: Completes the photo collection pipeline. Per CONTEXT.md: download immediately (URLs expire in 5 min), ask owner to confirm category, upload within 24 hours, confirm successful upload.
Output: Photo processing service and upload worker
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-gbp-content/07-CONTEXT.md
@.planning/phases/07-gbp-content/07-RESEARCH.md
@src/services/media/whatsapp-download.ts
@src/services/media/image-validator.ts
@src/services/google/media.ts
@src/services/whatsapp/message-handler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Photo Processor Service</name>
  <files>src/services/gbp-content/photo-processor.ts, src/services/gbp-content/index.ts</files>
  <action>
Create `src/services/gbp-content/photo-processor.ts`:

```typescript
/**
 * Photo Processor Service
 *
 * Orchestrates the photo collection flow:
 * 1. Download photo from WhatsApp immediately (URL expires in 5 min!)
 * 2. Validate image quality
 * 3. Ask owner to confirm category
 * 4. Queue for upload to GBP
 *
 * Per CONTEXT.md: Basic quality checks, ask for category, upload within 24h.
 */

import { downloadWhatsAppMedia, type DownloadedMedia } from '../media/whatsapp-download';
import { validateImage, prepareImageForUpload, type ImageValidationResult } from '../media/image-validator';
import { sendWhatsAppMessage } from '../whatsapp/send';
import { notificationsQueue } from '../../queue';
import { db } from '../../db';
import { photoRequests, gbpPhotos } from '../../db/schema';
import { eq, and, isNull } from 'drizzle-orm';
import type { PhotoCategory } from '../google/media';

// Simple category mapping for user-friendly Hebrew prompts
const CATEGORY_MAP: Record<string, PhotoCategory> = {
  'חנות': 'INTERIOR',
  'בית עסק': 'INTERIOR',
  'פנים': 'INTERIOR',
  'חוץ': 'EXTERIOR',
  'מבחוץ': 'EXTERIOR',
  'מוצר': 'PRODUCT',
  'מוצרים': 'PRODUCT',
  'צוות': 'TEAMS',
  'עובדים': 'TEAMS',
  'אוכל': 'FOOD_AND_DRINK',
  'מנה': 'FOOD_AND_DRINK',
  'תפריט': 'MENU',
  'עבודה': 'AT_WORK',
  'כללי': 'ADDITIONAL',
  'אחר': 'ADDITIONAL',
};

export interface ProcessedPhoto {
  mediaId: string;
  buffer: Buffer;
  validation: ImageValidationResult;
  tenantId: string;
  photoRequestId?: string;
}

// Temporary storage for photos pending category confirmation
// In production, use Redis or similar with TTL
const pendingPhotos = new Map<string, ProcessedPhoto>();

/**
 * Process a photo received from WhatsApp.
 *
 * Downloads immediately (critical - URL expires in 5 min!),
 * validates quality, and responds to owner.
 *
 * @param tenantId - Tenant UUID
 * @param mediaId - WhatsApp media ID
 * @param accessToken - WhatsApp access token
 * @param ownerPhone - Owner's phone number
 * @returns Processing result
 */
export async function processReceivedPhoto(
  tenantId: string,
  mediaId: string,
  accessToken: string,
  ownerPhone: string
): Promise<{ success: boolean; message: string }> {
  console.log(`[photo-processor] Processing photo ${mediaId} for tenant ${tenantId}`);

  try {
    // Step 1: Download immediately (URL expires in 5 minutes!)
    const downloaded = await downloadWhatsAppMedia(mediaId, accessToken);
    console.log(`[photo-processor] Downloaded ${downloaded.fileSize} bytes`);

    // Step 2: Validate image quality
    const validation = await validateImage(downloaded.buffer);

    if (!validation.valid) {
      // Send friendly rejection message in Hebrew
      await sendWhatsAppMessage(tenantId, ownerPhone, validation.reason || 'התמונה לא מתאימה');
      return { success: false, message: validation.reason || 'Validation failed' };
    }

    // Step 3: Find active photo request for this week
    const { week, year } = getISOWeek(new Date());
    const [activeRequest] = await db
      .select()
      .from(photoRequests)
      .where(
        and(
          eq(photoRequests.tenantId, tenantId),
          eq(photoRequests.week, week),
          eq(photoRequests.year, year),
          eq(photoRequests.status, 'sent')
        )
      )
      .limit(1);

    // Step 4: Prepare image for upload
    const preparedBuffer = await prepareImageForUpload(downloaded.buffer);

    // Step 5: Store pending photo and ask for category
    const pendingKey = `${tenantId}:${mediaId}`;
    pendingPhotos.set(pendingKey, {
      mediaId,
      buffer: preparedBuffer,
      validation,
      tenantId,
      photoRequestId: activeRequest?.id,
    });

    // Ask for category in Hebrew
    await sendWhatsAppMessage(
      tenantId,
      ownerPhone,
      `תמונה מצוינת! זה נראה כמו:\n` +
      `1. חנות/בית עסק\n` +
      `2. מוצר\n` +
      `3. צוות\n` +
      `4. אוכל\n` +
      `5. אחר\n\n` +
      `שלח את המספר או תאר במילים`
    );

    // Update photo request status
    if (activeRequest) {
      await db
        .update(photoRequests)
        .set({
          status: 'received',
          receivedAt: new Date(),
          mediaIds: [...(activeRequest.mediaIds || []), mediaId],
          updatedAt: new Date(),
        })
        .where(eq(photoRequests.id, activeRequest.id));
    }

    return { success: true, message: 'Photo received, waiting for category' };
  } catch (error) {
    console.error(`[photo-processor] Error processing photo:`, error);
    await sendWhatsAppMessage(
      tenantId,
      ownerPhone,
      'לא הצלחנו לעבד את התמונה. נא לנסות שוב'
    );
    return { success: false, message: String(error) };
  }
}

/**
 * Handle category selection from owner.
 *
 * @param tenantId - Tenant UUID
 * @param mediaId - WhatsApp media ID of pending photo
 * @param categoryText - Category text from owner
 * @param ownerPhone - Owner's phone number
 * @returns Whether category was recognized and upload queued
 */
export async function handleCategorySelection(
  tenantId: string,
  mediaId: string,
  categoryText: string,
  ownerPhone: string
): Promise<boolean> {
  const pendingKey = `${tenantId}:${mediaId}`;
  const pendingPhoto = pendingPhotos.get(pendingKey);

  if (!pendingPhoto) {
    console.log(`[photo-processor] No pending photo for ${pendingKey}`);
    return false;
  }

  // Parse category
  const category = parseCategory(categoryText);

  // Queue for upload
  await notificationsQueue.add(
    'photo-upload',
    {
      tenantId,
      mediaId,
      category,
      buffer: pendingPhoto.buffer.toString('base64'),
      photoRequestId: pendingPhoto.photoRequestId,
    },
    {
      delay: 0, // Upload immediately, but batched via worker
      attempts: 3,
      backoff: { type: 'exponential', delay: 60000 },
    }
  );

  // Clean up pending
  pendingPhotos.delete(pendingKey);

  // Confirm to owner
  await sendWhatsAppMessage(
    tenantId,
    ownerPhone,
    'מעולה! התמונה בתהליך העלאה לגוגל. נעדכן אותך כשזה יסתיים.'
  );

  return true;
}

/**
 * Parse category from user text input.
 */
function parseCategory(text: string): PhotoCategory {
  const normalized = text.trim().toLowerCase();

  // Check for number selection
  const numberMap: Record<string, PhotoCategory> = {
    '1': 'INTERIOR',
    '2': 'PRODUCT',
    '3': 'TEAMS',
    '4': 'FOOD_AND_DRINK',
    '5': 'ADDITIONAL',
  };
  if (numberMap[normalized]) {
    return numberMap[normalized];
  }

  // Check for text match
  for (const [key, value] of Object.entries(CATEGORY_MAP)) {
    if (normalized.includes(key)) {
      return value;
    }
  }

  // Default to ADDITIONAL
  return 'ADDITIONAL';
}

/**
 * Get ISO week number.
 */
function getISOWeek(date: Date): { week: number; year: number } {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  const week = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
  return { week, year: d.getUTCFullYear() };
}
```

Create `src/services/gbp-content/index.ts` to export.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Photo processor downloads immediately, validates, asks for category, and queues upload</done>
</task>

<task type="auto">
  <name>Task 2: Create Photo Upload Worker</name>
  <files>src/queue/workers/photo-upload.worker.ts</files>
  <action>
Create `src/queue/workers/photo-upload.worker.ts`:

```typescript
/**
 * Photo Upload Worker
 *
 * Processes photo upload jobs:
 * 1. Upload photo buffer to cloud storage (public URL)
 * 2. Upload to GBP via sourceUrl
 * 3. Notify owner of success
 *
 * Per CONTEXT.md: Upload within 24 hours, confirm with link.
 */

import { Worker, Job } from 'bullmq';
import { redis } from '../redis';
import { uploadPhotoFromUrl, type PhotoCategory } from '../../services/google/media';
import { sendWhatsAppMessage } from '../../services/whatsapp/send';
import { db } from '../../db';
import { gbpPhotos, photoRequests, tenants, googleConnections } from '../../db/schema';
import { eq, and } from 'drizzle-orm';

interface PhotoUploadJob {
  tenantId: string;
  mediaId: string;
  category: PhotoCategory;
  buffer: string; // Base64 encoded
  photoRequestId?: string;
}

/**
 * Upload photo to a temporary public URL.
 *
 * TODO: In production, use S3/GCS with presigned URLs.
 * For now, using a simple data URL approach (works for small images).
 *
 * Note: GBP requires a publicly accessible URL. This is a placeholder
 * implementation - replace with actual cloud storage in production.
 */
async function uploadToPublicStorage(
  tenantId: string,
  mediaId: string,
  buffer: Buffer
): Promise<string> {
  // TODO: Implement actual cloud storage upload
  // For now, we'll throw an error indicating this needs implementation
  // In production:
  // 1. Upload to S3/GCS with public-read ACL
  // 2. Return the public URL
  // Example: return `https://storage.findo.co.il/photos/${tenantId}/${mediaId}.jpg`;

  throw new Error('Cloud storage upload not implemented. See TODO in photo-upload.worker.ts');
}

export const photoUploadWorker = new Worker<PhotoUploadJob>(
  'notifications',
  async (job: Job<PhotoUploadJob>) => {
    if (job.name !== 'photo-upload') return;

    const { tenantId, mediaId, category, buffer, photoRequestId } = job.data;
    console.log(`[photo-upload] Processing upload for tenant ${tenantId}`);

    try {
      // Get tenant and Google connection
      const [tenant] = await db
        .select()
        .from(tenants)
        .where(eq(tenants.id, tenantId))
        .limit(1);

      if (!tenant) {
        throw new Error(`Tenant ${tenantId} not found`);
      }

      const [googleConn] = await db
        .select()
        .from(googleConnections)
        .where(and(
          eq(googleConnections.tenantId, tenantId),
          eq(googleConnections.isActive, true)
        ))
        .limit(1);

      if (!googleConn) {
        throw new Error(`No active Google connection for tenant ${tenantId}`);
      }

      // Convert base64 to buffer
      const imageBuffer = Buffer.from(buffer, 'base64');

      // Upload to public storage
      const publicUrl = await uploadToPublicStorage(tenantId, mediaId, imageBuffer);

      // Upload to GBP
      const gbpPhoto = await uploadPhotoFromUrl(
        tenantId,
        googleConn.accountId,
        googleConn.locationId,
        publicUrl,
        category
      );

      console.log(`[photo-upload] Uploaded to GBP: ${gbpPhoto.mediaItemId}`);

      // Record in database
      await db.insert(gbpPhotos).values({
        id: crypto.randomUUID(),
        tenantId,
        photoRequestId: photoRequestId || null,
        mediaItemId: gbpPhoto.mediaItemId,
        category,
        sourceUrl: publicUrl,
        status: 'processing', // GBP takes 24-48h to process
        uploadedAt: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Update photo request if linked
      if (photoRequestId) {
        const [request] = await db
          .select()
          .from(photoRequests)
          .where(eq(photoRequests.id, photoRequestId))
          .limit(1);

        if (request) {
          await db
            .update(photoRequests)
            .set({
              status: 'uploaded',
              uploadedAt: new Date(),
              gbpMediaIds: [...(request.gbpMediaIds || []), gbpPhoto.mediaItemId],
              updatedAt: new Date(),
            })
            .where(eq(photoRequests.id, photoRequestId));
        }
      }

      // Notify owner
      if (tenant.ownerPhone) {
        await sendWhatsAppMessage(
          tenantId,
          tenant.ownerPhone,
          `התמונה עלתה לגוגל! יכול לקחת 24-48 שעות עד שתופיע בפרופיל.\n` +
          `תודה שאתה שומר על הפרופיל מעודכן!`
        );
      }

    } catch (error) {
      console.error(`[photo-upload] Error:`, error);

      // Notify owner of failure
      const [tenant] = await db
        .select()
        .from(tenants)
        .where(eq(tenants.id, tenantId))
        .limit(1);

      if (tenant?.ownerPhone) {
        await sendWhatsAppMessage(
          tenantId,
          tenant.ownerPhone,
          'לא הצלחנו להעלות את התמונה לגוגל. נסה שוב מאוחר יותר או פנה לתמיכה.'
        );
      }

      throw error; // Re-throw for retry
    }
  },
  {
    connection: redis,
    concurrency: 3,
  }
);

photoUploadWorker.on('completed', (job) => {
  console.log(`[photo-upload] Job ${job.id} completed`);
});

photoUploadWorker.on('failed', (job, err) => {
  console.error(`[photo-upload] Job ${job?.id} failed:`, err.message);
});
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Photo upload worker processes queued photos and uploads to GBP</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Photo Handler with WhatsApp Message Processing</name>
  <files>src/services/whatsapp/message-handler.ts</files>
  <action>
Update `src/services/whatsapp/message-handler.ts` to handle image messages:

1. Add image message detection in the message processing flow:
   - Check if message type is 'image'
   - If tenant has active photo request (status='sent' or 'received'), process as photo response

2. Add photo processing integration:
```typescript
import { processReceivedPhoto, handleCategorySelection } from '../gbp-content/photo-processor';

// In message handler, after detecting image message:
if (message.type === 'image' && message.image?.id) {
  // Check if we're expecting photos (active photo request)
  const { week, year } = getISOWeek(new Date());
  const [activeRequest] = await db
    .select()
    .from(photoRequests)
    .where(
      and(
        eq(photoRequests.tenantId, tenantId),
        eq(photoRequests.week, week),
        eq(photoRequests.year, year),
        // Accept photos if sent or already received (multi-photo)
        or(eq(photoRequests.status, 'sent'), eq(photoRequests.status, 'received'))
      )
    )
    .limit(1);

  if (activeRequest) {
    // Process the photo
    const accessToken = await getWhatsAppAccessToken(tenantId);
    await processReceivedPhoto(tenantId, message.image.id, accessToken, senderPhone);
    return; // Photo handled, don't process as text
  }
}
```

3. Add category response detection:
   - After sending category prompt, track that we're waiting for category
   - When text message received, check if it's a category response
   - Use simple heuristics: short message (1-2 words or single digit)

4. Store pending photo context in conversation or separate tracking.

Note: This builds on existing message handler patterns. Don't break existing chatbot/lead flows - photo handling should be a separate branch.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>WhatsApp message handler routes image messages to photo processor when photo request is active</done>
</task>

</tasks>

<verification>
1. Photo processor:
   - Downloads immediately from WhatsApp
   - Validates with sharp
   - Sends Hebrew rejection messages for invalid photos
   - Asks for category with numbered options
   - Queues valid photos for upload
2. Photo upload worker:
   - Processes jobs from notifications queue
   - Uploads to GBP via public URL
   - Records in gbpPhotos table
   - Updates photoRequests status
   - Notifies owner of success/failure in Hebrew
3. Message handler integration:
   - Detects image messages
   - Routes to photo processor when photo request active
   - Handles category selection responses
</verification>

<success_criteria>
- Photos received via WhatsApp are downloaded immediately
- Invalid photos receive friendly Hebrew rejection message
- Valid photos trigger category selection prompt
- Category response queues photo for upload
- Upload worker processes and notifies owner
</success_criteria>

<output>
After completion, create `.planning/phases/07-gbp-content/07-03-SUMMARY.md`
</output>
