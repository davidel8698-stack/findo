---
phase: 07-gbp-content
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/gbp-content.ts
  - src/services/google/posts.ts
  - src/services/google/index.ts
  - src/queue/workers/monthly-post.worker.ts
  - src/scheduler/jobs.ts
autonomous: true

must_haves:
  truths:
    - "Owner receives monthly WhatsApp asking about promotional post"
    - "GBP posts can be created via API"
    - "Post requests track status through approval flow"
  artifacts:
    - path: "src/db/schema/gbp-content.ts"
      provides: "Post requests tracking table"
      contains: "postRequests"
    - path: "src/services/google/posts.ts"
      provides: "GBP local posts service"
      exports: ["createPost", "listPosts"]
    - path: "src/queue/workers/monthly-post.worker.ts"
      provides: "Monthly post request worker"
      exports: ["monthlyPostWorker"]
  key_links:
    - from: "google/posts.ts"
      to: "GBP API v4"
      via: "createAuthenticatedClient"
      pattern: "mybusiness\\.googleapis\\.com/v4.*localPosts"
    - from: "monthly-post.worker.ts"
      to: "whatsapp/send.ts"
      via: "sendWhatsAppMessage"
      pattern: "sendWhatsAppMessage"
---

<objective>
Create the database schema for promotional post tracking, implement the GBP posts API service, and build the monthly post request worker that initiates the promotional post flow.

Purpose: Enables the monthly promotional post feature. Per CONTEXT.md: monthly request asking if owner wants AI to create a post, with explanation of why fresh posts matter.
Output: Posts schema, GBP posts service, monthly worker
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-gbp-content/07-CONTEXT.md
@.planning/phases/07-gbp-content/07-RESEARCH.md
@src/services/google/reviews.ts
@src/db/schema/gbp-content.ts
@src/scheduler/jobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Schema with Post Requests Table</name>
  <files>src/db/schema/gbp-content.ts</files>
  <action>
Add to `src/db/schema/gbp-content.ts`:

```typescript
/**
 * Post Requests Table
 *
 * Tracks monthly promotional post request flow:
 * 1. Initial request sent to owner
 * 2. Owner provides content OR requests AI generation
 * 3. AI generates draft (if requested)
 * 4. Owner approves/edits
 * 5. Post published to GBP
 *
 * Per CONTEXT.md: Reminder sequence if no response, safe auto-publish as last resort.
 */

export const postRequestStatusEnum = pgEnum('post_request_status', [
  'requested',      // Initial WhatsApp sent
  'owner_content',  // Owner provided their content
  'ai_generating',  // AI is generating draft
  'pending_approval', // Draft ready, waiting for owner
  'approved',       // Owner approved, ready to publish
  'published',      // Posted to GBP
  'skipped',        // Owner declined, no post this month
  'auto_published', // Published safe content without approval
]);

export const postTypeEnum = pgEnum('post_type', [
  'STANDARD',  // General update
  'EVENT',     // Event announcement
  'OFFER',     // Special offer/promotion
]);

export const postRequests = pgTable('post_requests', {
  id: uuid('id').primaryKey().defaultRandom(),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id),
  status: postRequestStatusEnum('status').notNull().default('requested'),
  month: integer('month').notNull(), // 1-12
  year: integer('year').notNull(),

  // Content
  ownerContent: text('owner_content'), // Owner-provided text
  aiDraft: text('ai_draft'), // AI-generated draft
  finalContent: text('final_content'), // Approved content to publish
  postType: postTypeEnum('post_type').default('STANDARD'),
  callToActionType: text('call_to_action_type'), // LEARN_MORE, BOOK, ORDER, etc.
  callToActionUrl: text('call_to_action_url'),
  imageUrl: text('image_url'), // Optional image URL

  // Tracking
  requestedAt: timestamp('requested_at'),
  reminder1SentAt: timestamp('reminder1_sent_at'),
  reminder2SentAt: timestamp('reminder2_sent_at'),
  draftSentAt: timestamp('draft_sent_at'),
  approvedAt: timestamp('approved_at'),
  publishedAt: timestamp('published_at'),

  // GBP result
  gbpPostId: text('gbp_post_id'),
  gbpPostState: text('gbp_post_state'), // LIVE, PROCESSING, REJECTED

  // Metadata
  isSafeContent: boolean('is_safe_content').default(false), // True if auto-publishable
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(),
  deletedAt: timestamp('deleted_at'),
});

// Unique constraint: one request per month
// Add index for (tenantId, month, year)
```

Export the new table and enums.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>postRequests table exists with full status lifecycle and content fields</done>
</task>

<task type="auto">
  <name>Task 2: Create GBP Posts Service</name>
  <files>src/services/google/posts.ts, src/services/google/index.ts</files>
  <action>
Create `src/services/google/posts.ts` following reviews.ts pattern:

```typescript
/**
 * Google Business Profile Posts Service
 *
 * Create and manage local posts on GBP using My Business API v4.
 *
 * Per RESEARCH.md:
 * - Posts cannot contain phone numbers (Google rejects)
 * - Max 1500 chars, ideal 100-300
 * - Single media item per post (image)
 */

import { createAuthenticatedClient } from './oauth';

const GBP_API_BASE = 'https://mybusiness.googleapis.com/v4';

export type PostTopicType = 'STANDARD' | 'EVENT' | 'OFFER';
export type CallToActionType = 'BOOK' | 'ORDER' | 'SHOP' | 'LEARN_MORE' | 'SIGN_UP' | 'CALL';
export type PostState = 'LIVE' | 'PROCESSING' | 'REJECTED';

export interface LocalPost {
  postId: string;
  name: string;
  summary: string;
  topicType: PostTopicType;
  state: PostState;
  callToAction?: {
    actionType: CallToActionType;
    url: string;
  };
  media?: {
    sourceUrl: string;
    mediaFormat: 'PHOTO';
  };
  createTime: string;
  updateTime: string;
}

export interface CreatePostInput {
  summary: string;
  topicType?: PostTopicType;
  callToAction?: {
    actionType: CallToActionType;
    url: string;
  };
  mediaUrl?: string; // Optional image URL
}

interface PostApiResponse {
  name?: string;
  languageCode?: string;
  summary?: string;
  topicType?: string;
  state?: string;
  callToAction?: {
    actionType?: string;
    url?: string;
  };
  media?: Array<{
    sourceUrl?: string;
    mediaFormat?: string;
  }>;
  createTime?: string;
  updateTime?: string;
}

interface ListPostsApiResponse {
  localPosts?: PostApiResponse[];
  nextPageToken?: string;
}

// Phone number regex for validation
const PHONE_REGEX = /\d{2,3}[-.\s]?\d{7}|\d{10}/;

/**
 * Create a local post on GBP.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param post - Post content
 * @returns Created post with state
 */
export async function createPost(
  tenantId: string,
  accountId: string,
  locationId: string,
  post: CreatePostInput
): Promise<LocalPost> {
  // Validate: No phone numbers (Google rejects these)
  if (PHONE_REGEX.test(post.summary)) {
    throw new Error('Posts cannot contain phone numbers per Google policy');
  }

  // Validate: Max 1500 chars
  if (post.summary.length > 1500) {
    throw new Error(`Post exceeds 1500 character limit (${post.summary.length} chars)`);
  }

  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}/localPosts`;

  const body: Record<string, unknown> = {
    languageCode: 'he', // Hebrew
    summary: post.summary,
    topicType: post.topicType || 'STANDARD',
  };

  if (post.callToAction) {
    body.callToAction = post.callToAction;
  }

  if (post.mediaUrl) {
    body.media = [{
      mediaFormat: 'PHOTO',
      sourceUrl: post.mediaUrl,
    }];
  }

  const response = await client.request<PostApiResponse>({
    url,
    method: 'POST',
    data: body,
  });

  return mapPost(response.data);
}

/**
 * List local posts for a location.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param pageToken - Pagination token
 * @returns List of posts
 */
export async function listPosts(
  tenantId: string,
  accountId: string,
  locationId: string,
  pageToken?: string
): Promise<{ posts: LocalPost[]; nextPageToken?: string }> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const params = new URLSearchParams();
  if (pageToken) params.set('pageToken', pageToken);

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}/localPosts?${params}`;

  const response = await client.request<ListPostsApiResponse>({ url });

  const posts = (response.data.localPosts || []).map(mapPost);

  return {
    posts,
    nextPageToken: response.data.nextPageToken,
  };
}

/**
 * Delete a local post.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param postId - Post ID to delete
 */
export async function deletePost(
  tenantId: string,
  accountId: string,
  locationId: string,
  postId: string
): Promise<void> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}/localPosts/${postId}`;

  await client.request({
    url,
    method: 'DELETE',
  });
}

/**
 * Map API response to LocalPost type.
 */
function mapPost(data: PostApiResponse): LocalPost {
  return {
    postId: data.name?.split('/').pop() || '',
    name: data.name || '',
    summary: data.summary || '',
    topicType: (data.topicType as PostTopicType) || 'STANDARD',
    state: (data.state as PostState) || 'PROCESSING',
    callToAction: data.callToAction?.actionType
      ? {
          actionType: data.callToAction.actionType as CallToActionType,
          url: data.callToAction.url || '',
        }
      : undefined,
    media: data.media?.[0]
      ? {
          sourceUrl: data.media[0].sourceUrl || '',
          mediaFormat: 'PHOTO',
        }
      : undefined,
    createTime: data.createTime || '',
    updateTime: data.updateTime || '',
  };
}
```

Export from `src/services/google/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>GBP posts service can create, list, and delete local posts</done>
</task>

<task type="auto">
  <name>Task 3: Create Monthly Post Request Worker</name>
  <files>src/queue/workers/monthly-post.worker.ts, src/scheduler/jobs.ts</files>
  <action>
Create `src/queue/workers/monthly-post.worker.ts`:

```typescript
/**
 * Monthly Post Request Worker
 *
 * Sends monthly WhatsApp to owners asking about promotional posts.
 * Runs on the 1st of each month.
 *
 * Per CONTEXT.md:
 * - Include compelling explanation of why fresh posts matter
 * - Owner can provide content or request AI generation
 * - Reminder sequence if no response
 */

import { Worker, Job } from 'bullmq';
import { redis } from '../redis';
import { db } from '../../db';
import { tenants, googleConnections, whatsappConnections, postRequests } from '../../db/schema';
import { eq, and, isNull } from 'drizzle-orm';
import { sendWhatsAppMessage } from '../../services/whatsapp/send';

interface MonthlyPostJobData {
  jobType: 'monthly-post';
}

/**
 * Get current month/year for tracking.
 */
function getCurrentMonth(): { month: number; year: number } {
  const now = new Date();
  return {
    month: now.getMonth() + 1, // 1-12
    year: now.getFullYear(),
  };
}

export const monthlyPostWorker = new Worker<MonthlyPostJobData>(
  'scheduled',
  async (job: Job<MonthlyPostJobData>) => {
    if (job.data.jobType !== 'monthly-post') return;

    console.log('[monthly-post] Starting monthly post request cycle');
    const { month, year } = getCurrentMonth();

    // Get all active tenants with both Google and WhatsApp connections
    const activeTenants = await db
      .select({
        tenant: tenants,
        google: googleConnections,
        whatsapp: whatsappConnections,
      })
      .from(tenants)
      .innerJoin(googleConnections, and(
        eq(googleConnections.tenantId, tenants.id),
        eq(googleConnections.isActive, true)
      ))
      .innerJoin(whatsappConnections, and(
        eq(whatsappConnections.tenantId, tenants.id),
        eq(whatsappConnections.isActive, true)
      ))
      .where(and(
        eq(tenants.status, 'active'),
        isNull(tenants.deletedAt)
      ));

    console.log(`[monthly-post] Found ${activeTenants.length} eligible tenants`);

    let sent = 0;
    let skipped = 0;

    for (const { tenant, google } of activeTenants) {
      try {
        // Check if request already exists for this month
        const [existing] = await db
          .select()
          .from(postRequests)
          .where(and(
            eq(postRequests.tenantId, tenant.id),
            eq(postRequests.month, month),
            eq(postRequests.year, year),
            isNull(postRequests.deletedAt)
          ))
          .limit(1);

        if (existing) {
          console.log(`[monthly-post] Skipping ${tenant.id} - already requested this month`);
          skipped++;
          continue;
        }

        // Send WhatsApp with compelling explanation
        const message =
          `היי! הגיע הזמן לפוסט חודשי בגוגל.\n\n` +
          `למה זה חשוב?\n` +
          `- עסקים עם פוסטים פעילים מקבלים 35% יותר צפיות בגוגל\n` +
          `- לקוחות רואים שהעסק פעיל ומעודכן\n` +
          `- זה עוזר לדירוג בחיפוש המקומי\n\n` +
          `מה תרצה לעשות?\n` +
          `1. שלח לי טקסט והכנתי פוסט ממנו\n` +
          `2. שלח "AI" ואני אכין משהו מעולה בשבילך\n` +
          `3. שלח "דלג" אם לא הפעם`;

        if (tenant.ownerPhone) {
          await sendWhatsAppMessage(tenant.id, tenant.ownerPhone, message);

          // Create post request record
          await db.insert(postRequests).values({
            id: crypto.randomUUID(),
            tenantId: tenant.id,
            status: 'requested',
            month,
            year,
            requestedAt: new Date(),
            createdAt: new Date(),
            updatedAt: new Date(),
          });

          sent++;
          console.log(`[monthly-post] Sent request to ${tenant.id}`);
        }

        // Rate limit: 100ms between tenants
        await new Promise(resolve => setTimeout(resolve, 100));

      } catch (error) {
        console.error(`[monthly-post] Error for tenant ${tenant.id}:`, error);
        // Continue with other tenants
      }
    }

    console.log(`[monthly-post] Completed: ${sent} sent, ${skipped} skipped`);
  },
  {
    connection: redis,
    concurrency: 1, // Single concurrency for monthly job
  }
);

monthlyPostWorker.on('completed', (job) => {
  console.log(`[monthly-post] Job ${job.id} completed`);
});

monthlyPostWorker.on('failed', (job, err) => {
  console.error(`[monthly-post] Job ${job?.id} failed:`, err.message);
});
```

Update `src/scheduler/jobs.ts` to add monthly post job:

```typescript
// Monthly post request - 1st of each month at 10:00 AM Israel
await scheduledQueue.add(
  'monthly-post',
  {
    jobType: 'monthly-post',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '0 10 1 * *', // 1st of month at 10:00 AM
      tz: 'Asia/Jerusalem',
    },
    jobId: 'monthly-post',
  }
);
console.log('[scheduler] Scheduled monthly post request (1st of month 10:00 AM Israel)');
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Monthly post worker sends requests with compelling explanation, creates tracking records</done>
</task>

</tasks>

<verification>
1. Schema extended with postRequests table:
   - Full status lifecycle (requested -> approved -> published)
   - Content fields (owner, AI draft, final)
   - Reminder tracking timestamps
   - GBP result tracking
2. GBP posts service:
   - Creates posts with phone number validation
   - Character limit validation (1500 max)
   - Supports optional images and CTAs
   - Uses direct HTTP to v4 API
3. Monthly worker:
   - Runs on 1st of month at 10:00 AM
   - Sends compelling WhatsApp with statistics
   - Creates postRequests records
   - Handles idempotency via month/year check
</verification>

<success_criteria>
- postRequests table tracks the full post lifecycle
- GBP posts service can create posts with validation
- Monthly worker sends requests with clear options
- Job scheduled for 1st of each month
</success_criteria>

<output>
After completion, create `.planning/phases/07-gbp-content/07-04-SUMMARY.md`
</output>
