---
phase: 07-gbp-content
plan: 05
type: execute
wave: 2
depends_on: ["07-04"]
files_modified:
  - src/services/gbp-content/post-generator.ts
  - src/queue/workers/post-approval.worker.ts
  - src/services/whatsapp/message-handler.ts
  - src/scheduler/jobs.ts
autonomous: true

must_haves:
  truths:
    - "AI can generate promotional post content in Hebrew"
    - "Owner can approve or edit AI-generated drafts"
    - "Approved posts are published to GBP"
    - "Safe content auto-publishes if owner doesn't respond"
  artifacts:
    - path: "src/services/gbp-content/post-generator.ts"
      provides: "AI post content generation"
      exports: ["generatePostContent", "PostContent"]
    - path: "src/queue/workers/post-approval.worker.ts"
      provides: "Post approval and publishing workflow"
      exports: ["postApprovalWorker"]
  key_links:
    - from: "post-generator.ts"
      to: "anthropic"
      via: "Claude API"
      pattern: "anthropic\\.beta\\.messages\\.create"
    - from: "post-approval.worker.ts"
      to: "google/posts.ts"
      via: "createPost"
      pattern: "createPost"
---

<objective>
Implement AI-powered post content generation and the post approval workflow that handles owner responses, reminders, and auto-publishing.

Purpose: Completes the promotional post feature. Per CONTEXT.md: Owner can edit/approve AI content, reminder sequence if no response, safe auto-publish as last resort.
Output: AI generator, approval workflow, message handler integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-gbp-content/07-CONTEXT.md
@.planning/phases/07-gbp-content/07-RESEARCH.md
@src/services/review-management/reply-generator.ts
@src/services/google/posts.ts
@src/db/schema/gbp-content.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI Post Generator Service</name>
  <files>src/services/gbp-content/post-generator.ts</files>
  <action>
Create `src/services/gbp-content/post-generator.ts`:

```typescript
/**
 * AI Post Content Generator
 *
 * Generates promotional post content using Claude Haiku 4.5.
 * Follows the same pattern as reply-generator.ts.
 *
 * Per CONTEXT.md:
 * - Safe content = general updates, seasonal, behind-the-scenes (NOT promotions)
 * - Owner can provide content or request AI generation
 * - AI prompt must forbid phone numbers (Google rejects)
 */

import Anthropic from '@anthropic-ai/sdk';
import type { CallToActionType, PostTopicType } from '../google/posts';

const anthropic = new Anthropic();

export interface PostContent {
  summary: string;
  topicType: PostTopicType;
  callToActionType: CallToActionType | null;
  isSafe: boolean; // Safe = can auto-publish without owner approval
}

export interface GeneratePostOptions {
  businessName: string;
  businessType: string;
  ownerContent?: string; // If owner provided text
  recentActivity?: string; // Any recent activity to mention
  forceSafe?: boolean; // Force safe content (for auto-publish)
}

/**
 * Generate promotional post content.
 *
 * @param options - Generation options
 * @returns Generated post content
 */
export async function generatePostContent(
  options: GeneratePostOptions
): Promise<PostContent> {
  const { businessName, businessType, ownerContent, recentActivity, forceSafe } = options;

  const prompt = ownerContent
    ? buildOwnerContentPrompt(businessName, businessType, ownerContent)
    : buildAIGenerationPrompt(businessName, businessType, recentActivity, forceSafe);

  try {
    const response = await anthropic.beta.messages.create({
      model: 'claude-haiku-4-5-20251001',
      max_tokens: 512,
      betas: ['structured-outputs-2025-11-13'],
      messages: [{ role: 'user', content: prompt }],
      // @ts-expect-error - structured outputs beta
      output_format: {
        type: 'json_schema',
        schema: {
          type: 'object',
          properties: {
            summary: { type: 'string' },
            topicType: {
              type: 'string',
              enum: ['STANDARD', 'EVENT', 'OFFER'],
            },
            callToActionType: {
              type: ['string', 'null'],
              enum: ['LEARN_MORE', 'BOOK', 'ORDER', 'SHOP', 'SIGN_UP', 'CALL', null],
            },
            isSafe: { type: 'boolean' },
          },
          required: ['summary', 'topicType', 'callToActionType', 'isSafe'],
          additionalProperties: false,
        },
      },
    });

    const content = response.content[0];
    if (content.type !== 'text') {
      throw new Error('Unexpected response type');
    }

    const result = JSON.parse(content.text) as PostContent;

    // Validate no phone numbers
    if (/\d{2,3}[-.\s]?\d{7}|\d{10}/.test(result.summary)) {
      console.warn('[post-generator] AI included phone number, regenerating...');
      // Try once more with explicit reminder
      return generatePostContent({ ...options, forceSafe: true });
    }

    return result;

  } catch (error) {
    console.error('[post-generator] AI generation failed:', error);
    // Return safe fallback
    return getSafeFallback(businessName);
  }
}

/**
 * Build prompt for AI-only generation.
 */
function buildAIGenerationPrompt(
  businessName: string,
  businessType: string,
  recentActivity?: string,
  forceSafe?: boolean
): string {
  const safeInstruction = forceSafe
    ? `IMPORTANT: Generate ONLY safe content - general updates, seasonal greetings, or customer appreciation. NO promotions, NO specific offers, NO discounts.`
    : `If appropriate, you may include a subtle promotion, but prefer safe content (updates, greetings) that doesn't commit the business to specific offers.`;

  return `Generate a Google Business Profile post for a business.

Business Name: ${businessName}
Business Type: ${businessType}
Recent Activity: ${recentActivity || 'none'}

Requirements:
- Write in Hebrew
- 100-200 characters (ideal length for GBP engagement)
- Engaging, friendly tone
- NO phone numbers anywhere (Google strictly rejects these - CRITICAL!)
- NO email addresses
${safeInstruction}

Content types by safety:
- SAFE (isSafe=true): seasonal greetings, customer appreciation, quality commitment, behind-the-scenes, general updates
- NOT SAFE (isSafe=false): specific discounts, limited-time offers, sales promotions

Return JSON with:
- summary: The post text in Hebrew
- topicType: "STANDARD" for updates, "EVENT" for events, "OFFER" for promotions
- callToActionType: "LEARN_MORE", "BOOK", "ORDER", "SHOP", "SIGN_UP", "CALL", or null
- isSafe: true if content is general/seasonal (can auto-publish), false if contains specific promotions`;
}

/**
 * Build prompt when owner provided content.
 */
function buildOwnerContentPrompt(
  businessName: string,
  businessType: string,
  ownerContent: string
): string {
  return `Convert the owner's content into a polished Google Business Profile post.

Business Name: ${businessName}
Business Type: ${businessType}
Owner's Input: "${ownerContent}"

Requirements:
- Write in Hebrew (keep owner's tone if in Hebrew, translate if in English)
- 100-200 characters (condense if needed)
- Keep the owner's message intent
- Professional but friendly tone
- NO phone numbers (remove if present - Google rejects)
- NO email addresses (remove if present)

Return JSON with:
- summary: The polished post text in Hebrew
- topicType: "STANDARD" for updates, "EVENT" for events, "OFFER" for promotions
- callToActionType: "LEARN_MORE", "BOOK", "ORDER", "SHOP", "SIGN_UP", "CALL", or null (based on content)
- isSafe: true if content is general (no specific promotions), false if contains specific offers`;
}

/**
 * Safe fallback content.
 */
function getSafeFallback(businessName: string): PostContent {
  const fallbacks = [
    `תודה שאתם איתנו! ${businessName} מזמין אתכם להמשיך ליהנות משירות מעולה.`,
    `שבוע טוב מ${businessName}! תודה על האמון והתמיכה.`,
    `אנחנו ב${businessName} כאן בשבילכם - מוזמנים לפנות בכל שאלה.`,
  ];

  return {
    summary: fallbacks[Math.floor(Math.random() * fallbacks.length)],
    topicType: 'STANDARD',
    callToActionType: null,
    isSafe: true,
  };
}

/**
 * Generate safe content specifically for auto-publishing.
 * Used when owner doesn't respond after all reminders.
 */
export async function generateSafeAutoContent(
  businessName: string,
  businessType: string
): Promise<PostContent> {
  return generatePostContent({
    businessName,
    businessType,
    forceSafe: true, // Force safe content
  });
}
```

Export from `src/services/gbp-content/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>AI post generator creates Hebrew content with safe/promotion distinction</done>
</task>

<task type="auto">
  <name>Task 2: Create Post Approval Worker</name>
  <files>src/queue/workers/post-approval.worker.ts, src/scheduler/jobs.ts</files>
  <action>
Create `src/queue/workers/post-approval.worker.ts`:

```typescript
/**
 * Post Approval Worker
 *
 * Handles:
 * 1. post-generate: Generate AI draft and send to owner
 * 2. post-publish: Publish approved post to GBP
 * 3. post-reminder: Send reminders, auto-publish if no response
 *
 * Per CONTEXT.md reminder sequence:
 * 1. Initial request (monthly-post.worker)
 * 2. Reminders (multiple)
 * 3. AI creates safe content, sends for approval
 * 4. If still no response: publish safe content only
 */

import { Worker, Job } from 'bullmq';
import { redis } from '../redis';
import { db } from '../../db';
import { tenants, googleConnections, postRequests } from '../../db/schema';
import { eq, and, isNull, lt } from 'drizzle-orm';
import { sendWhatsAppMessage } from '../../services/whatsapp/send';
import { generatePostContent, generateSafeAutoContent } from '../../services/gbp-content/post-generator';
import { createPost } from '../../services/google/posts';

type PostJobData =
  | { jobType: 'post-generate'; tenantId: string; postRequestId: string; ownerContent?: string }
  | { jobType: 'post-publish'; tenantId: string; postRequestId: string }
  | { jobType: 'post-reminder' };

// Reminder intervals (days from initial request)
const REMINDER_1_DAYS = 3;
const REMINDER_2_DAYS = 7;
const AUTO_PUBLISH_DAYS = 10;

export const postApprovalWorker = new Worker<PostJobData>(
  'notifications',
  async (job: Job<PostJobData>) => {
    const { jobType } = job.data;

    switch (jobType) {
      case 'post-generate':
        await handleGenerate(job.data);
        break;
      case 'post-publish':
        await handlePublish(job.data);
        break;
      case 'post-reminder':
        await handleReminders();
        break;
    }
  },
  {
    connection: redis,
    concurrency: 3,
  }
);

/**
 * Generate AI draft and send to owner for approval.
 */
async function handleGenerate(data: { tenantId: string; postRequestId: string; ownerContent?: string }) {
  const { tenantId, postRequestId, ownerContent } = data;
  console.log(`[post-approval] Generating draft for ${postRequestId}`);

  const [tenant] = await db.select().from(tenants).where(eq(tenants.id, tenantId)).limit(1);
  if (!tenant) throw new Error(`Tenant ${tenantId} not found`);

  const [request] = await db.select().from(postRequests).where(eq(postRequests.id, postRequestId)).limit(1);
  if (!request) throw new Error(`Post request ${postRequestId} not found`);

  // Generate content
  const generated = await generatePostContent({
    businessName: tenant.businessName,
    businessType: tenant.businessType || 'business',
    ownerContent,
  });

  // Update request with draft
  await db
    .update(postRequests)
    .set({
      status: 'pending_approval',
      aiDraft: generated.summary,
      postType: generated.topicType,
      callToActionType: generated.callToActionType,
      isSafeContent: generated.isSafe,
      draftSentAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(postRequests.id, postRequestId));

  // Send draft to owner
  if (tenant.ownerPhone) {
    const message =
      `הנה הטיוטה לפוסט החודשי:\n\n` +
      `"${generated.summary}"\n\n` +
      `מה אומר?\n` +
      `1. שלח "אשר" לפרסום\n` +
      `2. שלח טקסט חדש לשינוי\n` +
      `3. שלח "דלג" לביטול`;

    await sendWhatsAppMessage(tenantId, tenant.ownerPhone, message);
  }

  console.log(`[post-approval] Draft sent for ${postRequestId}`);
}

/**
 * Publish approved post to GBP.
 */
async function handlePublish(data: { tenantId: string; postRequestId: string }) {
  const { tenantId, postRequestId } = data;
  console.log(`[post-approval] Publishing post ${postRequestId}`);

  const [tenant] = await db.select().from(tenants).where(eq(tenants.id, tenantId)).limit(1);
  if (!tenant) throw new Error(`Tenant ${tenantId} not found`);

  const [request] = await db.select().from(postRequests).where(eq(postRequests.id, postRequestId)).limit(1);
  if (!request) throw new Error(`Post request ${postRequestId} not found`);

  const [google] = await db
    .select()
    .from(googleConnections)
    .where(and(eq(googleConnections.tenantId, tenantId), eq(googleConnections.isActive, true)))
    .limit(1);

  if (!google) throw new Error(`No active Google connection for ${tenantId}`);

  const content = request.finalContent || request.aiDraft;
  if (!content) throw new Error('No content to publish');

  // Publish to GBP
  const post = await createPost(tenantId, google.accountId, google.locationId, {
    summary: content,
    topicType: (request.postType as 'STANDARD' | 'EVENT' | 'OFFER') || 'STANDARD',
    callToAction: request.callToActionType && request.callToActionUrl
      ? { actionType: request.callToActionType as any, url: request.callToActionUrl }
      : undefined,
  });

  // Update request
  await db
    .update(postRequests)
    .set({
      status: 'published',
      gbpPostId: post.postId,
      gbpPostState: post.state,
      publishedAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(postRequests.id, postRequestId));

  // Notify owner
  if (tenant.ownerPhone) {
    await sendWhatsAppMessage(
      tenantId,
      tenant.ownerPhone,
      `הפוסט פורסם בגוגל! יכול לקחת כמה שעות עד שיופיע בפרופיל.`
    );
  }

  console.log(`[post-approval] Published ${post.postId} for ${tenantId}`);
}

/**
 * Send reminders for pending posts and auto-publish if no response.
 */
async function handleReminders() {
  console.log('[post-approval] Processing post reminders');
  const now = new Date();

  // Find pending requests that need reminders or auto-publish
  const pending = await db
    .select({
      request: postRequests,
      tenant: tenants,
    })
    .from(postRequests)
    .innerJoin(tenants, eq(tenants.id, postRequests.tenantId))
    .where(and(
      eq(postRequests.status, 'requested'),
      isNull(postRequests.deletedAt)
    ));

  for (const { request, tenant } of pending) {
    try {
      if (!request.requestedAt || !tenant.ownerPhone) continue;

      const daysSinceRequest = Math.floor(
        (now.getTime() - request.requestedAt.getTime()) / (1000 * 60 * 60 * 24)
      );

      if (daysSinceRequest >= AUTO_PUBLISH_DAYS) {
        // Auto-publish safe content
        console.log(`[post-approval] Auto-publishing for ${tenant.id}`);

        const safeContent = await generateSafeAutoContent(
          tenant.businessName,
          tenant.businessType || 'business'
        );

        await db
          .update(postRequests)
          .set({
            status: 'auto_published',
            aiDraft: safeContent.summary,
            finalContent: safeContent.summary,
            isSafeContent: true,
            updatedAt: new Date(),
          })
          .where(eq(postRequests.id, request.id));

        // Queue for publish
        const { notificationsQueue } = await import('../../queue');
        await notificationsQueue.add('post-publish', {
          jobType: 'post-publish',
          tenantId: tenant.id,
          postRequestId: request.id,
        });

      } else if (daysSinceRequest >= REMINDER_2_DAYS && !request.reminder2SentAt) {
        // Send reminder 2 + generate AI draft
        console.log(`[post-approval] Reminder 2 + AI draft for ${tenant.id}`);

        const generated = await generateSafeAutoContent(
          tenant.businessName,
          tenant.businessType || 'business'
        );

        await db
          .update(postRequests)
          .set({
            status: 'pending_approval',
            aiDraft: generated.summary,
            isSafeContent: generated.isSafe,
            reminder2SentAt: new Date(),
            draftSentAt: new Date(),
            updatedAt: new Date(),
          })
          .where(eq(postRequests.id, request.id));

        await sendWhatsAppMessage(
          tenant.id,
          tenant.ownerPhone,
          `היי, הכנתי לך טיוטה לפוסט החודשי:\n\n` +
          `"${generated.summary}"\n\n` +
          `שלח "אשר" לפרסום או טקסט אחר לשינוי.\n` +
          `אם לא תגיב, נפרסם את הטיוטה הזו בעוד כמה ימים.`
        );

      } else if (daysSinceRequest >= REMINDER_1_DAYS && !request.reminder1SentAt) {
        // Send reminder 1
        console.log(`[post-approval] Reminder 1 for ${tenant.id}`);

        await db
          .update(postRequests)
          .set({
            reminder1SentAt: new Date(),
            updatedAt: new Date(),
          })
          .where(eq(postRequests.id, request.id));

        await sendWhatsAppMessage(
          tenant.id,
          tenant.ownerPhone,
          `היי, תזכורת על הפוסט החודשי בגוגל.\n` +
          `שלח טקסט או "AI" ואכין משהו.\n` +
          `פוסטים פעילים משפרים את הדירוג שלך בחיפוש!`
        );
      }

      // Rate limit
      await new Promise(resolve => setTimeout(resolve, 100));

    } catch (error) {
      console.error(`[post-approval] Error for ${tenant.id}:`, error);
    }
  }
}

postApprovalWorker.on('completed', (job) => {
  console.log(`[post-approval] Job ${job.id} completed`);
});

postApprovalWorker.on('failed', (job, err) => {
  console.error(`[post-approval] Job ${job?.id} failed:`, err.message);
});
```

Update `src/scheduler/jobs.ts` to add post-reminder job:

```typescript
// Post reminder check - daily at 11:00 AM Israel (1 hour after monthly-post)
await scheduledQueue.add(
  'post-reminder',
  {
    jobType: 'post-reminder',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '0 11 * * *', // Daily at 11:00 AM
      tz: 'Asia/Jerusalem',
    },
    jobId: 'post-reminder-daily',
  }
);
console.log('[scheduler] Scheduled post reminder check (daily 11:00 AM Israel)');
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Post approval worker handles generation, publishing, and reminder sequence with auto-publish</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Post Responses with Message Handler</name>
  <files>src/services/whatsapp/message-handler.ts</files>
  <action>
Update `src/services/whatsapp/message-handler.ts` to handle post-related responses:

1. Add post response detection:
   - Check if there's a pending postRequest for the tenant
   - If status is 'requested': owner providing content or requesting AI
   - If status is 'pending_approval': owner approving, editing, or skipping

2. Handle owner content:
```typescript
import { generatePostContent } from '../gbp-content/post-generator';
import { notificationsQueue } from '../../queue';

// After getting message text, check for pending post request:
const [pendingPost] = await db
  .select()
  .from(postRequests)
  .where(and(
    eq(postRequests.tenantId, tenantId),
    // Only check recent requests (within current month)
    eq(postRequests.month, new Date().getMonth() + 1),
    eq(postRequests.year, new Date().getFullYear()),
    isNull(postRequests.deletedAt)
  ))
  .limit(1);

if (pendingPost) {
  const messageText = message.text?.body?.toLowerCase().trim();

  if (pendingPost.status === 'requested') {
    // Owner responding to initial request
    if (messageText === 'ai') {
      // Request AI generation
      await notificationsQueue.add('post-generate', {
        jobType: 'post-generate',
        tenantId,
        postRequestId: pendingPost.id,
      });
      await sendWhatsAppMessage(tenantId, senderPhone, 'מעולה! מכין טיוטה...');
      return;
    }

    if (messageText === 'דלג' || messageText === 'skip') {
      // Skip this month
      await db
        .update(postRequests)
        .set({ status: 'skipped', updatedAt: new Date() })
        .where(eq(postRequests.id, pendingPost.id));
      await sendWhatsAppMessage(tenantId, senderPhone, 'בסדר, נדלג החודש. נזכיר בחודש הבא!');
      return;
    }

    // Owner provided content
    await db
      .update(postRequests)
      .set({ status: 'owner_content', ownerContent: message.text?.body, updatedAt: new Date() })
      .where(eq(postRequests.id, pendingPost.id));

    await notificationsQueue.add('post-generate', {
      jobType: 'post-generate',
      tenantId,
      postRequestId: pendingPost.id,
      ownerContent: message.text?.body,
    });

    await sendWhatsAppMessage(tenantId, senderPhone, 'קיבלתי! מכין את הפוסט...');
    return;
  }

  if (pendingPost.status === 'pending_approval') {
    // Owner responding to draft
    if (messageText === 'אשר' || messageText === 'approve' || messageText === '1') {
      // Approve draft
      await db
        .update(postRequests)
        .set({
          status: 'approved',
          finalContent: pendingPost.aiDraft,
          approvedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(postRequests.id, pendingPost.id));

      await notificationsQueue.add('post-publish', {
        jobType: 'post-publish',
        tenantId,
        postRequestId: pendingPost.id,
      });

      await sendWhatsAppMessage(tenantId, senderPhone, 'מפרסם!');
      return;
    }

    if (messageText === 'דלג' || messageText === 'skip' || messageText === '3') {
      // Skip
      await db
        .update(postRequests)
        .set({ status: 'skipped', updatedAt: new Date() })
        .where(eq(postRequests.id, pendingPost.id));
      await sendWhatsAppMessage(tenantId, senderPhone, 'בסדר, נדלג החודש.');
      return;
    }

    // Owner wants to edit - treat as new content
    await notificationsQueue.add('post-generate', {
      jobType: 'post-generate',
      tenantId,
      postRequestId: pendingPost.id,
      ownerContent: message.text?.body,
    });

    await sendWhatsAppMessage(tenantId, senderPhone, 'מעדכן את הטיוטה...');
    return;
  }
}
```

3. Make sure this check happens BEFORE lead chatbot processing to avoid conflicts.
   Add a comment explaining the priority order.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Message handler routes post-related responses to approval workflow</done>
</task>

</tasks>

<verification>
1. AI post generator:
   - Uses Claude Haiku 4.5 with structured outputs
   - Handles owner content and AI-only generation
   - Validates no phone numbers
   - Distinguishes safe vs promotional content
2. Post approval worker:
   - Generates drafts and sends to owner
   - Publishes approved posts to GBP
   - Sends reminders at day 3 and day 7
   - Auto-publishes safe content at day 10
3. Message handler integration:
   - Detects pending post requests
   - Routes AI/skip/content responses
   - Routes approve/edit/skip for drafts
</verification>

<success_criteria>
- AI generates Hebrew post content with safety classification
- Owner can provide content, request AI, or skip
- Owner can approve, edit, or skip drafts
- Reminder sequence runs daily
- Safe content auto-publishes after 10 days without response
</success_criteria>

<output>
After completion, create `.planning/phases/07-gbp-content/07-05-SUMMARY.md`
</output>
