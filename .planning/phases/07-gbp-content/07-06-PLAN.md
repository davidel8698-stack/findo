---
phase: 07-gbp-content
plan: 06
type: execute
wave: 3
depends_on: ["07-03"]
files_modified:
  - src/services/gbp-content/holiday-checker.ts
  - src/services/google/hours.ts
  - src/services/google/index.ts
  - src/queue/workers/holiday-check.worker.ts
  - src/queue/workers/whatsapp-message.worker.ts
  - src/scheduler/jobs.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "System detects upcoming Israeli holidays"
    - "Owner receives WhatsApp reminder 1 week before holidays"
    - "Owner can update hours via WhatsApp reply"
    - "Special hours are updated on GBP"
  artifacts:
    - path: "src/services/gbp-content/holiday-checker.ts"
      provides: "Holiday detection and reminder logic"
      exports: ["getUpcomingHolidays", "checkTenantHolidays"]
    - path: "src/services/google/hours.ts"
      provides: "GBP hours update service"
      exports: ["setSpecialHours", "getLocationHours"]
    - path: "src/queue/workers/holiday-check.worker.ts"
      provides: "Weekly holiday check worker"
      exports: ["holidayCheckWorker"]
  key_links:
    - from: "holiday-checker.ts"
      to: "@hebcal/core"
      via: "HebrewCalendar"
      pattern: "HebrewCalendar\\.calendar"
    - from: "google/hours.ts"
      to: "GBP API v4"
      via: "PATCH with updateMask"
      pattern: "updateMask.*specialHours"
---

<objective>
Implement Israeli holiday detection using @hebcal/core, create the GBP hours update service, and build the holiday check worker that reminds owners about special hours.

Purpose: Keeps business hours current during Israeli holidays. Per CONTEXT.md: remind 1 week before holidays, owner confirms via WhatsApp, system updates GBP directly.
Output: Holiday detection, hours API service, reminder worker
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-gbp-content/07-CONTEXT.md
@.planning/phases/07-gbp-content/07-RESEARCH.md
@.planning/phases/07-gbp-content/07-03-SUMMARY.md
@src/services/google/reviews.ts
@src/scheduler/jobs.ts
@src/queue/workers/whatsapp-message.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @hebcal/core and Create Holiday Checker Service</name>
  <files>package.json, src/services/gbp-content/holiday-checker.ts</files>
  <action>
1. Install @hebcal/core:
   ```bash
   pnpm add @hebcal/core
   ```

2. Create `src/services/gbp-content/holiday-checker.ts`:

```typescript
/**
 * Israeli Holiday Checker Service
 *
 * Detects upcoming Israeli holidays using @hebcal/core.
 * Triggers reminders 1 week before major holidays.
 *
 * Per CONTEXT.md:
 * - Remind 1 week before Israeli holidays about special hours
 * - Always ask owner about hours - don't assume
 * - Cover all major holidays: Rosh Hashanah, Yom Kippur, Sukkot, Pesach, etc.
 */

import { HebrewCalendar, HolidayEvent, flags } from '@hebcal/core';
import { db } from '../../db';
import { tenants, googleConnections } from '../../db/schema';
import { eq, and, isNull } from 'drizzle-orm';
import { sendWhatsAppMessage } from '../whatsapp/send';

export interface UpcomingHoliday {
  name: string;           // English name
  hebrewName: string;     // Hebrew name
  date: Date;             // Gregorian date
  isYomTov: boolean;      // Work forbidden (major holiday)
  daysUntil: number;      // Days from today
}

// Major holidays that typically affect business hours
const BUSINESS_AFFECTING_HOLIDAYS = [
  'Rosh Hashana',
  'Yom Kippur',
  'Sukkot',
  'Shmini Atzeret',
  'Simchat Torah',
  'Pesach',
  'Shavuot',
  'Yom HaAtzma\'ut',      // Independence Day
  'Yom HaZikaron',        // Memorial Day
  'Purim',                // Partial business impact
  'Chanukah',             // First and last days
];

// Hebrew names for common messages
const HEBREW_NAMES: Record<string, string> = {
  'Rosh Hashana': 'ראש השנה',
  'Yom Kippur': 'יום כיפור',
  'Sukkot': 'סוכות',
  'Shmini Atzeret': 'שמיני עצרת',
  'Simchat Torah': 'שמחת תורה',
  'Pesach': 'פסח',
  'Shavuot': 'שבועות',
  'Yom HaAtzma\'ut': 'יום העצמאות',
  'Yom HaZikaron': 'יום הזיכרון',
  'Purim': 'פורים',
  'Chanukah': 'חנוכה',
};

/**
 * Get upcoming holidays within a time window.
 *
 * @param daysAhead - Number of days to look ahead (default 14)
 * @returns List of upcoming holidays sorted by date
 */
export function getUpcomingHolidays(daysAhead: number = 14): UpcomingHoliday[] {
  const now = new Date();
  const end = new Date(now);
  end.setDate(end.getDate() + daysAhead);

  const events = HebrewCalendar.calendar({
    start: now,
    end: end,
    il: true,             // Use Israeli holidays
    candlelighting: false,
    sedrot: false,
    omer: false,
    noModern: false,      // Include modern Israeli holidays
  });

  const holidays: UpcomingHoliday[] = [];

  for (const event of events) {
    // Only process HolidayEvent instances
    if (!(event instanceof HolidayEvent)) continue;

    const desc = event.getDesc();

    // Check if this is a business-affecting holiday
    const isBusinessAffecting = BUSINESS_AFFECTING_HOLIDAYS.some(h => desc.includes(h));
    if (!isBusinessAffecting) continue;

    const eventDate = event.getDate().greg();
    const daysUntil = Math.ceil((eventDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    holidays.push({
      name: desc,
      hebrewName: HEBREW_NAMES[desc.split(' ')[0]] || event.render('he'),
      date: eventDate,
      isYomTov: (event.getFlags() & flags.CHAG) !== 0,
      daysUntil,
    });
  }

  // Sort by date
  return holidays.sort((a, b) => a.date.getTime() - b.date.getTime());
}

/**
 * Get holidays that need reminders (7 days away).
 *
 * @returns Holidays needing reminder this week
 */
export function getHolidaysNeedingReminder(): UpcomingHoliday[] {
  const holidays = getUpcomingHolidays(10); // Look 10 days ahead
  return holidays.filter(h => h.daysUntil >= 5 && h.daysUntil <= 8); // 5-8 days = "about a week"
}

/**
 * Check a tenant for upcoming holidays and send reminders.
 *
 * @param tenantId - Tenant UUID
 * @returns Whether reminder was sent
 */
export async function checkTenantHolidays(tenantId: string): Promise<boolean> {
  const [tenant] = await db
    .select()
    .from(tenants)
    .where(and(eq(tenants.id, tenantId), isNull(tenants.deletedAt)))
    .limit(1);

  if (!tenant?.ownerPhone) return false;

  const [google] = await db
    .select()
    .from(googleConnections)
    .where(and(
      eq(googleConnections.tenantId, tenantId),
      eq(googleConnections.isActive, true)
    ))
    .limit(1);

  if (!google) return false;

  const upcomingHolidays = getHolidaysNeedingReminder();
  if (upcomingHolidays.length === 0) return false;

  // Format holiday list
  const holidayList = upcomingHolidays
    .map(h => `- ${h.hebrewName} (${formatHebrewDate(h.date)})`)
    .join('\n');

  // Send reminder in Hebrew
  const message =
    `היי! בעוד שבוע יש חגים:\n${holidayList}\n\n` +
    `מה שעות הפעילות שלך בחגים?\n` +
    `שלח לי במבנה הזה:\n` +
    `"[תאריך]: [שעות או סגור]"\n\n` +
    `לדוגמה:\n` +
    `"15/9: סגור"\n` +
    `"16/9: 10:00-14:00"`;

  await sendWhatsAppMessage(tenantId, tenant.ownerPhone, message);
  return true;
}

/**
 * Format date in Hebrew style (DD/MM).
 */
function formatHebrewDate(date: Date): string {
  const day = date.getDate().toString().padStart(2, '0');
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  return `${day}/${month}`;
}

/**
 * Parse owner's hours response.
 *
 * Parses formats like:
 * - "15/9: סגור" -> closed
 * - "16/9: 10:00-14:00" -> specific hours
 * - "סגור 10-14" -> closed from 10th to 14th
 *
 * @param text - Owner's response text
 * @returns Parsed special hours or null if couldn't parse
 */
export interface ParsedHours {
  date: { day: number; month: number };
  isClosed: boolean;
  openTime?: string;
  closeTime?: string;
}

export function parseHoursResponse(text: string): ParsedHours[] {
  const results: ParsedHours[] = [];
  const lines = text.split('\n').filter(l => l.trim());

  for (const line of lines) {
    // Try "DD/MM: סגור" pattern
    const closedMatch = line.match(/(\d{1,2})\/(\d{1,2})\s*:\s*סגור/i);
    if (closedMatch) {
      results.push({
        date: { day: parseInt(closedMatch[1]), month: parseInt(closedMatch[2]) },
        isClosed: true,
      });
      continue;
    }

    // Try "DD/MM: HH:MM-HH:MM" pattern
    const hoursMatch = line.match(/(\d{1,2})\/(\d{1,2})\s*:\s*(\d{1,2}):?(\d{2})?\s*-\s*(\d{1,2}):?(\d{2})?/);
    if (hoursMatch) {
      const openHour = hoursMatch[3].padStart(2, '0');
      const openMin = (hoursMatch[4] || '00').padStart(2, '0');
      const closeHour = hoursMatch[5].padStart(2, '0');
      const closeMin = (hoursMatch[6] || '00').padStart(2, '0');

      results.push({
        date: { day: parseInt(hoursMatch[1]), month: parseInt(hoursMatch[2]) },
        isClosed: false,
        openTime: `${openHour}:${openMin}`,
        closeTime: `${closeHour}:${closeMin}`,
      });
      continue;
    }

    // Try simple "סגור" for single date context
    if (line.toLowerCase().includes('סגור') && results.length === 0) {
      // Need date context from previous messages - skip for now
      console.log('[holiday-checker] Could not parse date from:', line);
    }
  }

  return results;
}
```

Export from `src/services/gbp-content/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Holiday checker detects Israeli holidays and can send reminders</done>
</task>

<task type="auto">
  <name>Task 2: Create GBP Hours Update Service</name>
  <files>src/services/google/hours.ts, src/services/google/index.ts</files>
  <action>
Create `src/services/google/hours.ts`:

```typescript
/**
 * Google Business Profile Hours Service
 *
 * Update business hours on GBP, particularly special hours for holidays.
 *
 * Per RESEARCH.md:
 * - Use specific updateMask ('specialHours.specialHourPeriods'), never '*'
 * - Special hours add to regular hours, don't replace them
 */

import { createAuthenticatedClient } from './oauth';

const GBP_API_BASE = 'https://mybusiness.googleapis.com/v4';

export interface SpecialHourPeriod {
  startDate: {
    year: number;
    month: number;
    day: number;
  };
  endDate: {
    year: number;
    month: number;
    day: number;
  };
  isClosed: boolean;
  openTime?: string;  // HH:MM format
  closeTime?: string; // HH:MM format
}

export interface RegularHours {
  periods: Array<{
    openDay: string;   // MONDAY, TUESDAY, etc.
    openTime: string;  // HH:MM
    closeDay: string;
    closeTime: string;
  }>;
}

interface LocationHoursResponse {
  regularHours?: {
    periods?: Array<{
      openDay?: string;
      openTime?: string;
      closeDay?: string;
      closeTime?: string;
    }>;
  };
  specialHours?: {
    specialHourPeriods?: Array<{
      startDate?: { year?: number; month?: number; day?: number };
      endDate?: { year?: number; month?: number; day?: number };
      isClosed?: boolean;
      openTime?: string;
      closeTime?: string;
    }>;
  };
}

/**
 * Get current business hours for a location.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @returns Regular and special hours
 */
export async function getLocationHours(
  tenantId: string,
  accountId: string,
  locationId: string
): Promise<{ regular: RegularHours | null; special: SpecialHourPeriod[] }> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}`;

  const response = await client.request<LocationHoursResponse>({ url });

  const regular: RegularHours | null = response.data.regularHours?.periods
    ? {
        periods: response.data.regularHours.periods.map(p => ({
          openDay: p.openDay || '',
          openTime: p.openTime || '',
          closeDay: p.closeDay || '',
          closeTime: p.closeTime || '',
        })),
      }
    : null;

  const special: SpecialHourPeriod[] = (response.data.specialHours?.specialHourPeriods || [])
    .map(p => ({
      startDate: {
        year: p.startDate?.year || new Date().getFullYear(),
        month: p.startDate?.month || 1,
        day: p.startDate?.day || 1,
      },
      endDate: {
        year: p.endDate?.year || new Date().getFullYear(),
        month: p.endDate?.month || 1,
        day: p.endDate?.day || 1,
      },
      isClosed: p.isClosed || false,
      openTime: p.openTime,
      closeTime: p.closeTime,
    }));

  return { regular, special };
}

/**
 * Set special hours for a location.
 *
 * IMPORTANT: This ADDS to existing special hours. To replace,
 * call getLocationHours first and merge.
 *
 * @param tenantId - Tenant UUID
 * @param accountId - GBP account ID
 * @param locationId - Location ID
 * @param periods - Special hour periods to set
 */
export async function setSpecialHours(
  tenantId: string,
  accountId: string,
  locationId: string,
  periods: SpecialHourPeriod[]
): Promise<void> {
  const client = await createAuthenticatedClient(tenantId);

  if (!client) {
    throw new Error(`No valid Google credentials for tenant ${tenantId}`);
  }

  // Get existing special hours to merge
  const { special: existing } = await getLocationHours(tenantId, accountId, locationId);

  // Merge: remove conflicting dates, add new ones
  const merged = [...existing];

  for (const newPeriod of periods) {
    // Remove any existing period for the same date
    const index = merged.findIndex(
      p =>
        p.startDate.year === newPeriod.startDate.year &&
        p.startDate.month === newPeriod.startDate.month &&
        p.startDate.day === newPeriod.startDate.day
    );

    if (index >= 0) {
      merged.splice(index, 1);
    }

    merged.push(newPeriod);
  }

  const url = `${GBP_API_BASE}/accounts/${accountId}/locations/${locationId}`;

  // Use specific updateMask - NEVER use '*' per RESEARCH.md
  await client.request({
    url,
    method: 'PATCH',
    params: {
      updateMask: 'specialHours.specialHourPeriods',
    },
    data: {
      specialHours: {
        specialHourPeriods: merged.map(p => ({
          startDate: p.startDate,
          endDate: p.endDate,
          isClosed: p.isClosed,
          ...(p.openTime && { openTime: p.openTime }),
          ...(p.closeTime && { closeTime: p.closeTime }),
        })),
      },
    },
  });
}

/**
 * Helper: Create a special hour period for a single day.
 *
 * @param date - The date
 * @param isClosed - Whether closed
 * @param openTime - Opening time (HH:MM)
 * @param closeTime - Closing time (HH:MM)
 * @returns Special hour period
 */
export function createSingleDayPeriod(
  date: Date,
  isClosed: boolean,
  openTime?: string,
  closeTime?: string
): SpecialHourPeriod {
  const dateObj = {
    year: date.getFullYear(),
    month: date.getMonth() + 1, // API uses 1-12
    day: date.getDate(),
  };

  return {
    startDate: dateObj,
    endDate: dateObj,
    isClosed,
    openTime,
    closeTime,
  };
}
```

Export from `src/services/google/index.ts`.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>GBP hours service can get and set special hours with proper updateMask</done>
</task>

<task type="auto">
  <name>Task 3: Create Holiday Check Worker and Message Handler Integration</name>
  <files>src/queue/workers/holiday-check.worker.ts, src/scheduler/jobs.ts, src/queue/workers/whatsapp-message.worker.ts</files>
  <action>
1. Create `src/queue/workers/holiday-check.worker.ts`:

```typescript
/**
 * Holiday Check Worker
 *
 * Weekly job that checks for upcoming Israeli holidays
 * and sends reminders to owners about special hours.
 *
 * Per CONTEXT.md: Remind 1 week before holidays.
 */

import { Worker, Job } from 'bullmq';
import { createRedisConnection } from '../../lib/redis';
import { db } from '../../db';
import { tenants, googleConnections, whatsappConnections } from '../../db/schema';
import { eq, and, isNull } from 'drizzle-orm';
import { checkTenantHolidays, getHolidaysNeedingReminder } from '../../services/gbp-content/holiday-checker';

interface HolidayCheckJobData {
  jobType: 'holiday-check';
}

export const holidayCheckWorker = new Worker<HolidayCheckJobData>(
  'scheduled',
  async (job: Job<HolidayCheckJobData>) => {
    if (job.data.jobType !== 'holiday-check') return;

    console.log('[holiday-check] Starting weekly holiday check');

    // First check if there are any holidays to remind about
    const upcomingHolidays = getHolidaysNeedingReminder();
    if (upcomingHolidays.length === 0) {
      console.log('[holiday-check] No holidays needing reminder this week');
      return;
    }

    console.log(`[holiday-check] Found ${upcomingHolidays.length} holidays needing reminder`);

    // Get all active tenants with both Google and WhatsApp
    const activeTenants = await db
      .select({ tenant: tenants })
      .from(tenants)
      .innerJoin(googleConnections, and(
        eq(googleConnections.tenantId, tenants.id),
        eq(googleConnections.isActive, true)
      ))
      .innerJoin(whatsappConnections, and(
        eq(whatsappConnections.tenantId, tenants.id),
        eq(whatsappConnections.isActive, true)
      ))
      .where(and(
        eq(tenants.status, 'active'),
        isNull(tenants.deletedAt)
      ));

    console.log(`[holiday-check] Checking ${activeTenants.length} tenants`);

    let sent = 0;

    for (const { tenant } of activeTenants) {
      try {
        const reminded = await checkTenantHolidays(tenant.id);
        if (reminded) sent++;

        // Rate limit
        await new Promise(resolve => setTimeout(resolve, 100));

      } catch (error) {
        console.error(`[holiday-check] Error for ${tenant.id}:`, error);
      }
    }

    console.log(`[holiday-check] Completed: ${sent} reminders sent`);
  },
  {
    connection: createRedisConnection(),
    concurrency: 1,
  }
);

holidayCheckWorker.on('completed', (job) => {
  console.log(`[holiday-check] Job ${job.id} completed`);
});

holidayCheckWorker.on('failed', (job, err) => {
  console.error(`[holiday-check] Job ${job?.id} failed:`, err.message);
});
```

2. Update `src/scheduler/jobs.ts` to add holiday check job (add after existing scheduled jobs):

```typescript
// Holiday check - weekly on Sunday 10:00 AM Israel (same day as photo request)
// Checks for holidays in the coming week
await scheduledQueue.add(
  'holiday-check',
  {
    jobType: 'holiday-check',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '0 10 * * 0', // Sunday 10:00 AM
      tz: 'Asia/Jerusalem',
    },
    jobId: 'holiday-check-weekly',
  }
);
console.log('[scheduler] Scheduled holiday check (Sunday 10:00 AM Israel)');
```

3. Update `src/queue/workers/whatsapp-message.worker.ts` to handle hours responses.

**Location:** Add AFTER photo category handling (around line ~740 per 07-03 changes) and BEFORE the lead conversation check. This follows the message processing priority established in 07-03.

Add imports at the top (after the photo-processor imports from 07-03):
```typescript
import { parseHoursResponse } from '../../services/gbp-content/holiday-checker';
import { setSpecialHours, createSingleDayPeriod } from '../../services/google/hours';
```

Add hours response detection AFTER photo category handling, BEFORE lead conversation check:

```typescript
      // 1.9 Check if message looks like hours response (DD/MM: format)
      // This handles replies to holiday hours reminders
      let handledAsHoursResponse = false;

      if (isOwner && !handledAsReviewResponse && !handledAsPhotoResponse && message.type === 'text' && message.text) {
        const hoursPattern = /\d{1,2}\/\d{1,2}\s*:/;
        const messageText = message.text;

        if (hoursPattern.test(messageText)) {
          // Try to parse as hours response
          const parsedHours = parseHoursResponse(messageText);

          if (parsedHours.length > 0) {
            console.log(`[whatsapp-message] Parsed ${parsedHours.length} special hours`);

            // Get Google connection
            const [google] = await db
              .select()
              .from(googleConnections)
              .where(and(
                eq(googleConnections.tenantId, tenantId),
                eq(googleConnections.isActive, true)
              ))
              .limit(1);

            if (google) {
              const currentYear = new Date().getFullYear();

              // Convert parsed hours to API format
              const periods = parsedHours.map(h => {
                const date = new Date(currentYear, h.date.month - 1, h.date.day);
                return createSingleDayPeriod(date, h.isClosed, h.openTime, h.closeTime);
              });

              try {
                await setSpecialHours(tenantId, google.accountId, google.locationId, periods);

                // Confirm to owner
                const summary = parsedHours.map(h => {
                  const dateStr = `${h.date.day}/${h.date.month}`;
                  if (h.isClosed) return `${dateStr}: סגור`;
                  return `${dateStr}: ${h.openTime}-${h.closeTime}`;
                }).join('\n');

                const client = await createWhatsAppClient(tenantId);
                if (client) {
                  await sendTextMessage(
                    client,
                    message.from,
                    `עדכנתי את השעות בגוגל:\n${summary}\n\nתודה!`
                  );
                }

                handledAsHoursResponse = true;
                console.log(`[whatsapp-message] Processed as holiday hours response`);
              } catch (error) {
                console.error('[whatsapp-message] Failed to update hours:', error);
                const client = await createWhatsAppClient(tenantId);
                if (client) {
                  await sendTextMessage(
                    client,
                    message.from,
                    'לא הצלחתי לעדכן את השעות. נסה שוב או פנה לתמיכה.'
                  );
                }
              }
            }
          }
        }
      }

      // 1.10 Check if this is part of a lead conversation (skip if already handled)
      if (!handledAsReviewResponse && !handledAsPhotoResponse && !handledAsHoursResponse) {
```

Update the existing lead conversation check condition to include the new flag:
```typescript
      // OLD (from 07-03):
      if (!handledAsReviewResponse && !handledAsPhotoResponse) {

      // NEW:
      if (!handledAsReviewResponse && !handledAsPhotoResponse && !handledAsHoursResponse) {
```

Update the message processing priority comment (at top of processWhatsAppMessages):
```typescript
/**
 * Message Processing Priority (owner messages):
 * 1. Review approval responses (button clicks, text replies)
 * 2. Photo responses (images when photo request active)
 * 3. Photo category selection (1-5 or Hebrew category words)
 * 4. Hours responses (DD/MM: format for holiday hours)
 * 5. Lead chatbot flow (fallback for non-owner messages)
 */
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Holiday check worker runs weekly, message handler processes hours responses</done>
</task>

</tasks>

<verification>
1. Holiday checker service:
   - Uses @hebcal/core for Israeli holiday detection
   - Identifies business-affecting holidays
   - Calculates days until holiday
   - Provides Hebrew names for messages
2. GBP hours service:
   - Gets current regular and special hours
   - Sets special hours with proper updateMask
   - Merges new hours with existing
   - Creates single-day period helper
3. Holiday check worker:
   - Runs weekly on Sunday
   - Only sends reminders if holidays in 5-8 days
   - Rate-limited tenant iteration
4. Message handler integration:
   - Detects hours response pattern (DD/MM: ...)
   - Parses closed or specific hours
   - Updates GBP directly
   - Confirms update to owner
</verification>

<success_criteria>
- @hebcal/core installed and detecting Israeli holidays
- Holiday reminders sent 1 week before major holidays
- Owner can respond with hours in simple format
- Special hours updated on GBP directly from WhatsApp reply
- Confirmation sent after successful update
</success_criteria>

<output>
After completion, create `.planning/phases/07-gbp-content/07-06-SUMMARY.md`
</output>
