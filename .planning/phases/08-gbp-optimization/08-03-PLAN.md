---
phase: 08-gbp-optimization
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/services/optimization/metrics-collector.ts
  - src/services/optimization/index.ts
  - src/queue/workers/metrics-collection.worker.ts
  - src/scheduler/jobs.ts
autonomous: true

must_haves:
  truths:
    - "System collects weekly metrics for all active tenants"
    - "Metrics snapshot includes reviews, visibility, content data"
    - "Collection runs automatically every week"
    - "Baseline is recalculated after each collection"
  artifacts:
    - path: "src/services/optimization/metrics-collector.ts"
      provides: "Metrics collection and aggregation logic"
      exports: ["collectMetricsForTenant", "calculateBaseline"]
    - path: "src/queue/workers/metrics-collection.worker.ts"
      provides: "Scheduled worker for weekly collection"
      contains: "metrics-collection"
  key_links:
    - from: "src/queue/workers/metrics-collection.worker.ts"
      to: "src/services/optimization/metrics-collector.ts"
      via: "service import"
      pattern: "import.*collectMetricsForTenant"
    - from: "src/scheduler/jobs.ts"
      to: "metrics-collection"
      via: "scheduled job registration"
      pattern: "metrics-collection"
---

<objective>
Create metrics collection service and worker that aggregates GBP data weekly.

Purpose: GBPO-01/02/03 require metric monitoring. This plan implements the data collection pipeline that populates metricSnapshots table with weekly aggregates, and calculates dynamic baselines per tenant.

Output: Metrics collector service and scheduled worker that runs weekly to gather all optimization-relevant metrics.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-gbp-optimization/08-CONTEXT.md
@.planning/phases/08-gbp-optimization/08-01-SUMMARY.md
@.planning/phases/08-gbp-optimization/08-02-SUMMARY.md
@src/scheduler/jobs.ts
@src/queue/workers/review-poll.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metrics collector service</name>
  <files>src/services/optimization/metrics-collector.ts, src/services/optimization/index.ts</files>
  <action>
Create `src/services/optimization/metrics-collector.ts`:

1. **collectMetricsForTenant function:**
```typescript
export async function collectMetricsForTenant(
  tenantId: string,
  weekStartDate: Date, // Sunday
  period: 'week' | 'month' = 'week'
): Promise<void>
```

Implementation:
- Get tenant's Google connection from DB
- If no Google connection, log and skip (metrics require Google)

- **Review metrics (GBPO-01):**
  - Query processedReviews for the time period
  - Calculate: totalReviews (all time), reviewCount (this period), averageRating
  - Calculate: responsePercentage (reviews with postedReply / total * 100)

- **Visibility metrics (GBPO-02):**
  - Call getPerformanceMetrics from google/performance
  - Extract: impressions, searches, actions
  - Handle null (API unavailable) gracefully - set to null in snapshot

- **Content metrics (GBPO-03):**
  - Call getMediaMetrics from google/performance
  - Extract: imageCount, imageViews
  - Handle null gracefully

- **Review request metrics:**
  - Query reviewRequests for the time period
  - Calculate: sent count, completed count, conversion rate

- **Store snapshot:**
  - Upsert into metricSnapshots (update if exists for same week)
  - Use ON CONFLICT to handle re-runs

2. **calculateBaseline function:**
```typescript
export async function calculateBaseline(tenantId: string): Promise<void>
```

Implementation per CONTEXT.md "dynamic baseline":
- Query last 8 weeks of metricSnapshots for tenant
- If < 4 weeks of data, don't set baseline (not enough history)
- Calculate moving average for:
  - baselineReviewRate: avg(reviewCount) per week
  - baselineResponseRate: avg(responsePercentage)
  - baselineConversionRate: avg(reviewRequestConversionRate)
- Upsert into tenantBaselines
- Set samplesCount to number of weeks used

3. **collectMetricsForAllTenants function:**
```typescript
export async function collectMetricsForAllTenants(): Promise<{
  processed: number;
  skipped: number;
  errors: number;
}>
```

Implementation:
- Query all tenants with status 'active' or 'trial'
- Also require googleConnections.status = 'active'
- For each tenant:
  - collectMetricsForTenant
  - calculateBaseline
  - 100ms delay between tenants (rate limit protection)
- Return counts for logging

Create `src/services/optimization/index.ts`:
```typescript
export * from './metrics-collector';
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Functions exported: grep for "export async function collectMetricsForTenant"
  </verify>
  <done>
metrics-collector.ts exists with collectMetricsForTenant, calculateBaseline, collectMetricsForAllTenants. Uses optimization schema and google/performance service.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create metrics collection worker</name>
  <files>src/queue/workers/metrics-collection.worker.ts</files>
  <action>
Create `src/queue/workers/metrics-collection.worker.ts`:

Follow pattern from review-poll.worker.ts:

```typescript
import { Worker, type Job } from 'bullmq';
import { redisConnection } from '../../lib/redis';
import { collectMetricsForAllTenants } from '../../services/optimization';

const QUEUE_NAME = 'scheduled';

export const metricsCollectionWorker = new Worker(
  QUEUE_NAME,
  async (job: Job) => {
    if (job.name !== 'metrics-collection') return;

    console.log('[metrics-collection] Starting weekly metrics collection...');

    const result = await collectMetricsForAllTenants();

    console.log(`[metrics-collection] Complete: ${result.processed} processed, ${result.skipped} skipped, ${result.errors} errors`);

    return result;
  },
  {
    connection: redisConnection,
    concurrency: 1, // Single instance - runs weekly, no need for parallel
  }
);

metricsCollectionWorker.on('failed', (job, err) => {
  console.error(`[metrics-collection] Job ${job?.id} failed:`, err.message);
});

console.log('[metrics-collection] Worker started');
```
  </action>
  <verify>
File exists: `ls src/queue/workers/metrics-collection.worker.ts`
Worker pattern correct: grep for "new Worker"
  </verify>
  <done>
metrics-collection.worker.ts exists, processes 'metrics-collection' jobs from scheduled queue, calls collectMetricsForAllTenants.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register scheduled job for weekly collection</name>
  <files>src/scheduler/jobs.ts</files>
  <action>
Add to `src/scheduler/jobs.ts` in scheduleRecurringJobs function:

```typescript
/**
 * Metrics Collection Job
 *
 * Runs weekly on Monday at 2:00 AM Israel time.
 * Collects GBP metrics for all tenants from the previous week.
 * Updates baselines after collection.
 *
 * Per CONTEXT.md: Weekly check frequency for metrics.
 * Monday chosen to capture full week data (Sun-Sat).
 */
await scheduledQueue.add(
  'metrics-collection',
  {
    jobType: 'metrics-collection',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '0 2 * * 1', // Monday 2:00 AM
      tz: 'Asia/Jerusalem',
    },
    jobId: 'metrics-collection-weekly',
  }
);
console.log('[scheduler] Registered: metrics-collection (Monday 2:00 AM Israel)');
```

Place after holiday-check job registration (maintain logical grouping).
  </action>
  <verify>
grep for "metrics-collection" in jobs.ts
Pattern correct: "0 2 * * 1"
  </verify>
  <done>
Scheduled job registered for weekly metrics collection on Monday 2:00 AM Israel time.
  </done>
</task>

</tasks>

<verification>
1. Service exists: `ls src/services/optimization/metrics-collector.ts`
2. Worker exists: `ls src/queue/workers/metrics-collection.worker.ts`
3. Job registered: grep "metrics-collection" in jobs.ts
4. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- metrics-collector.ts has collectMetricsForTenant, calculateBaseline, collectMetricsForAllTenants
- Worker processes 'metrics-collection' jobs
- Scheduled job runs Monday 2:00 AM Israel time
- Baseline calculation uses 4+ weeks of data with moving average
</success_criteria>

<output>
After completion, create `.planning/phases/08-gbp-optimization/08-03-SUMMARY.md`
</output>
