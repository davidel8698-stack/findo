---
phase: 08-gbp-optimization
plan: 06
type: execute
wave: 3
depends_on: ["08-01"]
files_modified:
  - src/services/optimization/ab-testing.ts
  - src/services/optimization/index.ts
  - src/services/review-request/messages.ts
autonomous: true

must_haves:
  truths:
    - "System can assign A/B test variants to tenants"
    - "System tracks outcomes (success/failure) per variant"
    - "Variants are selected based on assignment when sending messages"
    - "Winning variants are identified when 20%+ better with 10+ samples"
  artifacts:
    - path: "src/services/optimization/ab-testing.ts"
      provides: "A/B test assignment and tracking"
      exports: ["assignVariant", "recordOutcome", "getActiveVariant", "checkForWinner"]
  key_links:
    - from: "src/services/review-request/messages.ts"
      to: "src/services/optimization/ab-testing.ts"
      via: "variant selection for messages"
      pattern: "getActiveVariant"
---

<objective>
Create A/B testing framework for message templates and timing optimization.

Purpose: GBPO-07 requires A/B testing of approaches. Per CONTEXT.md: test everything tunable, 20%+ threshold with 10+ samples, auto-adopt winners globally, auto-rollback if harmful.

Output: A/B testing service with variant assignment, outcome tracking, and winner detection. Integrated with review request messages as first use case.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-gbp-optimization/08-CONTEXT.md
@.planning/phases/08-gbp-optimization/08-01-SUMMARY.md
@src/services/review-request/messages.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create A/B testing service</name>
  <files>src/services/optimization/ab-testing.ts</files>
  <action>
Create `src/services/optimization/ab-testing.ts`:

```typescript
import { db } from '../../db';
import {
  abTestVariants,
  abTestAssignments,
  type AbTestVariant,
  type AbTestAssignment,
} from '../../db/schema';
import { eq, and, isNull, sql } from 'drizzle-orm';

export type TestType =
  | 'review_request_message'
  | 'review_request_timing'
  | 'review_reminder_message'
  | 'photo_request_message'
  | 'post_request_message';

/**
 * Threshold for declaring a winner.
 * Per CONTEXT.md: 20%+ better with 10+ samples.
 */
const WINNER_THRESHOLD_PERCENT = 20;
const MIN_SAMPLES_FOR_WINNER = 10;

/**
 * Get or assign a variant for a tenant for a specific test type.
 * If no assignment exists, randomly assigns from active variants.
 */
export async function getActiveVariant(
  tenantId: string,
  testType: TestType
): Promise<AbTestVariant | null> {
  // Check existing active assignment
  const existing = await db
    .select({
      assignment: abTestAssignments,
      variant: abTestVariants,
    })
    .from(abTestAssignments)
    .innerJoin(abTestVariants, eq(abTestVariants.id, abTestAssignments.variantId))
    .where(and(
      eq(abTestAssignments.tenantId, tenantId),
      eq(abTestAssignments.isActive, true),
      eq(abTestVariants.testType, testType)
    ))
    .limit(1);

  if (existing.length > 0) {
    return existing[0].variant;
  }

  // No active assignment - assign one
  return await assignVariant(tenantId, testType);
}

/**
 * Assign a variant to a tenant.
 * Prefers global winners, otherwise random assignment.
 */
export async function assignVariant(
  tenantId: string,
  testType: TestType
): Promise<AbTestVariant | null> {
  // Get all variants for this test type
  const variants = await db
    .select()
    .from(abTestVariants)
    .where(eq(abTestVariants.testType, testType));

  if (variants.length === 0) {
    return null; // No variants defined for this test
  }

  // Check for global winner first
  const globalWinner = variants.find(v => v.isGlobalWinner);
  if (globalWinner) {
    await createAssignment(tenantId, globalWinner.id);
    return globalWinner;
  }

  // Random assignment among available variants
  const randomIndex = Math.floor(Math.random() * variants.length);
  const selectedVariant = variants[randomIndex];

  await createAssignment(tenantId, selectedVariant.id);
  return selectedVariant;
}

async function createAssignment(tenantId: string, variantId: string): Promise<void> {
  await db.insert(abTestAssignments).values({
    tenantId,
    variantId,
    assignedAt: new Date(),
    samplesCollected: 0,
    successCount: 0,
    isActive: true,
  }).onConflictDoNothing(); // Ignore if already exists
}

/**
 * Record an outcome for a test.
 * @param tenantId - Tenant ID
 * @param testType - Type of test
 * @param success - Whether the outcome was successful (e.g., review received after request)
 */
export async function recordOutcome(
  tenantId: string,
  testType: TestType,
  success: boolean
): Promise<void> {
  // Get active assignment
  const [assignment] = await db
    .select({
      assignment: abTestAssignments,
      variant: abTestVariants,
    })
    .from(abTestAssignments)
    .innerJoin(abTestVariants, eq(abTestVariants.id, abTestAssignments.variantId))
    .where(and(
      eq(abTestAssignments.tenantId, tenantId),
      eq(abTestAssignments.isActive, true),
      eq(abTestVariants.testType, testType)
    ))
    .limit(1);

  if (!assignment) {
    console.log(`[ab-testing] No active assignment for tenant ${tenantId}, test ${testType}`);
    return;
  }

  const newSamples = assignment.assignment.samplesCollected + 1;
  const newSuccess = assignment.assignment.successCount + (success ? 1 : 0);
  const conversionRate = (newSuccess / newSamples) * 100;

  await db
    .update(abTestAssignments)
    .set({
      samplesCollected: newSamples,
      successCount: newSuccess,
      conversionRate: conversionRate.toFixed(2),
      updatedAt: new Date(),
    })
    .where(eq(abTestAssignments.id, assignment.assignment.id));

  console.log(`[ab-testing] Recorded outcome for tenant ${tenantId}: variant ${assignment.variant.variantName}, success=${success}, rate=${conversionRate.toFixed(1)}%`);
}

/**
 * Check if any variant should be declared a winner for a test type.
 * Per CONTEXT.md: 20%+ better than control with 10+ samples.
 */
export async function checkForWinner(testType: TestType): Promise<AbTestVariant | null> {
  // Aggregate stats by variant
  const variantStats = await db
    .select({
      variantId: abTestAssignments.variantId,
      totalSamples: sql<number>`SUM(${abTestAssignments.samplesCollected})`,
      totalSuccess: sql<number>`SUM(${abTestAssignments.successCount})`,
    })
    .from(abTestAssignments)
    .innerJoin(abTestVariants, eq(abTestVariants.id, abTestAssignments.variantId))
    .where(and(
      eq(abTestVariants.testType, testType),
      eq(abTestAssignments.isActive, true)
    ))
    .groupBy(abTestAssignments.variantId);

  // Get variants with enough samples
  const qualifiedVariants = variantStats.filter(v => v.totalSamples >= MIN_SAMPLES_FOR_WINNER);

  if (qualifiedVariants.length < 2) {
    return null; // Need at least 2 variants with enough samples to compare
  }

  // Find control variant
  const allVariants = await db
    .select()
    .from(abTestVariants)
    .where(eq(abTestVariants.testType, testType));

  const controlVariant = allVariants.find(v => v.isControl);
  if (!controlVariant) {
    return null; // No control to compare against
  }

  const controlStats = variantStats.find(v => v.variantId === controlVariant.id);
  if (!controlStats || controlStats.totalSamples < MIN_SAMPLES_FOR_WINNER) {
    return null; // Control doesn't have enough samples
  }

  const controlRate = controlStats.totalSuccess / controlStats.totalSamples;

  // Check each variant against control
  for (const stats of qualifiedVariants) {
    if (stats.variantId === controlVariant.id) continue;

    const variantRate = stats.totalSuccess / stats.totalSamples;
    const improvement = ((variantRate - controlRate) / controlRate) * 100;

    if (improvement >= WINNER_THRESHOLD_PERCENT) {
      // Found a winner!
      const winner = allVariants.find(v => v.id === stats.variantId);
      if (winner) {
        console.log(`[ab-testing] Winner found: ${winner.variantName} (${improvement.toFixed(1)}% better than control)`);
        return winner;
      }
    }
  }

  return null;
}

/**
 * Promote a variant to global winner.
 * All new tenants will be assigned this variant.
 */
export async function promoteToGlobalWinner(variantId: string): Promise<void> {
  const [variant] = await db
    .select()
    .from(abTestVariants)
    .where(eq(abTestVariants.id, variantId))
    .limit(1);

  if (!variant) {
    throw new Error(`Variant ${variantId} not found`);
  }

  // Clear any existing global winner for this test type
  await db
    .update(abTestVariants)
    .set({
      isGlobalWinner: false,
      updatedAt: new Date(),
    })
    .where(and(
      eq(abTestVariants.testType, variant.testType),
      eq(abTestVariants.isGlobalWinner, true)
    ));

  // Set new winner
  await db
    .update(abTestVariants)
    .set({
      isGlobalWinner: true,
      globalWinnerAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(abTestVariants.id, variantId));

  console.log(`[ab-testing] Promoted ${variant.variantName} to global winner for ${variant.testType}`);
}

/**
 * Seed initial variants for a test type.
 * Call this during deployment to set up test infrastructure.
 */
export async function seedVariants(
  testType: TestType,
  variants: Array<{ name: string; content: object; isControl?: boolean }>
): Promise<void> {
  for (const v of variants) {
    await db.insert(abTestVariants).values({
      testType,
      variantName: v.name,
      variantContent: JSON.stringify(v.content),
      isControl: v.isControl ?? false,
      isGlobalWinner: false,
    }).onConflictDoNothing();
  }
  console.log(`[ab-testing] Seeded ${variants.length} variants for ${testType}`);
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Functions exported: grep for "export async function getActiveVariant"
  </verify>
  <done>
ab-testing.ts exists with getActiveVariant, assignVariant, recordOutcome, checkForWinner, promoteToGlobalWinner, seedVariants. Uses 20% threshold with 10 samples.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update optimization service index</name>
  <files>src/services/optimization/index.ts</files>
  <action>
Update `src/services/optimization/index.ts` to export A/B testing:

```typescript
export * from './metrics-collector';
export * from './alert-detector';
export * from './ab-testing';
```
  </action>
  <verify>
Export exists: grep for "ab-testing" in index.ts
  </verify>
  <done>
A/B testing exports available from optimization service index.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate A/B testing with review request messages</name>
  <files>src/services/review-request/messages.ts</files>
  <action>
Update `src/services/review-request/messages.ts` to use A/B testing for message templates:

1. Import A/B testing:
```typescript
import { getActiveVariant, recordOutcome } from '../optimization/ab-testing';
```

2. Modify the message composition function (e.g., `composeReviewRequestMessage`) to:
   - Check for active variant using getActiveVariant(tenantId, 'review_request_message')
   - If variant exists, use variantContent to modify message
   - If no variant, use default message (backward compatible)

Example modification:
```typescript
export async function composeReviewRequestMessage(
  tenantId: string,
  customerName: string,
  businessName: string,
  reviewLink: string
): Promise<string> {
  // Check for A/B test variant
  const variant = await getActiveVariant(tenantId, 'review_request_message');

  if (variant) {
    const content = JSON.parse(variant.variantContent) as {
      template: string;
      emoji?: boolean;
      tone?: 'formal' | 'friendly' | 'casual';
    };

    // Use variant template if defined
    if (content.template) {
      return content.template
        .replace('{customerName}', customerName)
        .replace('{businessName}', businessName)
        .replace('{reviewLink}', reviewLink);
    }
  }

  // Default message (control)
  return `砖 ${customerName},

转 砖专转 ${businessName}! 

砖   转/ 砖转祝 转  砖 :
${reviewLink}

拽专转 砖 注专转  砖转驻专 注专 拽转 住驻 爪 转.

转 专!`;
}
```

3. Track outcomes in review completion detection (src/services/review-request/completion.ts):
   - When a review is detected after a request, call recordOutcome with success=true
   - When request expires without review, call recordOutcome with success=false

Add to completion.ts (if function exists) or note for future integration:
```typescript
// After detecting review completion
await recordOutcome(tenantId, 'review_request_message', true);

// After request times out without review (in review-request worker)
await recordOutcome(tenantId, 'review_request_message', false);
```
  </action>
  <verify>
grep for "getActiveVariant" in messages.ts
grep for "review_request_message" in messages.ts
  </verify>
  <done>
Review request messages use A/B test variant if assigned, falls back to default template. Outcomes tracked for winner detection.
  </done>
</task>

</tasks>

<verification>
1. A/B testing service exists: `ls src/services/optimization/ab-testing.ts`
2. Exported from index: grep for "ab-testing" in optimization/index.ts
3. Integrated with messages: grep for "getActiveVariant" in messages.ts
4. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- A/B testing service can assign/track variants
- Winner detection uses 20% threshold + 10 samples
- Review request messages check for variant before composing
- Outcomes tracked for conversion calculation
</success_criteria>

<output>
After completion, create `.planning/phases/08-gbp-optimization/08-06-SUMMARY.md`
</output>
