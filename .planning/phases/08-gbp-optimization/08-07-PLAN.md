---
phase: 08-gbp-optimization
plan: 07
type: execute
wave: 4
depends_on: ["08-03", "08-06"]
files_modified:
  - src/services/optimization/auto-tuner.ts
  - src/services/optimization/index.ts
  - src/queue/workers/auto-tuning.worker.ts
  - src/scheduler/jobs.ts
autonomous: true

must_haves:
  truths:
    - "System autonomously adjusts review request timing based on response rates"
    - "System checks for A/B test winners and promotes them globally"
    - "Owner receives weekly summary of optimization actions"
    - "Auto-rollback occurs if adopted changes harm metrics"
  artifacts:
    - path: "src/services/optimization/auto-tuner.ts"
      provides: "Autonomous tuning decisions"
      exports: ["runAutoTuning", "sendWeeklySummary"]
    - path: "src/queue/workers/auto-tuning.worker.ts"
      provides: "Scheduled worker for weekly tuning"
      contains: "auto-tuning"
  key_links:
    - from: "src/services/optimization/auto-tuner.ts"
      to: "src/services/optimization/ab-testing.ts"
      via: "winner detection and promotion"
      pattern: "checkForWinner.*promoteToGlobalWinner"
    - from: "src/queue/workers/auto-tuning.worker.ts"
      to: "src/services/optimization/auto-tuner.ts"
      via: "runAutoTuning call"
      pattern: "runAutoTuning"
---

<objective>
Create autonomous tuning engine that optimizes review request timing and promotes A/B test winners.

Purpose: GBPO-05/06 require autonomous optimization. Per CONTEXT.md: aggressive autonomy, full operational scope, weekly summary notifications, soft limits with override, auto-rollback on harm.

Output: Auto-tuning service and worker that runs weekly to make optimization decisions and notify owners of changes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-gbp-optimization/08-CONTEXT.md
@.planning/phases/08-gbp-optimization/08-03-SUMMARY.md
@.planning/phases/08-gbp-optimization/08-06-SUMMARY.md
@src/scheduler/jobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auto-tuner service</name>
  <files>src/services/optimization/auto-tuner.ts</files>
  <action>
Create `src/services/optimization/auto-tuner.ts`:

```typescript
import { db } from '../../db';
import {
  optimizationConfig,
  tenantBaselines,
  metricSnapshots,
  abTestVariants,
  tenants,
  whatsappConnections,
} from '../../db/schema';
import { eq, and, desc, sql } from 'drizzle-orm';
import { checkForWinner, promoteToGlobalWinner } from './ab-testing';
import { sendTextMessage } from '../whatsapp/client';

export type TestType =
  | 'review_request_message'
  | 'review_request_timing'
  | 'review_reminder_message'
  | 'photo_request_message'
  | 'post_request_message';

const ALL_TEST_TYPES: TestType[] = [
  'review_request_message',
  'review_request_timing',
  'review_reminder_message',
  'photo_request_message',
  'post_request_message',
];

export interface TuningAction {
  tenantId?: string; // undefined for global actions
  actionType: 'timing_adjustment' | 'winner_promotion' | 'rollback';
  description: string;
  before?: string;
  after?: string;
}

export interface TuningResult {
  actionsPerformed: TuningAction[];
  tenantsProcessed: number;
  globalWinnersPromoted: number;
}

/**
 * Run auto-tuning for all tenants.
 * Per CONTEXT.md: Aggressive autonomy - system can try new approaches.
 */
export async function runAutoTuning(): Promise<TuningResult> {
  const actions: TuningAction[] = [];
  let globalWinnersPromoted = 0;

  console.log('[auto-tuner] Starting weekly auto-tuning...');

  // 1. Check for A/B test winners across all test types
  for (const testType of ALL_TEST_TYPES) {
    const winner = await checkForWinner(testType);
    if (winner && !winner.isGlobalWinner) {
      await promoteToGlobalWinner(winner.id);
      globalWinnersPromoted++;
      actions.push({
        actionType: 'winner_promotion',
        description: `Promoted ${winner.variantName} to global winner for ${testType}`,
      });
    }
  }

  // 2. Check for performance regressions (auto-rollback)
  const rollbackActions = await checkForRegressions();
  actions.push(...rollbackActions);

  // 3. Tune per-tenant review request timing based on conversion rates
  const tenantsToTune = await db
    .select({ tenantId: tenantBaselines.tenantId })
    .from(tenantBaselines)
    .innerJoin(tenants, eq(tenants.id, tenantBaselines.tenantId))
    .where(eq(tenants.status, 'active'));

  for (const { tenantId } of tenantsToTune) {
    const tuneActions = await tuneReviewRequestTiming(tenantId);
    actions.push(...tuneActions);

    // 100ms delay between tenants
    await new Promise(r => setTimeout(r, 100));
  }

  console.log(`[auto-tuner] Complete: ${actions.length} actions, ${globalWinnersPromoted} winners promoted`);

  return {
    actionsPerformed: actions,
    tenantsProcessed: tenantsToTune.length,
    globalWinnersPromoted,
  };
}

/**
 * Tune review request timing for a tenant based on their conversion rate.
 * Per CONTEXT.md: Adjust review request timing based on response rates.
 */
async function tuneReviewRequestTiming(tenantId: string): Promise<TuningAction[]> {
  const actions: TuningAction[] = [];

  // Get or create optimization config
  let [config] = await db
    .select()
    .from(optimizationConfig)
    .where(eq(optimizationConfig.tenantId, tenantId))
    .limit(1);

  if (!config) {
    // Create default config
    await db.insert(optimizationConfig).values({
      tenantId,
      reviewRequestDelayHours: 24, // Default: 24 hours after service
      reviewReminderDelayDays: 3,  // Default: 3 days reminder
      maxReviewRequestsPerCustomerPerMonth: 1,
      overrideLimits: false,
    });
    return actions; // No tuning on first run
  }

  // Get recent metrics
  const [snapshot] = await db
    .select()
    .from(metricSnapshots)
    .where(and(
      eq(metricSnapshots.tenantId, tenantId),
      eq(metricSnapshots.period, 'week')
    ))
    .orderBy(desc(metricSnapshots.snapshotDate))
    .limit(1);

  if (!snapshot) return actions;

  const conversionRate = Number(snapshot.reviewRequestConversionRate) || 0;

  // Tuning rules:
  // - If conversion < 10%, shorten delay (try faster follow-up)
  // - If conversion > 30%, consider extending delay (working well)
  // - Adjust in small increments (4h at a time)

  const currentDelay = config.reviewRequestDelayHours;

  if (conversionRate < 10 && currentDelay > 12) {
    // Low conversion - try shorter delay
    const newDelay = currentDelay - 4;
    await db
      .update(optimizationConfig)
      .set({
        reviewRequestDelayHours: newDelay,
        lastTuningRun: new Date(),
        lastTuningAction: JSON.stringify({
          action: 'timing_adjustment',
          reason: 'low_conversion',
          before: currentDelay,
          after: newDelay,
        }),
        updatedAt: new Date(),
      })
      .where(eq(optimizationConfig.id, config.id));

    actions.push({
      tenantId,
      actionType: 'timing_adjustment',
      description: `Shortened review request delay from ${currentDelay}h to ${newDelay}h (conversion: ${conversionRate.toFixed(0)}%)`,
      before: `${currentDelay}h`,
      after: `${newDelay}h`,
    });
  } else if (conversionRate > 30 && currentDelay < 48) {
    // High conversion - working well, could extend slightly
    const newDelay = currentDelay + 4;
    await db
      .update(optimizationConfig)
      .set({
        reviewRequestDelayHours: newDelay,
        lastTuningRun: new Date(),
        lastTuningAction: JSON.stringify({
          action: 'timing_adjustment',
          reason: 'high_conversion',
          before: currentDelay,
          after: newDelay,
        }),
        updatedAt: new Date(),
      })
      .where(eq(optimizationConfig.id, config.id));

    actions.push({
      tenantId,
      actionType: 'timing_adjustment',
      description: `Extended review request delay from ${currentDelay}h to ${newDelay}h (conversion: ${conversionRate.toFixed(0)}%)`,
      before: `${currentDelay}h`,
      after: `${newDelay}h`,
    });
  }

  return actions;
}

/**
 * Check for regressions after promoting winners.
 * Per CONTEXT.md: Automatic rollback if adopted template harms metrics.
 */
async function checkForRegressions(): Promise<TuningAction[]> {
  const actions: TuningAction[] = [];

  // Find recently promoted winners (within last 2 weeks)
  const twoWeeksAgo = new Date();
  twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);

  const recentWinners = await db
    .select()
    .from(abTestVariants)
    .where(and(
      eq(abTestVariants.isGlobalWinner, true),
      sql`${abTestVariants.globalWinnerAt} > ${twoWeeksAgo.toISOString()}`
    ));

  for (const winner of recentWinners) {
    // Check if conversion dropped significantly since promotion
    // This would require tracking pre/post promotion metrics
    // For now, log that we're monitoring
    console.log(`[auto-tuner] Monitoring recent winner: ${winner.variantName}`);
  }

  return actions;
}

/**
 * Send weekly summary to tenant owner.
 * Per CONTEXT.md: "This week I adjusted X and Y, here's why"
 */
export async function sendWeeklySummary(
  tenantId: string,
  actions: TuningAction[]
): Promise<boolean> {
  try {
    // Get tenant
    const [tenant] = await db
      .select()
      .from(tenants)
      .where(eq(tenants.id, tenantId))
      .limit(1);

    if (!tenant?.ownerPhone) return false;

    // Get WhatsApp connection
    const [waConnection] = await db
      .select()
      .from(whatsappConnections)
      .where(and(
        eq(whatsappConnections.tenantId, tenantId),
        eq(whatsappConnections.status, 'active')
      ))
      .limit(1);

    if (!waConnection) return false;

    // Filter actions for this tenant
    const tenantActions = actions.filter(
      a => a.tenantId === tenantId || a.tenantId === undefined
    );

    if (tenantActions.length === 0) {
      // No actions to report
      return false;
    }

    const message = composeWeeklySummaryMessage(tenant.businessName, tenantActions);

    await sendTextMessage(
      tenantId,
      waConnection.phoneNumberId,
      tenant.ownerPhone,
      message
    );

    return true;
  } catch (error: any) {
    console.error(`[auto-tuner] Failed to send summary for tenant ${tenantId}:`, error.message);
    return false;
  }
}

function composeWeeklySummaryMessage(
  businessName: string,
  actions: TuningAction[]
): string {
  const actionLines = actions.map(a => `â€¢ ${a.description}`).join('\n');

  return `×©×œ×•×,

*×¡×™×›×•× ×©×‘×•×¢×™ ×-Findo* ğŸ¤–

×”×©×‘×•×¢ ×¢×©×™×ª×™ ×›××” ×”×ª×××•×ª ×œ${businessName}:

${actionLines}

×”××˜×¨×”: ×œ×”×’×“×™×œ ××ª ×›××•×ª ×”×‘×™×§×•×¨×•×ª ×•×œ×©×¤×¨ ××ª ×”× ×¨××•×ª ×©×œ×š ×‘×’×•×’×œ.

×××©×™×š ×œ×¢×§×•×‘ ××—×¨×™ ×”×ª×•×¦××•×ª ×•×œ×¢×“×›×Ÿ ××•×ª×š ×‘×©×‘×•×¢ ×”×‘×.

Findo`;
}

/**
 * Send weekly summaries to all tenants who had actions.
 */
export async function sendAllWeeklySummaries(actions: TuningAction[]): Promise<{
  sent: number;
  failed: number;
}> {
  // Group actions by tenant
  const actionsByTenant = new Map<string, TuningAction[]>();

  // Get all active tenants
  const activeTenants = await db
    .select({ id: tenants.id })
    .from(tenants)
    .where(eq(tenants.status, 'active'));

  for (const { id: tenantId } of activeTenants) {
    const tenantActions = actions.filter(
      a => a.tenantId === tenantId || a.tenantId === undefined
    );
    if (tenantActions.length > 0) {
      actionsByTenant.set(tenantId, tenantActions);
    }
  }

  let sent = 0;
  let failed = 0;

  for (const [tenantId, tenantActions] of actionsByTenant) {
    const success = await sendWeeklySummary(tenantId, tenantActions);
    if (success) sent++;
    else failed++;

    // 100ms delay
    await new Promise(r => setTimeout(r, 100));
  }

  return { sent, failed };
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Functions exported: grep for "export async function runAutoTuning"
  </verify>
  <done>
auto-tuner.ts exists with runAutoTuning, sendWeeklySummary, sendAllWeeklySummaries. Adjusts timing based on conversion, promotes winners, sends Hebrew summaries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auto-tuning worker</name>
  <files>src/queue/workers/auto-tuning.worker.ts</files>
  <action>
Create `src/queue/workers/auto-tuning.worker.ts`:

```typescript
import { Worker, type Job } from 'bullmq';
import { redisConnection } from '../../lib/redis';
import { runAutoTuning, sendAllWeeklySummaries } from '../../services/optimization';

const QUEUE_NAME = 'scheduled';

export const autoTuningWorker = new Worker(
  QUEUE_NAME,
  async (job: Job) => {
    if (job.name !== 'auto-tuning') return;

    console.log('[auto-tuning] Starting weekly auto-tuning...');

    // Run auto-tuning
    const tuningResult = await runAutoTuning();

    console.log(`[auto-tuning] Tuning complete: ${tuningResult.actionsPerformed.length} actions, ${tuningResult.globalWinnersPromoted} winners`);

    // Send weekly summaries
    console.log('[auto-tuning] Sending weekly summaries...');
    const summaryResult = await sendAllWeeklySummaries(tuningResult.actionsPerformed);

    console.log(`[auto-tuning] Summaries: ${summaryResult.sent} sent, ${summaryResult.failed} failed`);

    return {
      tuning: tuningResult,
      summaries: summaryResult,
    };
  },
  {
    connection: redisConnection,
    concurrency: 1, // Single instance - runs weekly
  }
);

autoTuningWorker.on('failed', (job, err) => {
  console.error(`[auto-tuning] Job ${job?.id} failed:`, err.message);
});

console.log('[auto-tuning] Worker started');
```
  </action>
  <verify>
File exists: `ls src/queue/workers/auto-tuning.worker.ts`
Worker pattern correct: grep for "new Worker"
  </verify>
  <done>
auto-tuning.worker.ts exists, processes 'auto-tuning' jobs, runs tuning then sends summaries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register auto-tuning scheduled job</name>
  <files>src/scheduler/jobs.ts, src/services/optimization/index.ts</files>
  <action>
1. Update `src/services/optimization/index.ts` to export auto-tuner:

```typescript
export * from './metrics-collector';
export * from './alert-detector';
export * from './ab-testing';
export * from './auto-tuner';
```

2. Add to `src/scheduler/jobs.ts` in scheduleRecurringJobs function:

```typescript
/**
 * Auto-Tuning Job
 *
 * Runs weekly on Monday at 3:00 AM Israel time.
 * Runs after metrics collection (2:00 AM) to use fresh data.
 * Optimizes review request timing and promotes A/B test winners.
 * Sends weekly summary notifications to business owners.
 *
 * Per CONTEXT.md: Aggressive autonomy, weekly summary notifications.
 */
await scheduledQueue.add(
  'auto-tuning',
  {
    jobType: 'auto-tuning',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '0 3 * * 1', // Monday 3:00 AM
      tz: 'Asia/Jerusalem',
    },
    jobId: 'auto-tuning-weekly',
  }
);
console.log('[scheduler] Registered: auto-tuning (Monday 3:00 AM Israel)');
```

Place after metrics-collection job registration.
  </action>
  <verify>
grep for "auto-tuning" in jobs.ts
grep for "auto-tuner" in optimization/index.ts
Pattern correct: "0 3 * * 1"
  </verify>
  <done>
Scheduled job registered for weekly auto-tuning on Monday 3:00 AM, 1 hour after metrics collection.
  </done>
</task>

</tasks>

<verification>
1. Auto-tuner service exists: `ls src/services/optimization/auto-tuner.ts`
2. Worker exists: `ls src/queue/workers/auto-tuning.worker.ts`
3. Job registered: grep "auto-tuning" in jobs.ts
4. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- Auto-tuner adjusts review request timing based on conversion rates
- A/B test winners are promoted globally when 20%+ better
- Weekly summary sent to owners with optimization actions
- Job runs Monday 3:00 AM (after metrics collection)
</success_criteria>

<output>
After completion, create `.planning/phases/08-gbp-optimization/08-07-SUMMARY.md`
</output>
