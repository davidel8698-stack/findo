---
phase: 08-gbp-optimization
plan: 07
type: execute
wave: 4
depends_on: ["08-03", "08-06"]
files_modified:
  - src/services/optimization/auto-tuner.ts
  - src/services/optimization/ab-testing.ts
  - src/services/optimization/index.ts
  - src/queue/workers/auto-tuning.worker.ts
  - src/scheduler/jobs.ts
autonomous: true

must_haves:
  truths:
    - "System autonomously adjusts review request timing based on response rates"
    - "System checks for A/B test winners and promotes them globally"
    - "Existing tenant assignments are migrated to winning variants"
    - "Owner receives weekly summary of optimization actions"
    - "Auto-rollback occurs if adopted changes harm metrics"
  artifacts:
    - path: "src/services/optimization/auto-tuner.ts"
      provides: "Autonomous tuning decisions"
      exports: ["runAutoTuning", "sendWeeklySummary"]
    - path: "src/services/optimization/ab-testing.ts"
      provides: "Winner migration function"
      exports: ["migrateToWinner"]
    - path: "src/queue/workers/auto-tuning.worker.ts"
      provides: "Scheduled worker for weekly tuning"
      contains: "auto-tuning"
  key_links:
    - from: "src/services/optimization/auto-tuner.ts"
      to: "src/services/optimization/ab-testing.ts"
      via: "winner detection, promotion, and migration"
      pattern: "checkForWinner.*promoteToGlobalWinner.*migrateToWinner"
    - from: "src/queue/workers/auto-tuning.worker.ts"
      to: "src/services/optimization/auto-tuner.ts"
      via: "runAutoTuning call"
      pattern: "runAutoTuning"
---

<objective>
Create autonomous tuning engine that optimizes review request timing and promotes A/B test winners.

Purpose: GBPO-05/06 require autonomous optimization. Per CONTEXT.md: aggressive autonomy, full operational scope, weekly summary notifications, soft limits with override, auto-rollback on harm.

Output: Auto-tuning service and worker that runs weekly to make optimization decisions and notify owners of changes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-gbp-optimization/08-CONTEXT.md
@.planning/phases/08-gbp-optimization/08-03-SUMMARY.md
@.planning/phases/08-gbp-optimization/08-06-SUMMARY.md
@src/scheduler/jobs.ts
@src/services/optimization/ab-testing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add winner migration function to ab-testing service</name>
  <files>src/services/optimization/ab-testing.ts</files>
  <action>
Add a `migrateToWinner` function to `src/services/optimization/ab-testing.ts` that migrates existing tenant assignments to the winning variant when a winner is promoted.

Add this function after `promoteToGlobalWinner`:

```typescript
/**
 * Migrate all existing tenant assignments to the winning variant.
 * Called after promoteToGlobalWinner to ensure all tenants benefit from the winner.
 * Per GBPO-06: "auto-adopt winners globally" means ALL tenants, not just new ones.
 *
 * @param variantId - The winning variant ID
 * @returns Number of assignments migrated
 */
export async function migrateToWinner(variantId: string): Promise<number> {
  const [winner] = await db
    .select()
    .from(abTestVariants)
    .where(eq(abTestVariants.id, variantId))
    .limit(1);

  if (!winner) {
    throw new Error(`Variant ${variantId} not found`);
  }

  // Get all other variants for this test type (losers)
  const losingVariants = await db
    .select({ id: abTestVariants.id })
    .from(abTestVariants)
    .where(and(
      eq(abTestVariants.testType, winner.testType),
      sql`${abTestVariants.id} != ${variantId}`
    ));

  const losingVariantIds = losingVariants.map(v => v.id);

  if (losingVariantIds.length === 0) {
    return 0; // No other variants to migrate from
  }

  // Deactivate all assignments to losing variants
  const deactivated = await db
    .update(abTestAssignments)
    .set({
      isActive: false,
      updatedAt: new Date(),
    })
    .where(and(
      inArray(abTestAssignments.variantId, losingVariantIds),
      eq(abTestAssignments.isActive, true)
    ));

  // Get tenants who were on losing variants and need new assignments
  const tenantsToMigrate = await db
    .select({ tenantId: abTestAssignments.tenantId })
    .from(abTestAssignments)
    .where(and(
      inArray(abTestAssignments.variantId, losingVariantIds),
      eq(abTestAssignments.isActive, false)
    ))
    .groupBy(abTestAssignments.tenantId);

  let migratedCount = 0;

  for (const { tenantId } of tenantsToMigrate) {
    // Check if tenant already has active assignment to winner
    const existingWinnerAssignment = await db
      .select()
      .from(abTestAssignments)
      .where(and(
        eq(abTestAssignments.tenantId, tenantId),
        eq(abTestAssignments.variantId, variantId),
        eq(abTestAssignments.isActive, true)
      ))
      .limit(1);

    if (existingWinnerAssignment.length === 0) {
      // Create new assignment to winner
      await createAssignment(tenantId, variantId);
      migratedCount++;
    }
  }

  console.log(`[ab-testing] Migrated ${migratedCount} tenants to winner ${winner.variantName}`);
  return migratedCount;
}
```

Also add `inArray` to the drizzle-orm imports at the top if not already present:
```typescript
import { eq, and, isNull, sql, inArray } from 'drizzle-orm';
```
  </action>
  <verify>
1. Function exported: `grep -n "export async function migrateToWinner" src/services/optimization/ab-testing.ts`
2. inArray import: `grep -n "inArray" src/services/optimization/ab-testing.ts`
  </verify>
  <done>
migrateToWinner function exists in ab-testing.ts. Deactivates losing variant assignments and creates new assignments to winning variant for all affected tenants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auto-tuner service with winner migration</name>
  <files>src/services/optimization/auto-tuner.ts</files>
  <action>
Create `src/services/optimization/auto-tuner.ts`:

```typescript
import { db } from '../../db';
import {
  optimizationConfig,
  tenantBaselines,
  metricSnapshots,
  abTestVariants,
  tenants,
  whatsappConnections,
} from '../../db/schema';
import { eq, and, desc, sql } from 'drizzle-orm';
import { checkForWinner, promoteToGlobalWinner, migrateToWinner } from './ab-testing';
import { sendTextMessage } from '../whatsapp/client';

export type TestType =
  | 'review_request_message'
  | 'review_request_timing'
  | 'review_reminder_message'
  | 'photo_request_message'
  | 'post_request_message';

const ALL_TEST_TYPES: TestType[] = [
  'review_request_message',
  'review_request_timing',
  'review_reminder_message',
  'photo_request_message',
  'post_request_message',
];

export interface TuningAction {
  tenantId?: string; // undefined for global actions
  actionType: 'timing_adjustment' | 'winner_promotion' | 'winner_migration' | 'rollback';
  description: string;
  before?: string;
  after?: string;
}

export interface TuningResult {
  actionsPerformed: TuningAction[];
  tenantsProcessed: number;
  globalWinnersPromoted: number;
  tenantsMigrated: number;
}

/**
 * Run auto-tuning for all tenants.
 * Per CONTEXT.md: Aggressive autonomy - system can try new approaches.
 */
export async function runAutoTuning(): Promise<TuningResult> {
  const actions: TuningAction[] = [];
  let globalWinnersPromoted = 0;
  let totalMigrated = 0;

  console.log('[auto-tuner] Starting weekly auto-tuning...');

  // 1. Check for A/B test winners across all test types
  for (const testType of ALL_TEST_TYPES) {
    const winner = await checkForWinner(testType);
    if (winner && !winner.isGlobalWinner) {
      // Promote to global winner
      await promoteToGlobalWinner(winner.id);
      globalWinnersPromoted++;
      actions.push({
        actionType: 'winner_promotion',
        description: `Promoted ${winner.variantName} to global winner for ${testType}`,
      });

      // Migrate existing tenants to winner (GBPO-06 requirement)
      const migratedCount = await migrateToWinner(winner.id);
      totalMigrated += migratedCount;
      if (migratedCount > 0) {
        actions.push({
          actionType: 'winner_migration',
          description: `Migrated ${migratedCount} tenants from losing variants to ${winner.variantName}`,
        });
      }
    }
  }

  // 2. Check for performance regressions (auto-rollback)
  const rollbackActions = await checkForRegressions();
  actions.push(...rollbackActions);

  // 3. Tune per-tenant review request timing based on conversion rates
  const tenantsToTune = await db
    .select({ tenantId: tenantBaselines.tenantId })
    .from(tenantBaselines)
    .innerJoin(tenants, eq(tenants.id, tenantBaselines.tenantId))
    .where(eq(tenants.status, 'active'));

  for (const { tenantId } of tenantsToTune) {
    const tuneActions = await tuneReviewRequestTiming(tenantId);
    actions.push(...tuneActions);

    // 100ms delay between tenants
    await new Promise(r => setTimeout(r, 100));
  }

  console.log(`[auto-tuner] Complete: ${actions.length} actions, ${globalWinnersPromoted} winners promoted, ${totalMigrated} tenants migrated`);

  return {
    actionsPerformed: actions,
    tenantsProcessed: tenantsToTune.length,
    globalWinnersPromoted,
    tenantsMigrated: totalMigrated,
  };
}

/**
 * Tune review request timing for a tenant based on their conversion rate.
 * Per CONTEXT.md: Adjust review request timing based on response rates.
 */
async function tuneReviewRequestTiming(tenantId: string): Promise<TuningAction[]> {
  const actions: TuningAction[] = [];

  // Get or create optimization config
  let [config] = await db
    .select()
    .from(optimizationConfig)
    .where(eq(optimizationConfig.tenantId, tenantId))
    .limit(1);

  if (!config) {
    // Create default config
    await db.insert(optimizationConfig).values({
      tenantId,
      reviewRequestDelayHours: 24, // Default: 24 hours after service
      reviewReminderDelayDays: 3,  // Default: 3 days reminder
      maxReviewRequestsPerCustomerPerMonth: 1,
      overrideLimits: false,
    });
    return actions; // No tuning on first run
  }

  // Get recent metrics
  const [snapshot] = await db
    .select()
    .from(metricSnapshots)
    .where(and(
      eq(metricSnapshots.tenantId, tenantId),
      eq(metricSnapshots.period, 'week')
    ))
    .orderBy(desc(metricSnapshots.snapshotDate))
    .limit(1);

  if (!snapshot) return actions;

  const conversionRate = Number(snapshot.reviewRequestConversionRate) || 0;

  // Tuning rules:
  // - If conversion < 10%, shorten delay (try faster follow-up)
  // - If conversion > 30%, consider extending delay (working well)
  // - Adjust in small increments (4h at a time)

  const currentDelay = config.reviewRequestDelayHours;

  if (conversionRate < 10 && currentDelay > 12) {
    // Low conversion - try shorter delay
    const newDelay = currentDelay - 4;
    await db
      .update(optimizationConfig)
      .set({
        reviewRequestDelayHours: newDelay,
        lastTuningRun: new Date(),
        lastTuningAction: JSON.stringify({
          action: 'timing_adjustment',
          reason: 'low_conversion',
          before: currentDelay,
          after: newDelay,
        }),
        updatedAt: new Date(),
      })
      .where(eq(optimizationConfig.id, config.id));

    actions.push({
      tenantId,
      actionType: 'timing_adjustment',
      description: `Shortened review request delay from ${currentDelay}h to ${newDelay}h (conversion: ${conversionRate.toFixed(0)}%)`,
      before: `${currentDelay}h`,
      after: `${newDelay}h`,
    });
  } else if (conversionRate > 30 && currentDelay < 48) {
    // High conversion - working well, could extend slightly
    const newDelay = currentDelay + 4;
    await db
      .update(optimizationConfig)
      .set({
        reviewRequestDelayHours: newDelay,
        lastTuningRun: new Date(),
        lastTuningAction: JSON.stringify({
          action: 'timing_adjustment',
          reason: 'high_conversion',
          before: currentDelay,
          after: newDelay,
        }),
        updatedAt: new Date(),
      })
      .where(eq(optimizationConfig.id, config.id));

    actions.push({
      tenantId,
      actionType: 'timing_adjustment',
      description: `Extended review request delay from ${currentDelay}h to ${newDelay}h (conversion: ${conversionRate.toFixed(0)}%)`,
      before: `${currentDelay}h`,
      after: `${newDelay}h`,
    });
  }

  return actions;
}

/**
 * Check for regressions after promoting winners.
 * Per CONTEXT.md: Automatic rollback if adopted template harms metrics.
 */
async function checkForRegressions(): Promise<TuningAction[]> {
  const actions: TuningAction[] = [];

  // Find recently promoted winners (within last 2 weeks)
  const twoWeeksAgo = new Date();
  twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);

  const recentWinners = await db
    .select()
    .from(abTestVariants)
    .where(and(
      eq(abTestVariants.isGlobalWinner, true),
      sql`${abTestVariants.globalWinnerAt} > ${twoWeeksAgo.toISOString()}`
    ));

  for (const winner of recentWinners) {
    // Check if conversion dropped significantly since promotion
    // This would require tracking pre/post promotion metrics
    // For now, log that we're monitoring
    console.log(`[auto-tuner] Monitoring recent winner: ${winner.variantName}`);
  }

  return actions;
}

/**
 * Send weekly summary to tenant owner.
 * Per CONTEXT.md: "This week I adjusted X and Y, here's why"
 */
export async function sendWeeklySummary(
  tenantId: string,
  actions: TuningAction[]
): Promise<boolean> {
  try {
    // Get tenant
    const [tenant] = await db
      .select()
      .from(tenants)
      .where(eq(tenants.id, tenantId))
      .limit(1);

    if (!tenant?.ownerPhone) return false;

    // Get WhatsApp connection
    const [waConnection] = await db
      .select()
      .from(whatsappConnections)
      .where(and(
        eq(whatsappConnections.tenantId, tenantId),
        eq(whatsappConnections.status, 'active')
      ))
      .limit(1);

    if (!waConnection) return false;

    // Filter actions for this tenant
    const tenantActions = actions.filter(
      a => a.tenantId === tenantId || a.tenantId === undefined
    );

    if (tenantActions.length === 0) {
      // No actions to report
      return false;
    }

    const message = composeWeeklySummaryMessage(tenant.businessName, tenantActions);

    await sendTextMessage(
      tenantId,
      waConnection.phoneNumberId,
      tenant.ownerPhone,
      message
    );

    return true;
  } catch (error: any) {
    console.error(`[auto-tuner] Failed to send summary for tenant ${tenantId}:`, error.message);
    return false;
  }
}

function composeWeeklySummaryMessage(
  businessName: string,
  actions: TuningAction[]
): string {
  const actionLines = actions.map(a => `* ${a.description}`).join('\n');

  return `שלום,

*סיכום שבועי מ-Findo*

השבוע עשיתי כמה התאמות ל${businessName}:

${actionLines}

המטרה: להגדיל את כמות הביקורות ולשפר את הנראות שלך בגוגל.

אמשיך לעקוב אחרי התוצאות ולעדכן אותך בשבוע הבא.

Findo`;
}

/**
 * Send weekly summaries to all tenants who had actions.
 */
export async function sendAllWeeklySummaries(actions: TuningAction[]): Promise<{
  sent: number;
  failed: number;
}> {
  // Group actions by tenant
  const actionsByTenant = new Map<string, TuningAction[]>();

  // Get all active tenants
  const activeTenants = await db
    .select({ id: tenants.id })
    .from(tenants)
    .where(eq(tenants.status, 'active'));

  for (const { id: tenantId } of activeTenants) {
    const tenantActions = actions.filter(
      a => a.tenantId === tenantId || a.tenantId === undefined
    );
    if (tenantActions.length > 0) {
      actionsByTenant.set(tenantId, tenantActions);
    }
  }

  let sent = 0;
  let failed = 0;

  for (const [tenantId, tenantActions] of actionsByTenant) {
    const success = await sendWeeklySummary(tenantId, tenantActions);
    if (success) sent++;
    else failed++;

    // 100ms delay
    await new Promise(r => setTimeout(r, 100));
  }

  return { sent, failed };
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Functions exported: grep for "export async function runAutoTuning"
Winner migration called: grep for "migrateToWinner" in auto-tuner.ts
  </verify>
  <done>
auto-tuner.ts exists with runAutoTuning, sendWeeklySummary, sendAllWeeklySummaries. Calls migrateToWinner after promoting winners. Adjusts timing based on conversion, sends Hebrew summaries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auto-tuning worker and register scheduled job</name>
  <files>src/queue/workers/auto-tuning.worker.ts, src/scheduler/jobs.ts, src/services/optimization/index.ts</files>
  <action>
1. Create `src/queue/workers/auto-tuning.worker.ts`:

```typescript
import { Worker, type Job } from 'bullmq';
import { redisConnection } from '../../lib/redis';
import { runAutoTuning, sendAllWeeklySummaries } from '../../services/optimization';

const QUEUE_NAME = 'scheduled';

export const autoTuningWorker = new Worker(
  QUEUE_NAME,
  async (job: Job) => {
    if (job.name !== 'auto-tuning') return;

    console.log('[auto-tuning] Starting weekly auto-tuning...');

    // Run auto-tuning
    const tuningResult = await runAutoTuning();

    console.log(`[auto-tuning] Tuning complete: ${tuningResult.actionsPerformed.length} actions, ${tuningResult.globalWinnersPromoted} winners, ${tuningResult.tenantsMigrated} migrated`);

    // Send weekly summaries
    console.log('[auto-tuning] Sending weekly summaries...');
    const summaryResult = await sendAllWeeklySummaries(tuningResult.actionsPerformed);

    console.log(`[auto-tuning] Summaries: ${summaryResult.sent} sent, ${summaryResult.failed} failed`);

    return {
      tuning: tuningResult,
      summaries: summaryResult,
    };
  },
  {
    connection: redisConnection,
    concurrency: 1, // Single instance - runs weekly
  }
);

autoTuningWorker.on('failed', (job, err) => {
  console.error(`[auto-tuning] Job ${job?.id} failed:`, err.message);
});

console.log('[auto-tuning] Worker started');
```

2. Update `src/services/optimization/index.ts` to export auto-tuner:

```typescript
export * from './metrics-collector';
export * from './alert-detector';
export * from './ab-testing';
export * from './auto-tuner';
```

3. Add to `src/scheduler/jobs.ts` in scheduleRecurringJobs function:

```typescript
/**
 * Auto-Tuning Job
 *
 * Runs weekly on Monday at 3:00 AM Israel time.
 * Runs after metrics collection (2:00 AM) to use fresh data.
 * Optimizes review request timing and promotes A/B test winners.
 * Migrates existing tenants to winning variants.
 * Sends weekly summary notifications to business owners.
 *
 * Per CONTEXT.md: Aggressive autonomy, weekly summary notifications.
 */
await scheduledQueue.add(
  'auto-tuning',
  {
    jobType: 'auto-tuning',
  } satisfies ScheduledJobData,
  {
    repeat: {
      pattern: '0 3 * * 1', // Monday 3:00 AM
      tz: 'Asia/Jerusalem',
    },
    jobId: 'auto-tuning-weekly',
  }
);
console.log('[scheduler] Registered: auto-tuning (Monday 3:00 AM Israel)');
```

Place after metrics-collection job registration.
  </action>
  <verify>
1. Worker file exists: `ls src/queue/workers/auto-tuning.worker.ts`
2. Worker pattern correct: grep for "new Worker" in auto-tuning.worker.ts
3. Job registered: grep for "auto-tuning" in jobs.ts
4. Auto-tuner exported: grep for "auto-tuner" in optimization/index.ts
5. Cron pattern correct: grep for "0 3 \* \* 1" in jobs.ts
  </verify>
  <done>
auto-tuning.worker.ts exists, processes 'auto-tuning' jobs, runs tuning then sends summaries. Scheduled job registered for Monday 3:00 AM Israel time.
  </done>
</task>

</tasks>

<verification>
1. Winner migration function exists: grep for "migrateToWinner" in ab-testing.ts
2. Auto-tuner service exists: `ls src/services/optimization/auto-tuner.ts`
3. Auto-tuner calls migration: grep for "migrateToWinner" in auto-tuner.ts
4. Worker exists: `ls src/queue/workers/auto-tuning.worker.ts`
5. Job registered: grep "auto-tuning" in jobs.ts
6. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- migrateToWinner function migrates existing tenants to winning variants
- Auto-tuner adjusts review request timing based on conversion rates
- A/B test winners are promoted globally when 20%+ better
- Existing tenant assignments are migrated when winner is promoted
- Weekly summary sent to owners with optimization actions
- Job runs Monday 3:00 AM (after metrics collection)
</success_criteria>

<output>
After completion, create `.planning/phases/08-gbp-optimization/08-07-SUMMARY.md`
</output>
