---
phase: 19-performance-seo-certification
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - website/app/globals.css
  - website/lib/animation.ts
  - website/components/motion/variants.ts
  - website/components/sections/hero/ActivityFeed.tsx
autonomous: true

must_haves:
  truths:
    - "All animations run at 60fps on scroll"
    - "CLS is 0 (no layout shifts from fonts or animations)"
    - "Reduced motion preferences respected"
    - "Hero animations do not block LCP"
  artifacts:
    - path: "website/app/globals.css"
      provides: "Reduced motion CSS"
      contains: "prefers-reduced-motion"
    - path: "website/lib/animation.ts"
      provides: "GPU-optimized animation defaults"
      contains: "will-change"
  key_links:
    - from: "components/**"
      to: "lib/animation.ts"
      via: "animation config imports"
      pattern: "import.*animation"
---

<objective>
Optimize animations for 60fps performance and zero CLS, ensuring GPU acceleration, reduced motion support, and no LCP blocking.

Purpose: Achieve PERF-03 (CLS = 0), PERF-05 (60fps animations), and prepare for PERF-01/02 (Lighthouse 95+, LCP < 1.5s).
Output: Optimized animation configurations and reduced motion support.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/19-performance-seo-certification/19-RESEARCH.md
@website/app/globals.css
@website/lib/animation.ts
@website/components/motion/variants.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add comprehensive reduced motion support and CSS utilities</name>
  <files>
    website/app/globals.css
  </files>
  <action>
Add reduced motion CSS to globals.css. This respects user preferences for reduced motion (accessibility requirement):

```css
/**
 * Reduced Motion Support
 * Respects user's OS-level preference for reduced motion
 * Required for WCAG 2.1 AA compliance
 */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }

  /* Disable GSAP animations */
  .gsap-animate,
  [data-gsap] {
    opacity: 1 !important;
    transform: none !important;
  }

  /* Disable Motion library animations */
  [data-motion] {
    opacity: 1 !important;
    transform: none !important;
  }
}

/**
 * GPU Acceleration Hints
 * Applied to animated elements for smoother performance
 */
.gpu-accelerated {
  will-change: transform, opacity;
  transform: translateZ(0);
  backface-visibility: hidden;
}

/**
 * Prevent CLS from animations
 * Elements that animate in should have explicit dimensions
 */
.animate-in {
  contain: layout style;
}

/**
 * Contain layout utility for activity feed and animated containers
 * Prevents layout thrashing from child animations
 */
.contain-layout {
  contain: layout style;
}

/**
 * Save-Data preference support
 * Reduces animations on slow connections
 */
@media (prefers-reduced-data: reduce) {
  .non-essential-animation {
    animation: none !important;
    transition: none !important;
  }
}
```

Place this AFTER the existing CSS in globals.css (after tailwind imports).

NOTE: The `.contain-layout` class defined here will be used by Task 3 for ActivityFeed optimization.
  </action>
  <verify>
    - CSS includes prefers-reduced-motion media query
    - GPU acceleration class exists
    - `.contain-layout` utility class exists
    - No syntax errors in CSS
  </verify>
  <done>Reduced motion, GPU acceleration, and contain-layout CSS utilities added</done>
</task>

<task type="auto">
  <name>Task 2: Optimize animation configuration for 60fps</name>
  <files>
    website/lib/animation.ts
    website/components/motion/variants.ts
  </files>
  <action>
1. Update lib/animation.ts with optimized defaults:
   ```typescript
   /**
    * Animation configuration optimized for 60fps performance
    *
    * Key principles:
    * - Use transform and opacity only (GPU-accelerated)
    * - Avoid animating layout properties (width, height, margin, padding)
    * - Use will-change sparingly (only for elements that will animate)
    * - Remove will-change after animation completes
    */

   // Keep existing exports, add these optimized configs:

   /**
    * GPU-optimized spring config
    * Stiffer = snappier feel, less frames needed
    */
   export const gpuSpring = {
     type: "spring" as const,
     stiffness: 300,
     damping: 30,
     mass: 1,
   };

   /**
    * Duration-based transition for predictable timing
    * Use when spring physics not needed
    */
   export const gpuDuration = {
     type: "tween" as const,
     duration: 0.3,
     ease: [0.25, 0.1, 0.25, 1], // CSS ease-out
   };

   /**
    * Stagger config for list animations
    * Keep stagger short to avoid long total duration
    */
   export const staggerConfig = {
     staggerChildren: 0.05, // 50ms between children
     delayChildren: 0,
   };

   /**
    * Viewport trigger config
    * Trigger slightly before element is visible
    */
   export const viewportConfig = {
     once: true, // Only animate once
     amount: 0.2, // Trigger when 20% visible
     margin: "-50px", // Start 50px before visible
   };
   ```

2. Update components/motion/variants.ts with GPU-only transforms:
   Ensure all variants only animate transform and opacity:
   ```typescript
   /**
    * All variants use ONLY transform and opacity
    * This keeps animations on the GPU compositor thread
    *
    * NEVER animate: width, height, top, left, margin, padding, border
    * These cause layout recalculation and jank
    */

   // fadeInUp - verified GPU-only
   export const fadeInUp = {
     hidden: { opacity: 0, y: 20 },
     visible: {
       opacity: 1,
       y: 0,
       transition: { duration: 0.5, ease: "easeOut" },
     },
   };

   // scaleIn - verified GPU-only
   export const scaleIn = {
     hidden: { opacity: 0, scale: 0.95 },
     visible: {
       opacity: 1,
       scale: 1,
       transition: { duration: 0.3, ease: "easeOut" },
     },
   };

   // slideInEnd - verified GPU-only (uses translateX via x)
   export const slideInEnd = {
     hidden: { opacity: 0, x: -20 }, // RTL: slide from left
     visible: {
       opacity: 1,
       x: 0,
       transition: { duration: 0.4, ease: "easeOut" },
     },
   };

   // Add will-change cleanup variant
   export const withCleanup = {
     initial: { willChange: "transform, opacity" },
     animate: { willChange: "transform, opacity" },
     exit: { willChange: "auto" },
   };
   ```

3. Verify existing variants only use transform/opacity. If any animate layout properties, refactor them.
  </action>
  <verify>
    - animation.ts exports optimized configs
    - variants.ts only animates transform and opacity
    - No width/height/margin/padding animations
  </verify>
  <done>Animation system optimized for GPU-only 60fps performance</done>
</task>

<task type="auto">
  <name>Task 3: Optimize ActivityFeed for non-blocking LCP</name>
  <files>
    website/components/sections/hero/ActivityFeed.tsx
  </files>
  <action>
Ensure ActivityFeed animation doesn't block LCP:

1. Add requestIdleCallback wrapper for GSAP timeline:
   ```typescript
   useEffect(() => {
     // Delay animation until browser is idle
     // This ensures LCP (headline) renders first
     const startAnimation = () => {
       if (!containerRef.current) return;

       const cards = containerRef.current.querySelectorAll(".activity-card");
       if (!cards.length) return;

       // ... existing GSAP timeline setup ...
     };

     // Use requestIdleCallback if available, fallback to setTimeout
     if ('requestIdleCallback' in window) {
       requestIdleCallback(startAnimation, { timeout: 1000 });
     } else {
       setTimeout(startAnimation, 100);
     }

     return () => {
       // ... existing cleanup ...
     };
   }, []);
   ```

2. Add will-change optimization with cleanup:
   ```typescript
   // In GSAP timeline, add onComplete to remove will-change
   tl.eventCallback("onComplete", () => {
     cards.forEach((card) => {
       (card as HTMLElement).style.willChange = "auto";
     });
   });
   ```

3. Ensure cards have explicit dimensions to prevent CLS:
   The cards already have fixed heights via Tailwind classes - verify this:
   ```typescript
   // ActivityCard should have explicit h-[XX] class
   // If not, add min-height to prevent CLS
   ```

4. Add contain-layout class to the container (using the CSS utility added in Task 1):
   ```typescript
   // In ActivityFeed container - use the .contain-layout class from globals.css
   <div ref={containerRef} className="... contain-layout">
   ```

   The `.contain-layout` CSS class was added to globals.css in Task 1 of this plan:
   ```css
   .contain-layout {
     contain: layout style;
   }
   ```
  </action>
  <verify>
    - ActivityFeed uses requestIdleCallback or setTimeout
    - will-change removed after animation completes
    - Activity cards have explicit dimensions
    - Container uses contain-layout class
    - No CLS from activity feed animation
  </verify>
  <done>ActivityFeed optimized for non-blocking LCP and zero CLS</done>
</task>

</tasks>

<verification>
1. Run Lighthouse on mobile - check CLS is 0 or near 0
2. Enable "Rendering > Show Paint Flashing" in DevTools - verify animations don't cause full-page repaints
3. Check Performance panel - animations should stay on compositor thread
4. Test with "Reduce motion" OS setting - animations should be disabled
5. LCP should remain under 2.5s despite animations
</verification>

<success_criteria>
- CLS score is 0 in Lighthouse
- Animation frame rate is 60fps (check Performance panel)
- Reduced motion preference disables all animations
- Hero LCP element (headline) is not blocked by animations
- No layout-triggering properties animated
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-performance-seo-certification/19-04-SUMMARY.md`
</output>
