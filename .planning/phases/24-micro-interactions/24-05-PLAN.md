---
phase: 24-micro-interactions
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - website/components/sections/conversion/LeadCaptureForm.tsx
  # PhoneInput.tsx NOT modified - already supports error prop (string type)
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Input error prop shows destructive border and glow on validation error"
    - "Form fields shake when validation fails on submit"
    - "Error shake animation is gentle (1-2 cycles) not jarring"
    - "Error state clears when user starts typing"
  artifacts:
    - path: "website/components/sections/conversion/LeadCaptureForm.tsx"
      provides: "Error state integration with Input and useShake"
      contains: "useShake"
  key_links:
    - from: "website/components/sections/conversion/LeadCaptureForm.tsx"
      to: "website/lib/hooks/useShake.ts"
      via: "import useShake"
      pattern: "import.*useShake.*from"
    - from: "website/components/sections/conversion/LeadCaptureForm.tsx"
      to: "website/components/ui/input.tsx"
      via: "error prop"
      pattern: "error=\\{.*\\}"
---

<objective>
Wire form error states with Input error prop and useShake hook.

Purpose: Phase 24 built error handling components but never integrated them. This plan wires error states to show destructive styling + shake animation on validation failure.

Output: LeadCaptureForm shows error shake and red glow when submission fails.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/24-micro-interactions/24-VERIFICATION.md
@.planning/phases/24-micro-interactions/24-02-SUMMARY.md
@website/components/ui/input.tsx
@website/lib/hooks/useShake.ts
@website/components/sections/conversion/LeadCaptureForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire useShake hook and error state to LeadCaptureForm</name>
  <files>website/components/sections/conversion/LeadCaptureForm.tsx</files>
  <action>
    Integrate error state handling into LeadCaptureForm:

    1. Import useShake hook:
       ```tsx
       import { useShake } from "@/lib/hooks/useShake";
       ```

    2. Create refs for both inputs using useShake:
       ```tsx
       const { ref: nameRef, triggerShake: shakeName, clearError: clearNameError } = useShake<HTMLInputElement>();
       const { ref: phoneRef, triggerShake: shakePhone, clearError: clearPhoneError } = useShake<HTMLInputElement>();
       ```

    3. Add error state tracking (NOTE: use boolean for consistency with Input component):
       ```tsx
       const [fieldErrors, setFieldErrors] = useState<{ name?: boolean; phone?: boolean }>({});
       ```

       Type note: Input uses `error?: boolean`, PhoneInput uses `error?: string`.
       For PhoneInput, pass a truthy string (e.g., " ") or falsy value to match boolean semantics.
       The PhoneInput component applies destructive styling when error is truthy.

    4. Add useEffect to handle errors and trigger shakes:
       ```tsx
       useEffect(() => {
         if (state.error) {
           // Server returned error - shake both fields with gentle animation
           setFieldErrors({ name: true, phone: true });
           shakeName("gentle");
           shakePhone("gentle");
         }
       }, [state.error, shakeName, shakePhone]);
       ```

    5. Wire error prop to Input components:
       ```tsx
       <Input
         ref={nameRef}
         name="name"
         error={fieldErrors.name}
         onChange={() => {
           setFieldErrors(prev => ({ ...prev, name: false }));
           clearNameError();
         }}
         // ...rest of props
       />
       ```

    6. For PhoneInput - it ALREADY supports error prop (string type):
       - PhoneInput.tsx line 15: `error?: string;`
       - Lines 49-52 apply destructive styling when error is truthy
       - Pass `fieldErrors.phone ? " " : undefined` to convert boolean to string
       - For useShake, wrap PhoneInput in a div with the ref:
         ```tsx
         <div ref={phoneRef}>
           <PhoneInput name="phone" error={fieldErrors.phone ? " " : undefined} ... />
         </div>
         ```

    7. Clear errors on form focus/change:
       - On input change, clear that field's error state
       - On new submission, reset all error states

    Note: Use "gentle" severity (pulse animation) per CONTEXT.md for form validation errors.
  </action>
  <verify>
    - `grep "useShake" website/components/sections/conversion/LeadCaptureForm.tsx` shows import and usage
    - `grep "error=" website/components/sections/conversion/LeadCaptureForm.tsx` shows error prop usage
    - `npx tsc --noEmit` passes
    - Dev server: Submit form with invalid data shows:
      - Red border on inputs (destructive styling)
      - Gentle pulse/shake animation
      - Error clears when user types
  </verify>
  <done>LeadCaptureForm shows error shake and destructive styling on validation failure</done>
</task>

</tasks>

<!-- Task 2 REMOVED: PhoneInput already supports error prop (line 15: error?: string, lines 49-52 apply destructive styling) -->

<verification>
1. **TypeScript**: `npx tsc --noEmit` passes
2. **Visual testing** (dev server):
   - Submit form with empty fields
   - Observe: red borders, shake animation, error message
   - Start typing in a field
   - Observe: that field's error clears, shake stops
3. **Animation timing**: shake feels "gentle" not jarring (1-2 pulse cycles)
4. **Accessibility**: inputs have aria-invalid="true" when error
</verification>

<success_criteria>
- useShake hook imported and wired to form inputs
- Input error prop passed based on validation state
- PhoneInput error prop passed (with boolean-to-string conversion)
- Gentle shake animation triggers on form error
- Error state clears when user interacts with field
</success_criteria>

<output>
After completion, create `.planning/phases/24-micro-interactions/24-05-SUMMARY.md`
</output>
