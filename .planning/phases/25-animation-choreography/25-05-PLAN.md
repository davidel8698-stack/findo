---
phase: 25-animation-choreography
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - website/components/sections/hero/ActivityFeed.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Activity feed waits for hero-entrance-complete event before starting animation"
    - "Animation starts within 50ms of event firing"
    - "Fallback timeout triggers after 2000ms if event never fires"
  artifacts:
    - path: "website/components/sections/hero/ActivityFeed.tsx"
      provides: "Event-synchronized animation start"
      contains: "hero-entrance-complete"
  key_links:
    - from: "ActivityFeed.tsx"
      to: "hero-entrance-complete event"
      via: "window.addEventListener"
      pattern: "addEventListener.*hero-entrance-complete"
---

<objective>
Synchronize ActivityFeed animation with hero entrance choreography.

Purpose: The ActivityFeed currently starts independently via requestIdleCallback, which breaks the 7-phase hero entrance choreography. The feed should wait for the hero-entrance-complete event (dispatched at 1000ms) before starting its animation.

Output: ActivityFeed.tsx that listens for hero-entrance-complete event and only starts animation after receiving it.
</objective>

<execution_context>
@C:\Users\דודאלמועלם\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\דודאלמועלם\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-animation-choreography/25-VERIFICATION.md

# Gap context from VERIFICATION.md:
The useHeroEntrance hook dispatches hero-entrance-complete event at 1000ms mark (Phase 7 of hero entrance).
ActivityFeed must listen for this event instead of using requestIdleCallback independently.

# Existing code context:
@website/lib/hooks/useHeroEntrance.ts (dispatches event at line 58 and 118)
@website/components/sections/hero/ActivityFeed.tsx (currently uses requestIdleCallback at line 118-127)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event-synchronized animation trigger to ActivityFeed</name>
  <files>website/components/sections/hero/ActivityFeed.tsx</files>
  <action>
Refactor the useEffect in ActivityFeed.tsx to:

1. Add state to track hero entrance completion:
   ```tsx
   const [heroEntranceComplete, setHeroEntranceComplete] = useState(false);
   ```

2. Add a separate useEffect that listens for the hero-entrance-complete event:
   ```tsx
   useEffect(() => {
     const handleHeroComplete = () => {
       setHeroEntranceComplete(true);
     };

     window.addEventListener("hero-entrance-complete", handleHeroComplete);

     // Fallback: if event doesn't fire within 2000ms, start anyway
     // This handles edge cases like component mounting after hero is already complete
     const fallbackTimeout = setTimeout(() => {
       setHeroEntranceComplete(true);
     }, 2000);

     return () => {
       window.removeEventListener("hero-entrance-complete", handleHeroComplete);
       clearTimeout(fallbackTimeout);
     };
   }, []);
   ```

3. Modify the existing animation useEffect to only run when heroEntranceComplete is true:
   - Add `heroEntranceComplete` to the dependency array
   - Add early return if `!heroEntranceComplete`
   - Remove the requestIdleCallback wrapper entirely (no longer needed - the event already provides proper timing)
   - Keep the Safari setTimeout fallback logic but apply it to the animation start, not the idle callback

The final animation useEffect should look like:
```tsx
useEffect(() => {
  if (!heroEntranceComplete) return;

  const startAnimation = () => {
    if (!containerRef.current) return;
    // ... existing GSAP timeline code ...
  };

  // Small delay to ensure DOM is ready after state change
  const timeoutId = setTimeout(startAnimation, 50);
  return () => clearTimeout(timeoutId);
}, [heroEntranceComplete, removeWillChange]);
```

4. Update the JSDoc comment for the component to reflect the new behavior:
   - Remove mention of requestIdleCallback
   - Add note about hero-entrance-complete event synchronization
  </action>
  <verify>
1. Build succeeds: `cd website && npm run build`
2. Grep confirms event listener: `grep -n "hero-entrance-complete" website/components/sections/hero/ActivityFeed.tsx`
3. Grep confirms no more requestIdleCallback: `grep -c "requestIdleCallback" website/components/sections/hero/ActivityFeed.tsx` returns 0
  </verify>
  <done>
ActivityFeed waits for hero-entrance-complete event before starting animation. Fallback timeout of 2000ms ensures animation still works if event is missed.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>ActivityFeed now synchronizes with hero entrance choreography via hero-entrance-complete event</what-built>
  <how-to-verify>
1. Run `cd website && npm run dev`
2. Open browser to http://localhost:3000
3. Open DevTools Console
4. Hard refresh (Ctrl+Shift+R) to see full entrance sequence
5. Watch for: Activity feed cards should NOT appear until ~1 second after page load (after hero headline, CTAs, and phone mockup animate in)
6. The sequence should feel choreographed: headline -> CTAs -> phone -> THEN activity cards slide in

If activity cards appear immediately or before the phone mockup, the synchronization is broken.
  </how-to-verify>
  <resume-signal>Type "approved" if activity feed animates after hero entrance, or describe timing issues observed</resume-signal>
</task>

</tasks>

<verification>
1. Build passes without errors
2. No TypeScript errors in ActivityFeed.tsx
3. Event listener for hero-entrance-complete present
4. requestIdleCallback removed (replaced by event-driven trigger)
5. Visual: Activity feed starts after hero entrance completes (~1000ms)
</verification>

<success_criteria>
- ActivityFeed waits for hero-entrance-complete event
- Animation starts within 50ms of event firing
- Fallback timeout (2000ms) prevents broken state if event missed
- No regression in animation quality or timing
- Build succeeds, no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/25-animation-choreography/25-05-SUMMARY.md`
</output>
